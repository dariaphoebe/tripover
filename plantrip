#!/usr/bin/perl -W

# plantrip - local commandline client for tripover

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014-2015 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# rudimentary interface and implementation : to be elaborated

# post trip requests to a local queue, and watch that queue for answers
# the queue location is configured in the server, yet created here if nonexistent

use 5.012;
use strict;

use POSIX ();
use POSIX qw(strftime);
use Fcntl ':mode';

my $version_maj = 0;
my $version_min = 22;
my $lastchanged = "19 feb 2015";

my $copyright = "Copyright (C) 2014-2015, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $currentconfig = 'tripover.cfg.cur';
my $querydirvar = 'querydir';
my $querydir;

my $portrefname = 'portrefs.txt';

my $timeout = 60; # seconds

my $agelimit = 60; # seconds

# defaults, modifyable with 'set' cmd or args
my $maxstop = 4;
my $maxnetstop = 4;
my $dayrange = 3;
my $startdate = 0; # implies start of service
my $mintt = 5;
my $maxtt = 120;
my $transfercost = 10;
my $walklimit = 1000;
my $sumwalklimit = 1500;
my $tzdef = 'Australia/Brisbane';
my $tz;
my $utcofs = '+10:00';

my $utcofs12 = 2200;  # biased coded decimal
my $utcofs12_def = 2200;
my $utcofsmin = 10 * 60;
my $sysutcofs;  # utc offset for current system

my $testiters = 1000;

my $stats_trip = 0;
my $stats_notrip = 0;
my $stats_error = 0;

# stop at compile-time warnings
local $SIG{__WARN__} = sub { print "$_[0]\n"; exit 1; };

my $logname = 'plantrip.log';
my $logfd;

# rotate log
if (-t STDOUT) {
  for (my $bck = 8; $bck >= 0; $bck--) {
    rename($logname . '.' . $bck,$logname . '.' . ($bck+1)) if (-f $logname . '.' . $bck);
  }
  rename($logname,$logname . '.0') if -f $logname;
  open($logfd,'>:encoding(UTF-8)',$logname) or print("cannot create $logname:$!");
}

# unbuffered i/o
my $orgfh = select STDOUT; $| = 1; select STDERR; $| = 1; select $orgfh;

binmode(STDOUT,':utf8');

my %portnames;
my %portids;
my %idbysub;
my (%portlats,%portlons);
my $portcnt = 0;

my ($latscale,$lonscale);

sub msg($) {
  my ($m) = @_;

  print("$m\n");
  print($logfd "$m\n") if defined $logfd;
  return 1;
}

sub vrb($)     { msg("$_[0]") if $verbose; return 1; }
sub info($)    { return msg("$_[0]"); }
sub warning($) { return msg("warning: $_[0]"); }
sub error($)   { msg("error: $_[0]"); return 0; }

sub error_exit($) { print ("error: $_[0]\n"); exit 1; }

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub filepatindir($$$$)
{
  my ($pat,$stamp,$clientid,$dir) = @_;

  my ($dh,$serverid,$tstamp,$tid,$hstamp,$hid,$name);
  my @names;

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    ($hstamp,$hid,$serverid) = ($name =~ $pat);
    next unless (defined $hstamp and defined $hid and defined $serverid);
    $tstamp = hex($hstamp);
    $tid = hex($hid);
    if ($tstamp == $stamp and $tid == $clientid)  {
      vrb("reply handled by server $serverid");
      return $serverid;
    } else { vrb("reply from $tstamp $tid, expect $stamp $clientid $serverid"); }
  }
  return '';
}

# catchall for any leftover file in query queue.
sub agedir($$)
{
  my ($dir,$limit) = @_;

  my ($dh,$serverid,$tstamp,$tid,$name,$path);
  my @names;

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    next if $name eq '.' or $name eq '..';

    $path = $dir . '/' . $name;

    stat($path) or return error("cannot access $path: $!");
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
    return error("$path is not a regular file") unless S_ISREG($mode);

    if ($mtime < $limit)  {
      vrb("removing $path on timestamp $mtime below $limit");
      return 1 if $dryrun;
      unlink $path or return error("cannot remove $path: $!");
    }
  }
  return 1;
}

my $pi = 3.141592655;
my $geolow = $pi * 2.0e-5; # ~500 m
my $geolimit = $pi * 1.0e-7;
my $mean_earth_radius = 6371.0;
my $approx_surface = sqrt($mean_earth_radius * $mean_earth_radius + $mean_earth_radius * $mean_earth_radius);

sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

# Adapted from Tripover:math.c which in turn is adapted from Wikipedia article
sub geodist($$$$)
{
  my ($slat,$slon,$lat,$lon) = @_;

  my ($dist,$dlat,$dlon);

  my $phi1 = ($slat * $pi) / 180;
  my $lam1 = ($slon * $pi) / 180;
  my $phi2 = ($lat * $pi) / 180;
  my $lam2 = ($lon * $pi) / 180;

  my $dlam = $lam2 - $lam1;
  my $dphi = $phi2 - $phi1;

  if (abs($dlam) < $geolow and abs($dphi) < $geolow) { # trivial case: assume flat
    if (abs($dlam) < $geolimit and abs($dphi) < $geolimit) { # flush to zero
      return 0;
    }
    $dlat = $dlam * $approx_surface * 2 / $pi;
    $dlon = ($dphi * $approx_surface * 2) / $pi;
    $dist = sqrt( ($dlat * $dlat) + ($dlon * $dlon));
    return $dist;
  }

  my ($d,$dsig);

  $d = sin($phi1) * sin($phi2) + cos($phi1) * cos($phi2) * cos($dlam);
  if ($d >= 1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }
  elsif ($d <= -1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }

  $dsig = acos($d);

  return $dsig * $mean_earth_radius;
}

my $haveportrefs = 0;

# read port to id mappings
sub readportrefs($)
{
  my ($fname) = @_;

  my ($id,$subid,$name,$lcname,$nlen,$lat,$lon);
  my ($fh,$line,$c,$var,$val);

  open($fh,'<:encoding(UTF-8)',$fname) or error_exit("cannot open $fname: $!");

  my @lines = readline($fh);
  unless (scalar @lines) { error_exit("$fname is empty"); }

  foreach $line (@lines) {
    next unless length($line);
    $c = substr($line,0,1);
    next if $c eq '#';
    if ($c eq '.') {
      ($var,$val) = split("\t",substr($line,1));
      $tzdef = $val if $var eq 'tz';
      $latscale = $val if $var eq 'latscale';
      $lonscale = $val if $var eq 'lonscale';
      next;
    }
    ($id,$subid,$name,$lat,$lon) = split("\t",$line);
    next unless defined $id and defined $name;
    $lcname = lc($name);
    $portnames{$name} = $subid;
    $portnames{$lcname} = $subid;
    $portids{$subid} = $name unless defined $portids{$subid};
    $idbysub{$subid} = $id;
    $portlats{$subid} = $lat;
    $portlons{$subid} = $lon;
  }
  $portcnt = scalar(keys %portids);
  vrb("$portcnt ports");

  $haveportrefs = 1;
}

# returns sub-id by name
sub portbyname($)
{
  my ($name) = @_;

  my ($port,$id,$subid,$seq,$lcname,$cname,$plen,$line);
  my @plist;

  readportrefs($portrefname) unless $haveportrefs;

  $lcname = lc($name);
  if (exists($portnames{$name})) { return $portnames{$name}; }
  if (exists($portnames{$lcname})) { return $portnames{$lcname}; }

  while (($cname,$subid) = each %portnames) {
    next unless index($cname,$name) == 0;
    push @plist,$subid;
  }
  return $plist[0] if @plist == 1 and length($name) > 3;

  if (@plist == 0) {
    while (($cname,$subid) = each %portnames) {
      next unless index($cname,$name) > 0;
      push @plist,$subid;
    }
  }
  $plen = scalar(@plist);
  return $plist[0] if $plen == 1 and length($name) > 3;
  if ($plen == 0) {
    info("no matches for '$name'");
    return '';
  }

  return $plist[0] if $plen == 1;
  info("$plen matches for $name");
  @plist = splice @plist,0,30;

  $seq = 1;
  foreach $subid (@plist) {
    printf("%2u %s\n",$seq++,$portids{$subid});
  }
  unless (-t STDIN) {
    print("noninteractive mode: first match chosen\n");
    return $plist[0];
  }

  do {
    print("\nChoose port by number or q to quit: ");
    $line = <STDIN>;
    next unless defined $line and length($line);
    $line = trimws($line);
    next unless length($line);
    return '' if $line eq 'q' or $line eq 'x';
    if ($line =~ qr'^[0-9]+$') {
      $seq = $line;
      if ($seq <= $plen and $seq != 0) {
        return $plist[$seq - 1];
      } else {
        print("port number not in above list\n");
      }
    } else {
      print("expected port number or command\n");
    }
  } while 1;

  return '';
}

sub portbygeo($$)
{
  my ($lat,$lon) = @_;
  my ($clat,$clon,$dist,$lodist,$loid,$id,$name);

  readportrefs($portrefname) unless $haveportrefs;

  $lodist = 999999999; $loid = 0;
  while (($id,$name) = each %portids) {
    $clat = $portlats{$id};
    $clon = $portlons{$id};
    $clat = ($clat / $latscale) - 90;
    $clon = ($clon / $lonscale) - 180;

    $dist = geodist($lat,$lon,$clat,$clon);
    if ($dist < $lodist) { vrb("dist $dist id $id $name"); $lodist = $dist; $loid = $id; }
  }
  warning("$lat,$lon not found") unless exists $portids{$loid};

  return $loid;
}

sub doplan($$$$$$)
{
  my ($dep,$arr,$dayrange,$startdate,$starttime,$utcofs12) = @_;
  my ($qstr);

  $qstr = "dep i $dep\narr i $arr\ntspan i $dayrange\n";
  $qstr .= "deptmin i $startdate\ndepttmin i $starttime\n";
  $qstr .= "mintt i $mintt\nmaxtt i $maxtt\n";
  $qstr .= "costperstop i $transfercost\n";
  $qstr .= "walklimit i $walklimit\nsumwalklimit i $sumwalklimit\n";
  $qstr .= "histop i $maxstop\nnethistop i $maxnetstop\n";
  $qstr .= "utcofs i $utcofs12\n";

  vrb("\n$qstr\n");

  query('p','glob',$qstr);
}

sub iplan($$)
{
  my ($dep,$arr) = @_;

  my ($rdep,$rarr,$hh,$mm,$dot,$starttime);
  my $depname = "unknown";
  my $arrname = "unknown";

  if ($haveportrefs) {
    if (exists($portids{$dep})) { $depname = $portids{$dep}; }
    if (exists($portids{$arr})) { $arrname = $portids{$arr}; }
  }

  if ($dep ne '*' and $dep == $arr) {
    info("departure and arrival identical");
    return 1;
  }

  unless (defined $tz) {
    $utcofs12 = $utcofs12_def;
    $hh = ($utcofs12 / 100) - 12;
    $mm = $utcofs12 % 100;
    $utcofsmin = $hh * 60 + $mm;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    $tz = ofs2tz($utcofs);
    vrb("using default display tz $tz utc$utcofs from portrefs");
  }

  $dot = index($startdate,'.');
  $starttime = 0;
  if ($dot == 0) {
    $starttime = substr($startdate,1);
    $startdate = 0;
  } elsif ($dot > 0) {
    $starttime = substr($startdate,$dot+1);
    $startdate = substr($startdate,0,$dot);
    $starttime = 0 unless defined $starttime and length $starttime;
  }

  my $rndcnt = 0;

  if ($dep eq '*') {
    readportrefs($portrefname) unless $haveportrefs;

    foreach $rdep (keys %portids) {
      $rdep = $idbysub{$rdep};
      if (exists($portids{$rdep})) { $depname = $portids{$rdep}; }
      else { $depname = "unknown"; }

      if ($arr eq '*') {
        foreach $rarr (keys %portids) {
          $rarr = $idbysub{$rarr};
          next if $rdep == $rarr;
          if (exists($portids{$rarr})) { $arrname = $portids{$rarr}; }
          else { $arrname = "unknown"; }
          info("from $depname to $arrname  v    $rdep-$rarr");
          doplan($rdep,$rarr,$dayrange,$startdate,$starttime,$utcofs12);
          last unless $rndcnt++ < $testiters;
        }
      } else {
        next if $rdep == $arr;
        doplan($rdep,$arr,$dayrange,$startdate,$starttime,$utcofs12);
        last unless $rndcnt++ < $testiters;
      }
      last unless $rndcnt++ < $testiters;
    }
    info("$stats_trip found, $stats_notrip no route $stats_error no time");
    return;
  }
  info("from $depname ($dep) to $arrname ($arr) start $startdate.$starttime for $dayrange days in $maxstop stops utc $utcofs");
  doplan($dep,$arr,$dayrange,$startdate,$starttime,$utcofs12);
}

sub plan($$)
{
  my ($depname,$arrname) = @_;

  my ($dep,$arr);
  my $isgeo = qr'^\s*([+-]?[0-9]+\.[0-9]+)\s*,\s*([+-]?[0-9]+\.[0-9]+)\s*$';
  my ($dlat,$dlon,$alat,$alon);

  unless (defined $depname and length($depname)) {
    print('depart from: ');
    $depname=<STDIN>;
  }
  return unless defined $depname and length($depname);
  unless (defined $arrname and length($arrname)) {
    print('arrive at: ');
    $arrname=<STDIN>;
  }
  return unless defined $arrname and length($arrname);

  ($dlat,$dlon) = ($depname =~ $isgeo);
  if (defined $dlat and defined $dlon) {
    $dep = portbygeo($dlat,$dlon)
  } else {
    $dep = portbyname($depname);
  }
  return 1 unless length($dep) and exists $portids{$dep};
  info("$depname resolved into $portids{$dep}");

  ($alat,$alon) = ($arrname =~ $isgeo);
  if (defined $dlat and defined $dlon) {
    $arr = portbygeo($alat,$alon) 
  } else {
    $arr = portbyname($arrname);
  }
  return 1 unless length($arr) and exists $portids{$arr};
  info("$arrname resolved into $portids{$arr}");

  my $pdep = $idbysub{$dep};
  my $parr = $idbysub{$arr};

  iplan($pdep,$parr);
}

sub getvar($)
{
  my ($var) = @_;

  unless (defined $var and length($var)) {
    print('variable (? for list): ');
    $var=<STDIN>;
  }
  return unless defined $var and length($var);
  if (substr($var,0,1) eq '?') {
    info('startdate - search for departure from this day onward');
    info('daterange - number of days to search');
    info('transferlimit - maximum number of transfers allowed');
    info('timezone - specify timezone to show results in');
    info('utcoffset- idem, in hh:mm offset from UTC');
    return;
  }
  info("startdate: $startdate") if index($var,'startdate') >= 0;
  info("daterange: $dayrange") if index($var,'daterange') >= 0;
  info("transferlimit: $maxstop") if index($var,'transerlimit') >= 0;
  info("timezone: $tz") if index($var,'timezone') >= 0;
  info("utcoffset: $utcofs") if index($var,'utcoffset') >= 0;
}

sub setvar($$)
{
  my ($var,$val) = @_;

  my ($hh,$mm,$col);

  unless (defined $var and length($var)) {
    print('variable: ');
    $var=<STDIN>;
  }
  return 0 unless defined $var and length($var);
  unless (defined $var and length($var)) {
    print('value: ');
    $var=<STDIN>;
  }
  return 0 unless defined $var and length($var);

  $val = '' unless defined $val and length $val;

  vrb("set $var to '$val'");
  if ($var eq 'date' or $var eq 'startdate') {
    $startdate = $val;
  } elsif ($var eq 'days') {
    $dayrange = $val;
  } elsif ($var eq 'maxstops') {
    $maxstop = $val;
  } elsif ($var eq 'maxnetstop') {
    $maxnetstop = $val;
  } elsif ($var eq 'maxtxtime') {
    $maxtt = $val;
  } elsif ($var eq 'mintxtime') {
    $mintt = $val;
  } elsif ($var eq 'transfercost') {
    $transfercost = $val;
  } elsif ($var eq 'walklimit') {
    $walklimit = $val;
  } elsif ($var eq 'sumwalklimit') {
    $sumwalklimit = $val;
  } elsif (index($var,'timezone') >= 0) {
    ($hh,$mm) = tz2ofs($val);
    return 0 unless defined $hh;
    $tz = $val;
    $utcofs12 = ($hh + 12) * 100 + $mm;
    $utcofsmin = $hh * 60 + $mm;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    info("new utcofs $hh:$mm");
  } elsif (index($var,'utcoffset') >= 0) {
    $col = index($val,':');
    return 0 unless $col > 0;
    $hh = substr($val,0,$col);
    $mm = substr($val,$col+1);
    $utcofsmin = $hh * 60 + $mm;
    $utcofs12 = int(($hh + 12) * 100 + $mm);
    info("new utcofs $hh:$mm");
    $tz = ofs2tz($val);
    info("new tz $tz");
  } else {
    return error("unknown variable $var: check online help");
  }
  return 1;
}

sub set_var($)
{
  my ($arg) = @_;
  my ($eq,$var,$val);

  vrb("arg '$arg'");
  $eq = index($arg,'=');
  if ($eq > 0) {
    $var = substr($arg,0,$eq);
    $val = substr($arg,$eq + 1);
    setvar($var,$val);
    return '';
  } else { return $arg . ' '; }
}

sub stop($)
{
  my ($cmd) = @_;

  query('s','glob','');
}

my $clientid = "$$";

sub ret_close_err($$)
{
  my ($fh,$msg) = @_;

  error("$msg");
  close($fh);
  return 0;
}

# submit the query and wait for corresponding reply
sub query($$$)
{
  my ($cmd,$region,$str) = @_;
  my ($stamp,$qfile,$qname,$qname_new,$qname_sub,$qname_rep,$qname_rcv,$serverid);

# prepare the query. use atomic file renames, server does the same
# query filename: 
#  [a-z]_     command
#  [a-z]_     (format todo) region
#  [0-9a-f]_  hex timestamp in sec plus _
#  [0-9a-f]   hex client id
#  .sub

# file content:
# list of (var type value) each on 1 line
# var:  [a-z] dep arr
# type [is] i = int s = string

  $stamp = time();
  $qname = sprintf("%s/%s_%s_%010x_%04x",$querydir,$cmd,$region,$stamp,$clientid);
  $qname_new = $qname . '.new';
  $qname_sub = $qname . '.sub';
  vrb("create $qname_new");

  if ($dryrun) {
    info("$cmd $str");
    return 1;
  }

  open($qfile,'>',$qname_new) or error_exit("cannot create $qname_new: $!");
  print($qfile $str . "\n");
  close($qfile);

  vrb("submit '$cmd' '$str'");

# rename to submit: server will pick up from here. reply has serverid appended
  vrb("rename to $qname_sub");
  rename($qname_new,$qname_sub);

  # cmd,region,stamp,clientid,serverid
  my $pat = qr'^[a-z]_[a-z]+_([0-9a-f]+)_([0-9a-f]+)_([0-9a-f]+)\.rep';

  while (time() - $stamp < $timeout) {
    select(undef,undef,undef,0.01);  # = sleep 10 millisec
    $serverid = filepatindir($pat,$stamp,$clientid,$querydir);
    last if length($serverid);
  }
  unless (length($serverid)) {
    info("no reply in $timeout sec");
    return;
  }

  # reply present: read and delete
  $qname_rep = $qname . '_' . $serverid . '.rep';
  $qname_rcv = $qname . '_' . $serverid . '.rcv';

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  my $reply;
  open($reply,'<',$qname_rep) or return error("cannot open $qname_rep:$!");

  stat $reply or return ret_close_err($reply,"cannot access $qname_rep: $!");
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
  return ret_close_err($reply,"$qname_rep is not a regular file") unless S_ISREG($mode);
  return ret_close_err($reply,"$qname_rep is empty") unless $size > 0;
  return ret_close_err($reply,"$qname_rep is empty") unless -r $qname_rep;

  my @lines = readline($reply);
  close($reply);
  unlink $qname_rep or return error("cannot remove $qname_rep:$!");

  return error("$qname_rep is empty") unless (scalar @lines);

  if ($cmd eq 'p') {
    if (index($lines[0],'no trip') >= 0) { $stats_notrip++; }
    elsif (index($lines[0],'error code') >= 0) { $stats_error++; }
    else { $stats_trip++; }
  }
  print @lines;
  print($logfd @lines) if defined $logfd;
  unlink $qname_rcv or return error("cannot remove $qname_rcv:$!");
}

# issue an update ( = realtime) command : similar to query, yet no response
sub updcmd($)
{
  my ($str) = @_;
  my ($stamp,$qfile,$qname,$qname_new,$qname_sub,$qname_rep,$qname_rcv,$serverid);
  my $cmd = 'u';

# prepare the query. use atomic file renames, server does the same
# query filename: 
#  [a-z]_     command
#  [a-z]_     (format todo) region
#  [0-9a-f]_  hex timestamp in sec
#  [0-9a-f]   hex client id
#  .sub

# file content is lines with list of hex integers only:
# first number is command : 0=fares 1=trips 2=routes 3=stops
# fares : rrid,t0,(dt mask fare[n])+

  $stamp = time();
  $qname = sprintf("%s/%s_glob_%010x_%04x",$querydir,$cmd,$stamp,$clientid);
  $qname_new = $qname . '.new';
  $qname_sub = $qname . '.sub';
  vrb("create $qname_new");

  if ($dryrun) {
    info("$qname");
    info("  $str");
    return 1;
  }

  open($qfile,'>',$qname_new) or error_exit("cannot create $qname_new: $!");
  print($qfile $str);
  close($qfile);

  vrb("submit '$cmd' '$str'");

# rename to submit: server will pick up from here.
  vrb("rename to $qname_sub");
  rename($qname_new,$qname_sub);
}

sub cntbits($)
{
  my $x = shift;
  my $n = 0;

  $x = hex($x) & 0xf;
  while ($x) { $n++ if ($x & 1); $x >>= 1; }
  return $n
}

my $nix2to = 946684800; # seconds Epoch 2000 since 1970

# from yyyymmdd to minutes since Epoch
sub cd2day($)
{
  my $cd = shift;

  my $dd = int($cd % 100); $cd /= 100;
  my $mm = int($cd % 100);
  my $yy = int($cd / 100);
  my $nixsec = int POSIX::mktime(0,0,0,$dd,$mm-1,$yy-1900,0,0,0);
  my $tomin = ($nixsec - $nix2to) / 60;
  return int($tomin + $sysutcofs);
}

# hhmm to minutes
sub cd2time($)
{
  my $cd = shift;

  my $hh = int($cd / 100);
  my $mm = int($cd % 100);
  return int($hh * 60 + $mm);
}

sub update($$$$$$)
{
  my ($rid,$dep,$arr,$cd_day0,$cd_time0,$xargs) = @_;
  my ($cd_day,$cd_time,$t,$dt,$mask,$farecnt);

  $xargs = trimws($xargs);

  info("rid $rid t0 $cd_day0 xargs '$xargs'");
  my $d = cd2day($cd_day0);
  my $tt = cd2time($cd_time0);
  my $t0 = int($d + $tt - $utcofsmin);

  my @args = split(' ',$xargs);
  my $argcnt = scalar(@args);
  my $argno = 0;
  my $str = sprintf("0 %x %x %x %x ",$rid,$dep,$arr,$t0);
  while ($argno + 3 < $argcnt) {
    $cd_day = $args[$argno];
    $cd_time = $args[$argno+1];
    $d = cd2day($cd_day);
    $tt = cd2time($cd_time);
    $t = int($d + $tt - $utcofsmin);
    return info("t $t t0 $t0") if ($t < $t0);
    $dt = $t - $t0;
    $mask = $args[$argno+2];
    $argno += 3;
    $farecnt = cntbits($mask);
    return info("farecnt $farecnt argno $argno") if ($argno + $farecnt >= $argcnt);
    $str .= sprintf("%x %x ",$dt,hex $mask);
    while ($farecnt--) { $str .= sprintf("%x ",$args[$argno++]); }
  }
  $str .= "\n";
  updcmd($str);
}

# obtain query dir from current config
sub readcfg()
{
  my ($cfg,$var,$val);

  open($cfg,'<',$currentconfig)  or error_exit("cannot open $currentconfig: $!\n\nCheck if the tripover server is running in this dir");

  my @cfglines = readline($cfg);
  unless (scalar @cfglines) { error_exit("$currentconfig is empty\n\nCheck if the tripover server is running in this dir"); }

  my $varisval = qr'^([-a-zA-Z0-9_.]+)\s*=?\s*([-a-zA-Z0-9_.]+)';

  foreach my $line (@cfglines) {
    ($var,$val) = ($line =~ $varisval);
    next unless defined $var;
    next if $var ne $querydirvar;
    $querydir = $val;
    last;
  }
  error_exit("empty query config") unless length($querydir);
  vrb("query dir $querydir/");
}

sub usage()
{
  info("usage: plantrip [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("plan <from> <to>   plan a trip");
  info("stop               stop server");
  info("set <var> <value>  set variable");
  info("get [var]          get variable (? for list)\n");
  info("without command, interactive mode is entered\n");

  info("variables: specify as var=value on plan commands");
  info("startdate          start date / time for depart : yyyymmdd[.hhmm]");
  info("days               number of days to consider (search horizon) [3]");
  info("maxstops           max number of transfers to consider [4]");
  info("maxnetstop         max number of transfers to base on precomputed info [3]");
  info("maxtxtime          max transfer (waiting time) in minutes [120]");
  info("mintxtime          min tranfer time in minutes [5]");
  info("transfercost       extra cost per tranfser in minutes [10]");
  info("walklimit          max walk distance in meters for a single go [1000]");
  info("sumwalklimit       max summed up walk distance in meters [3000]");
  info("timezone           timezone to use : country/city");
  info("utcoffset          UTC offset to use [+-]hh:mm\n");
  info("example:  plan beerwah elimbah date=20150218.0800 transfercost=0 walklimit=300");
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover commandline client version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

my (%tzofs,%tzdstofs);

sub readtzinfo()
{
  my $tzname = 'tzinfo.txt';
  my $tzfile;
  my $col = 0;
  my ($line,$tzstr,$tz,$ofs,$dstofs,$a,$b,$c,$alt);
  my @tzs;
  my $tzcol = 3;
  my $ofscol = 5;
  my $dstofscol = 6;

  # read timezone info from wikipedia export, in turn from iana TZ database 
  open($tzfile,'<:encoding(UTF-8)',$tzname) or return warning("cannot open $tzname:$!");
  my @lines = readline($tzfile);
  close($tzfile);
  for $line (@lines) {
    next unless length($line);
    next if index($line,'#') == 0;

    @tzs = ();
    if (index($line,'|-') == 0) {
      $col = 0;
    } elsif (index($line,'|') == 0) {
      $line = substr($line,1);
      $col++;
    }

    if ($col == $tzcol) {
      $a = index($line,'[[');
      $b = index($line,']]');
      $tzstr = substr($line,$a+2,$b-3);
    } elsif ($col == $ofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      $ofs = substr($line,$a+5,$c-6);
      if (substr($ofs,0,1) eq "\x{2212}") { $ofs = '-' . substr($ofs,1); }
    } elsif ($col == $dstofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      if ($a < 0) { vrb("no dstofs for $tz abc $line"); $dstofs = $ofs; }
      else { $dstofs = substr($line,$a+5,$c-6); }
    } elsif ($col > $dstofscol) {
      while (length($tzstr)) {
        $alt = index($tzstr,'|');
        if ($alt < 0) {
          push @tzs,$tzstr;
          $tzstr = '';
        } else {
          $tz = substr($tzstr,0,$alt);
          vrb("tz '$tz' ofs '$ofs'");
          push @tzs,$tz;
          $tzstr = substr($tzstr,$alt + 1);
          vrb("tzstr '$tzstr'");
        }
      }
      foreach $tz (@tzs) {
        $tzofs{$tz} = $ofs;
        $tzdstofs{$tz} = $dstofs;
        vrb("tz '$tz' ofs '$ofs'");
      }
      $col = 0;
    }
  }
  return 1;
}

sub tz2ofs($)
{
  my ($str) = @_;
  my ($hh,$mm,$hhmm);

  unless (exists($tzofs{$str})) { warning("no timezone info for $str"); return (0,0); }

  $hhmm = $tzofs{$str};
  $a = index($hhmm,':');
  $hh = substr($hhmm,0,$a);
  $mm = substr($hhmm,$a+1);
  vrb("utc offset hh $hh mm $mm");
  return ($hh,$mm);
}

sub ofs2tz($)
{
  my ($hhmm) = @_;
  my ($hm,$str) = @_;

  while (($str,$hm) = each %tzofs) {
    return $str if $hm eq $hhmm;
  }
  return $hhmm;
}

sub init()
{
  readcfg();
  unless (-d $querydir) {
    info("creating configured query dir $querydir");
    mkdir($querydir) || error_exit("cannot create query dir:$!");
  }
  readtzinfo();
  my $sec70 = time;
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $sec70;
  my $ltsec = strftime('%s',$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,0);
  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime $sec70;
  my $utcsec = strftime('%s',$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,0);
  $sysutcofs = int(($ltsec - $utcsec) / 60);
  info("localtime $ltsec utc $utcsec ofs $sysutcofs");
}

my ($arg,$xargs,$opt,$inopt,$cmd,$line,$prvline);
my ($dep,$arr,$rid,$d0,$t0);
my @args;

my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
$startdate = sprintf("%04u%02u%02u.%02u%02u",$year+1900,$mon+1,$mday,$hour,$min);
vrb("$startdate");

if (@ARGV > 0) {
  foreach $arg (@ARGV) {
    if (substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
      if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
    }
  }

  $inopt = 1;
  foreach $arg (@ARGV) {
    if ($inopt and substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
      elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
      elsif ($opt eq 'h' or $opt eq 'help') { usage(); exit 1; }
      elsif ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      else { info("ignoring unknown option -$opt"); }
    } else {
      $inopt = 0;
      push(@args,$arg);
    }
  }

  if (@args > 0) {
    init();
    $cmd = $args[0];
    $xargs = '';
    if ($cmd eq 'stop') {
      stop($cmd);
    } elsif ($cmd eq 'plan') {
      exit info("plan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      splice(@args,0,3);
      foreach $arg (@args) { set_var($arg); }
      plan($dep,$arr);
      agedir($querydir,time() - $agelimit);
    } elsif ($cmd eq 'iplan') {
      exit info("iplan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      splice(@args,0,3);
      foreach $arg (@args) { set_var($arg); }
      iplan($dep,$arr);
      agedir($querydir,time() - $agelimit);
    } elsif ($cmd eq 'update') {  # dev provision
      exit info("update needs: 'rid,dep,arr,date,time'") unless (@args > 5);
      $rid = $args[1]; $dep = $args[2]; $arr = $args[3]; $d0 = $args[4]; $t0 = $args[5];
      splice(@args,0,6);
      foreach $arg (@args) { $xargs .= set_var($arg); }
      update($rid,$dep,$arr,$d0,$t0,$xargs);
    } else { info("unknown command"); }
    exit 0;
  }
}

init();

if (-t STDIN) {
  info("entering command loop. commands:\n");
  info("  plan <from> <to> name or coords");
  info("  quit, exit");
}

# loop 
$cmd = ''; $prvline = '';
while ($cmd ne 'quit') {
  print("plantrip % ") if -t STDIN;
  $line = <STDIN>;
  next unless defined $line and length($line);
  next if index($line,'#') == 0;

  $line = trimws($line);
  $line = $prvline if $line eq '!!';
  @args = split(' ',$line);
  $cmd = '';
  $cmd = 'quit' if index($line,'quit') == 0;
  $cmd = 'quit' if index($line,'exit') == 0;
  $cmd = 'plan' if index($line,'plan') == 0;
  $cmd = 'iplan' if index($line,'iplan') == 0;
  $cmd = 'update' if index($line,'update') == 0;
  $cmd = 'stop' if index($line,'stop') == 0;
  $cmd = 'set' if index($line,'set') == 0;
  $cmd = 'get' if index($line,'get') == 0;
  info("unrecognised command '$line'") if length($line) and not length($cmd);
  $prvline = $line;
  if ($cmd eq 'plan') {
    exit info("plan needs 'from' and 'to' arg") unless (@args > 2);
    $dep = $args[1]; $arr = $args[2];
    splice(@args,0,3);
    foreach $arg (@args) { set_var($arg); }
    plan($dep,$arr);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'iplan') {
    exit info("iplan needs 'from' and 'to' arg") unless (@args > 2);
    $dep = $args[1]; $arr = $args[2];
    splice(@args,0,3);
    foreach $arg (@args) { set_var($arg); }
    iplan($dep,$arr);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'update') {  # dev provision
    unless (@args > 5) {
      info("update needs: 'rid,dep,arr,date,time'");
      exit;
    }
    $rid = $args[1]; $dep = $args[2]; $arr = $args[3]; $d0 = $args[4]; $t0 = $args[5];
    splice(@args,0,6);
    foreach $arg (@args) { $xargs .= set_var($arg); }
    update($rid,$dep,$arr,$d0,$t0,$xargs);
  } elsif ($cmd eq 'stop') {
    stop($line);
  } elsif ($cmd eq 'set') {
    setvar($args[1],$args[2]);
  } elsif ($cmd eq 'get') {
    getvar($args[1]);
  }
}
