#!/usr/bin/perl -W

# plantrip - local commandline client for tripover

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014-2015 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# rudimentary interface and implementation : to be elaborated

# post trip requests to a local queue, and watch that queue for answers
# the queue location is configured in the server, yet created here if nonexistent

use 5.012;
use strict;
use utf8;

use POSIX ();
use POSIX qw(strftime);
use Fcntl ':mode';
use Time::HiRes qw(gettimeofday);

my $version_maj = 0;
my $version_min = 28;
my $lastchanged = "7 apr 2015";

my $copyright = "Copyright (C) 2014-2015, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $currentconfig = 'tripover.cfg.cur';
my $querydirvar = 'querydir';
my $querydir;

my $iscgi = 0;

my $repdir = 'rep';
my $repfile = $repdir . '/plantrip.rep';
my $reqid = 0;

my $portrefname = 'portrefs.txt';
my $haveportrefs = 0;
my @portrefs;

my $timeout = 4; # seconds

my $agelimit = 60; # seconds
my $repagelimit = 7200; # seconds

my $foreground = 0;

my $do_lcname = 0;

# defaults, modifyable with 'set' cmd or args
my $maxstop = 6;
my $maxnetstop = 5;

my $plusday = 1;
my $minday = 0;

my $startdatetime = 0; # implies start of service
my $mintt = 5;
my $maxtt = 120;
my $transfercost = 1;
my $walklimit = 1000;
my $sumwalklimit = 1500;
my $tzdef = 'Australia/Brisbane';
my $tz;
my $utcofs = '+10:00';

my $utcofs12 = 2200;  # biased coded decimal
my $utcofs12_def = 2200;
my $utcofsmin = 10 * 60;
my $sysutcofs;  # utc offset for current system

# engineering test provisions
my $testiter = 0;
my $delay = 0;

my $testiters = 1000;

my $stats_trip = 0;
my $stats_notrip = 0;
my $stats_error = 0;

# stop at compile-time warnings
local $SIG{__WARN__} = sub { print "$_[0]\n"; exit 1; };

my $logname = 'plantrip.log';
my $logfd;

# rotate log
if (-t STDOUT) {
  for (my $bck = 8; $bck >= 0; $bck--) {
    rename($logname . '.' . $bck,$logname . '.' . ($bck+1)) if (-f $logname . '.' . $bck);
  }
  rename($logname,$logname . '.0') if -f $logname;
  open($logfd,'>:encoding(UTF-8)',$logname) or print("cannot create $logname:$!");
}

# unbuffered i/o
my $orgfh = select STDOUT; $| = 1; select STDERR; $| = 1; select $orgfh;

binmode(STDOUT,':utf8');

my %portnames;
my %portids;
my %idbysub;
my (%portlats,%portlons,%portrlats,%portrlons,%portmodes);
my $portcnt = 0;

my ($latscale,$lonscale);

sub msg($) {
  my ($m) = @_;

  print("$m\n");
  print($logfd "$m\n") if defined $logfd;
  return 1;
}

sub vrb($)     { msg("$_[0]") if $verbose; return 1; }
sub info($)    { return msg("$_[0]"); }
sub warning($) { return msg("warning: $_[0]"); }

sub error($)
{
  my ($package,$filename,$line,$sub) = caller(0);
  ($package,$filename,$line,$sub) = caller(1) if $sub eq 'main::error';
  msg("error at line $line: $_[0]"); return 0;
}

sub error_exit($) { error($_[0]); exit 1; }

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub filepatindir($$$$)
{
  my ($pat,$stamp,$clientid,$dir) = @_;

  my ($dh,$serverid,$tid,$hstamp,$hid,$name);
  my @names;

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    ($hstamp,$hid,$serverid) = ($name =~ $pat);
    next unless (defined $hstamp and defined $hid and defined $serverid);
    $tid = hex($hid);
    if ($hstamp eq $stamp and $tid == $clientid)  {
      vrb("reply handled by server $serverid");
      return $serverid;
    } else { vrb("reply from $hstamp $tid, expect $stamp $clientid $serverid"); }
  }
  return '';
}

# catchall for any leftover file in query queue.
sub agedir($$)
{
  my ($dir,$limit) = @_;

  my ($dh,$serverid,$tstamp,$tid,$name,$path);
  my @names;

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    next if $name eq '.' or $name eq '..';

    $path = $dir . '/' . $name;

    stat($path) or return error("cannot access $path: $!");
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
    return error("$path is not a regular file") unless S_ISREG($mode);

    if ($mtime < $limit)  {
      vrb("removing $path on timestamp $mtime below $limit");
      return 1 if $dryrun;
      unlink $path or return error("cannot remove $path: $!");
    }
  }
  return 1;
}

my $pi = 3.141592655;
my $pi180 = 0.017453293;
my $geolow = $pi * 2.0e-5; # ~500 m
my $geolimit = $pi * 1.0e-7;
my $mean_earth_radius = 6371.0;
my $approx_surface = sqrt($mean_earth_radius * $mean_earth_radius + $mean_earth_radius * $mean_earth_radius);

sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

# Adapted from Tripover:math.c which in turn is adapted from Wikipedia article
sub geodist($$$$)
{
  my ($slat,$slon,$lat,$lon) = @_;

  my ($dist,$dlat,$dlon);

  my $phi1 = $slat * $pi180;
  my $lam1 = $slon * $pi180;
  my $phi2 = $lat * $pi180;
  my $lam2 = $lon * $pi180;

  my $dlam = $lam2 - $lam1;
  my $dphi = $phi2 - $phi1;

  if (abs($dlam) < $geolow and abs($dphi) < $geolow) { # trivial case: assume flat
    if (abs($dlam) < $geolimit and abs($dphi) < $geolimit) { # flush to zero
      return 0;
    }
    $dlat = $dlam * $approx_surface * 2 / $pi;
    $dlon = ($dphi * $approx_surface * 2) / $pi;
    $dist = sqrt( ($dlat * $dlat) + ($dlon * $dlon));
    return $dist;
  }

  my ($d,$dsig);

  $d = sin($phi1) * sin($phi2) + cos($phi1) * cos($phi2) * cos($dlam);
#  if ($d >= 1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }
#  elsif ($d <= -1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }

  $dsig = acos($d);

  return $dsig * $mean_earth_radius;
}

sub addtorep($$)
{
  my ($txt,$append) = @_;

  my ($fh);

  $append = 0 unless -f $repfile;
  my $mode = ($append ? '>>' : '>');
  open($fh,$mode . ':encoding(UTF-8)',$repfile) or error_exit("cannot open $repfile: $!");
  print($fh "$txt\n");
  print("$txt\n") if $iscgi;
  close $fh;
}

# read port to id mappings
sub readportrefs($)
{
  my ($fname) = @_;

  my ($id,$subid,$name,$lcname,$nlen,$lat,$lon,$modes,$rlat,$rlon);
  my ($fh,$line,$c,$var,$val);

  open($fh,'<:encoding(UTF-8)',$fname) or error_exit("cannot open $fname: $!");

  my @lines = readline($fh);
  unless (scalar @lines) { error_exit("$fname is empty"); }

  foreach $line (@lines) {
    next unless length($line);
    $c = chop $line;
    $line .= $c if $c ne "\n";
    next unless length($line);
    $c = substr($line,0,1);
    next if $c eq '#';

    if ($c eq '.') {
      ($var,$val) = split("\t",substr($line,1));
      $tzdef = $val if $var eq 'tz';
      $latscale = $val if $var eq 'latscale';
      $lonscale = $val if $var eq 'lonscale';
      next;
    }
    ($id,$subid,$name,$lat,$lon,$modes) = split("\t",$line);
    next unless defined $id and defined $name;

    $portnames{$name} = $subid;
    if ($do_lcname) {
      $lcname = lc($name);
      $portnames{$lcname} = $subid;
    }
    $portids{$subid} = $name unless defined $portids{$subid};
    $idbysub{$subid} = $id;
    $rlat = ($lat / $latscale) - 90;
    $rlon = ($lon / $lonscale) - 180;
    $portrlats{$subid} = $rlat;
    $portrlons{$subid} = $rlon;
    $portmodes{$subid} = $modes;
  }
  $portcnt = scalar(keys %portids);
  info("$portcnt ports [name]");

  $haveportrefs = 1;
}

# as above, geocode version
sub readportrefs_geo($)
{
  my ($fname) = @_;

  return if (@portrefs > 0);

#  my ($id,$subid,$name,$lcname,$nlen,$lat,$lon,$modes,$rlat,$rlon);
  my ($fh,$line,$c,$var,$val);

  open($fh,'<:encoding(UTF-8)',$fname) or error_exit("cannot open $fname: $!");

  my @lines = readline($fh);
  unless (scalar @lines) { error_exit("$fname is empty"); }

  foreach $line (@lines) {
    next unless length($line);
    $c = chop $line;
    $line .= $c if $c ne "\n";
    next unless length($line);
    $c = substr($line,0,1);
    next if $c eq '#';

    if ($c eq '.') {
      ($var,$val) = split("\t",substr($line,1));
      $tzdef = $val if $var eq 'tz';
      $latscale = $val if $var eq 'latscale';
      $lonscale = $val if $var eq 'lonscale';
      next;
    }
    push @portrefs,$line;
  }
  $portcnt = scalar @portrefs;
  info("$portcnt ports [geo]");
}

# returns sub-id by name
sub portbyname($)
{
  my ($name) = @_;

  my ($port,$id,$subid,$seq,$lcname,$cname,$plen,$line);
  my @plist;

  readportrefs($portrefname) unless $haveportrefs;

  $lcname = lc($name);
  if (exists($portnames{$name})) { return $portnames{$name}; }
  if (exists($portnames{$lcname})) { return $portnames{$lcname}; }

  while (($cname,$subid) = each %portnames) {
    next unless index($cname,$name) == 0;
    push @plist,$subid;
  }
  return $plist[0] if @plist == 1 and length($name) > 3;

  if (@plist == 0) {
    while (($cname,$subid) = each %portnames) {
      next unless index($cname,$name) > 0;
      push @plist,$subid;
    }
  }
  $plen = scalar(@plist);
  return $plist[0] if $plen == 1 and length($name) > 3;
  if ($plen == 0) {
    info("no matches for '$name'");
    return '';
  }

  return $plist[0] if $plen == 1;
  info("$plen matches for $name");
  @plist = splice @plist,0,30;

  $seq = 1;
  foreach $subid (@plist) {
    printf("%2u %s\n",$seq++,$portids{$subid});
  }
  unless ($iscgi == 0 and -t STDIN) {
    print("noninteractive mode: first match chosen\n");
    return $plist[0];
  }

  do {
    print("\nChoose port by number or q to quit: ");
    $line = <STDIN>;
    next unless defined $line and length($line);
    $line = trimws($line);
    next unless length($line);
    return '' if $line eq 'q' or $line eq 'x';
    if ($line =~ qr'^[0-9]+$') {
      $seq = $line;
      if ($seq <= $plen and $seq != 0) {
        return $plist[$seq - 1];
      } else {
        print("port number not in above list\n");
      }
    } else {
      print("expected port number or command\n");
    }
  } while 1;

  return '';
}

sub portbygeo($$)
{
  my ($lat,$lon) = @_;
  my ($clat,$clon,$dist,$lodist,$loid,$pid,$pname,$fmtdist,$mdist);
  my ($line,$loline);
  my ($id,$subid,$name,$ilat,$ilon,$rlat,$rlon,$modes);

  $lodist = 999999999; $loid = -1;

  for $line (@portrefs) {
    ($id,$subid,$name,$ilat,$ilon,$modes) = split("\t",$line);

    $clat = ($ilat / $latscale) - 90;
    $clon = ($ilon / $lonscale) - 180;

    $dist = geodist($lat,$lon,$clat,$clon);
    if ($dist < $lodist) { $lodist = $dist; $loid = $subid; $loline = $line; }
  }
  if ($loid == -1) {
    warning("$lat,$lon not found");
    return -1;
  }
  ($id,$subid,$name,$ilat,$ilon,$modes) = split("\t",$loline);
  $clat = ($ilat / $latscale) - 90;
  $clon = ($ilon / $lonscale) - 180;

  $pid = $id;

  $mdist = int($lodist * 1000);
  if ($lodist < 1.500) { $fmtdist = $mdist . ' m'; }
  else { $fmtdist = sprintf("%.1f",$lodist) . ' Km'; }

  if ($loid == $pid) {
    info("$lat,$lon $fmtdist from $clat,$clon ID $loid $name");
    $pname = $name;
  } else {
    $pname = '(unavailable)';
    info("$lat,$lon $fmtdist from $clat,$clon ID $loid > $pid $name > $pname");
  }
  # if id >= portcnt, id - portcnt = subid; subid->parent
  info("mode $modes");
  addtorep("# reqid\tdist\tlat\tlon\tid\tpid\tmodes\tname\tpname",0);
  addtorep(".geo\t$reqid\t$mdist\t$clat\t$clon\t$loid\t$pid\t$modes\t$name\t$pname",1);

  return $loid;
}

my $isgeo = qr'^\s*([+-]?[0-9]+\.[0-9]+)\s*,\s*([+-]?[0-9]+\.[0-9]+)\s*$';

sub geocode($$)
{
  my ($lat,$lon) = @_;

  readportrefs_geo($portrefname);
  portbygeo($lat,$lon);
}

sub doplan($$$$$)
{
  my ($dep,$arr,$startdate,$starttime,$utcofs12) = @_;
  my ($qstr);

  $qstr = "dep i $dep\narr i $arr\n";
  $qstr .= "deptmin i $startdate\ndepttmin i $starttime\n";
  $qstr .= "plusday i $plusday minday i $minday\n",
  $qstr .= "mintt i $mintt\nmaxtt i $maxtt\n";
  $qstr .= "costperstop i $transfercost\n";
  $qstr .= "walklimit i $walklimit\nsumwalklimit i $sumwalklimit\n";
  $qstr .= "histop i $maxstop\nnethistop i $maxnetstop\n";
  $qstr .= "utcofs i $utcofs12\n";

  $qstr .= "delay i $delay\n" if $delay;
  $qstr .= "testiter i $testiter\n" if $testiter;

  vrb("\n$qstr\n");

  my $cmd = ($foreground ? 'P' : 'p');
  query($cmd,'glob',$qstr);
}

sub geocode2($$$)
{
  my ($lat,$lon,$scale) = @_;

  my $qstr = "lat i $lat\nlon i $lon\nscale i $scale\n";

  my $cmd = 'g';
  info("$qstr");
  query($cmd,'glob',$qstr);
}

sub iplan($$)
{
  my ($dep,$arr) = @_;

  info("iplan $dep $arr");

  my ($rdep,$rarr,$hh,$mm,$dot,$startdate,$starttime);
  my $depname = "unknown";
  my $arrname = "unknown";

  if ($haveportrefs) {
    if (exists($portids{$dep})) { $depname = $portids{$dep}; }
    if (exists($portids{$arr})) { $arrname = $portids{$arr}; }
  }

  if ($dep ne '*' and $dep == $arr) {
    info("departure and arrival identical");
    addtorep("departure stop ID $dep identical to arrival",0);
    return 1;
  }

  unless (defined $tz) {
    $utcofs12 = $utcofs12_def;
    $hh = ($utcofs12 / 100) - 12;
    $mm = $utcofs12 % 100;
    $utcofsmin = $hh * 60 + $mm;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    $tz = ofs2tz($utcofs);
    info("using default display tz $tz utc$utcofs from portrefs");
  }

  $dot = index($startdatetime,'.');
  $starttime = 0;
  if ($dot == 0) {
    $starttime = substr($startdatetime,1);
    $startdate = 0;
  } elsif ($dot > 0) {
    $starttime = substr($startdatetime,$dot+1);
    $startdate = substr($startdatetime,0,$dot);
    $starttime = 0 unless defined $starttime and length $starttime;
  } else {
    $startdate = $startdatetime;
  }

  my $rndcnt = 0;

  if ($dep eq '*') {
    readportrefs($portrefname) unless $haveportrefs;

    foreach $rdep (keys %portids) {
      $rdep = $idbysub{$rdep};
      if (exists($portids{$rdep})) { $depname = $portids{$rdep}; }
      else { $depname = "unknown"; }

      if ($arr eq '*') {
        foreach $rarr (keys %portids) {
          $rarr = $idbysub{$rarr};
          next if $rdep == $rarr;
          if (exists($portids{$rarr})) { $arrname = $portids{$rarr}; }
          else { $arrname = "unknown"; }
          info("from $depname to $arrname  v    $rdep-$rarr");
          doplan($rdep,$rarr,$startdate,$starttime,$utcofs12);
          last unless $rndcnt++ < $testiters;
        }
      } else {
        next if $rdep == $arr;
        doplan($rdep,$arr,$startdate,$starttime,$utcofs12);
        last unless $rndcnt++ < $testiters;
      }
      last unless $rndcnt++ < $testiters;
    }
    info("$stats_trip found, $stats_notrip no route $stats_error no time");
    return;
  }
  info("from $depname ($dep) to $arrname ($arr) start $startdate.$starttime +$plusday -$minday in $maxstop stops utc $utcofs");
  doplan($dep,$arr,$startdate,$starttime,$utcofs12);
}

sub plan($$)
{
  my ($depname,$arrname) = @_;

  my ($dep,$arr);
  my ($dlat,$dlon,$alat,$alon);

  $do_lcname = 1;

  unless (defined $depname and length($depname)) {
    return 0 if $iscgi;
    print('depart from: ');
    $depname=<STDIN>;
  }
  return unless defined $depname and length($depname);
  unless (defined $arrname and length($arrname)) {
    return 0 if $iscgi;
    print('arrive at: ');
    $arrname=<STDIN>;
  }
  return unless defined $arrname and length($arrname);

  ($dlat,$dlon) = ($depname =~ $isgeo);
  if (defined $dlat and defined $dlon) {
    readportrefs_geo($portrefname);
    readportrefs($portrefname) unless $haveportrefs;
    $dep = portbygeo($dlat,$dlon);
  } else {
    $dep = portbyname($depname);
  }
  return 1 unless length($dep) and exists $portids{$dep};
  info("$depname resolved into $portids{$dep}");

  ($alat,$alon) = ($arrname =~ $isgeo);
  if (defined $alat and defined $alon) {
    readportrefs_geo($portrefname);
    readportrefs($portrefname) unless $haveportrefs;
    $arr = portbygeo($alat,$alon) 
  } else {
    $arr = portbyname($arrname);
  }
  return 1 unless length($arr) and exists $portids{$arr};
  info("$arrname resolved into $portids{$arr}");

  my $pdep = $idbysub{$dep};
  my $parr = $idbysub{$arr};

  iplan($pdep,$parr);
}

sub getvar($)
{
  my ($var) = @_;

  unless (defined $var and length($var)) {
    print('variable (? for list): ');
    $var=<STDIN>;
  }
  return unless defined $var and length($var);
  if (substr($var,0,1) eq '?') {
    info('startdate - search for departure from this day onward');
    info('daterange - number of days to search');
    info('transferlimit - maximum number of transfers allowed');
    info('timezone - specify timezone to show results in');
    info('utcoffset- idem, in hh:mm offset from UTC');
    return;
  }
  info("startdate: $startdatetime") if index($var,'startdate') >= 0;
  info("plusday: $plusday") if index($var,'plusday') >= 0;
  info("minday: $minday") if index($var,'minday') >= 0;
  info("transferlimit: $maxstop") if index($var,'transerlimit') >= 0;
  info("timezone: $tz") if index($var,'timezone') >= 0;
  info("utcoffset: $utcofs") if index($var,'utcoffset') >= 0;
}

sub setvar($$)
{
  my ($var,$val) = @_;

  my ($hh,$mm,$col);

  unless (defined $var and length($var)) {
    return 0 if $iscgi;
    print('variable: ');
    $var=<STDIN>;
  }
  return 0 unless defined $var and length($var);
  unless (defined $var and length($var)) {
    return 0 if $iscgi;
    print('value: ');
    $var=<STDIN>;
  }
  return 0 unless defined $var and length($var);

  $val = '' unless defined $val and length $val;

  vrb("set $var to '$val'");
  if ($var eq 'date' or $var eq 'startdate') {
    $startdatetime = $val;
  } elsif ($var eq 'plusday') {
    $val = 99 if $val eq 'auto';
    $plusday = $val;
  } elsif ($var eq 'minday') {
    $minday = $val;
  } elsif ($var eq 'maxstops') {
    $maxstop = $val;
  } elsif ($var eq 'maxnetstop') {
    $maxnetstop = $val;
  } elsif ($var eq 'maxtxtime') {
    $maxtt = $val;
  } elsif ($var eq 'mintxtime') {
    $mintt = $val;
  } elsif ($var eq 'transfercost') {
    $transfercost = $val;
  } elsif ($var eq 'walklimit') {
    $walklimit = $val;
  } elsif ($var eq 'sumwalklimit') {
    $sumwalklimit = $val;
  } elsif (index($var,'timezone') >= 0) {
    ($hh,$mm) = tz2ofs($val);
    return 0 unless defined $hh;
    $tz = $val;
    $utcofs12 = ($hh + 12) * 100 + $mm;
    $utcofsmin = $hh * 60 + $mm;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    info("new utcofs $hh:$mm");
  } elsif (index($var,'utcoffset') >= 0) {
    $col = index($val,':');
    return 0 unless $col > 0;
    $utcofs = $val;
    $hh = substr($val,0,$col);
    $mm = substr($val,$col+1);
    $utcofsmin = $hh * 60 + $mm;
    $utcofs12 = int(($hh + 12) * 100 + $mm);
    info("new utcofs $hh:$mm");
    $tz = ofs2tz($val);
    info("new tz $tz");
  } elsif (index($var,'utcofs12') >= 0) {
    $utcofs12 = $val;
    $hh = int( ($val / 100) - 12);
    $mm = int($val % 100);
    $utcofsmin = $hh * 60 + $mm;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    $tz = ofs2tz($utcofs);
  } elsif (index($var,'delay') >= 0) {
    $delay = int $val;
  } elsif (index($var,'testiter') >= 0) {
    $testiter = int $val;
  } else {
    return error("unknown variable $var: check online help");
  }
  return 1;
}

sub set_var($)
{
  my ($arg) = @_;
  my ($eq,$var,$val);

  vrb("arg '$arg'");
  $eq = index($arg,'=');
  if ($eq > 0) {
    $var = substr($arg,0,$eq);
    $val = substr($arg,$eq + 1);
    setvar($var,$val);
    return '';
  } else { return $arg . ' '; }
}

sub stop($)
{
  my ($cmd) = @_;

  query('s','glob','');
}

my $clientid = "$$";

sub ret_close_err($$)
{
  my ($fh,$msg) = @_;

  error("$msg");
  close($fh);
  return 0;
}

# submit the query and wait for corresponding reply
sub query($$$)
{
  my ($cmd,$region,$str) = @_;
  my ($qfile,$qname,$qname_new,$qname_sub,$qname_rep,$qname_rcv,$serverid);

# prepare the query. use atomic file renames, server does the same
# query filename: 
#  [a-z]_     command
#  [a-z]_     (format todo) region
#  [0-9a-f]_  hex timestamp in msec
#  [0-9a-f]   hex client id
#  .sub

# file content:
# list of (var type value) each on 1 line
# var:  [a-z] dep arr
# type [is] i = int s = string

  my ($sec, $usec) = gettimeofday();
  my $now = time();

  my $stamp = int ($sec * 1000 + ($usec / 1000));

  my $stampstr = sprintf("%011x",$stamp);
  $qname = sprintf("%s/%s_%s_%s_%04x",$querydir,$cmd,$region,$stampstr,$clientid);

  $qname_new = $qname . '.new';
  $qname_sub = $qname . '.sub';
  vrb("create $qname_new");

  if ($dryrun) {
    info("dryrun $cmd $str");
    addtorep("dryrun test",0);
    return 1;
  }

  open($qfile,'>',$qname_new) or error_exit("cannot create $qname_new: $!");
  print($qfile $str . "\n");
  close($qfile);

  info("submit '$cmd' '$str'") if $iscgi;

# rename to submit: server will pick up from here. reply has serverid appended
  vrb("rename to $qname_sub");
#  my $tst;
#  open($tst,'>',"/tmp/test.q");
#  print($tst "$str");
#  close($tst);
  rename($qname_new,$qname_sub);

  # cmd,region,stamp,clientid,serverid
  my $pat = qr'^[a-zA-Z]_[a-z]+_([0-9a-f]+)_([0-9a-f]+)_([0-9a-f]+)\.rep';

  while (time() - $now < $timeout) {
    select(undef,undef,undef,0.01);  # = sleep 10 millisec
    $serverid = filepatindir($pat,$stampstr,$clientid,$querydir);
    last if length($serverid);
  }
  unless (length($serverid)) {
    info("no reply from tripover server in $timeout sec");
    addtorep(".planres\tno reply from tripover server in $timeout sec",0);
    return;
  }

  # reply present: read and delete
  $qname_rep = $qname . '_' . $serverid . '.rep';
  $qname_rcv = $qname . '_' . $serverid . '.rcv';

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  my $reply;
  open($reply,'<:encoding(UTF-8)',$qname_rep) or return error("cannot open $qname_rep:$!");

  stat $reply or return ret_close_err($reply,"cannot access $qname_rep: $!");
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
  return ret_close_err($reply,"$qname_rep is not a regular file") unless S_ISREG($mode);
  return ret_close_err($reply,"$qname_rep is empty") unless $size > 0;
  return ret_close_err($reply,"$qname_rep is empty") unless -r $qname_rep;

  my @lines = readline($reply);
  close($reply);
  unlink $qname_rep or return error("cannot remove $qname_rep:$!");

  return error("$qname_rep is empty") unless (scalar @lines);

  my $result = $lines[0];
  if ($cmd eq 'p') {
    if (index($result,'no trip') >= 0) { $stats_notrip++; }
    elsif (index($result,'error code') >= 0) { $stats_error++; }
    else { $stats_trip++; }
  }
  addtorep(".planres\tresult\t$result",0);

  my ($item,$time,$nxtime,$dist,$fare,$stops,$ref);
  my ($tdep,$tarr,$sdist,$txtime,$xtra,$dist0,$name,$rname);
  my ($line,$rline,$thop,$c,$col);
  my $nxtstr = '';
  my $aname = '';
  my $linno = 0;
  my $triprow = 0;
  my $legno = 1;
  my @cols;
  for $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    if (substr($line,0,1) eq '#') { addtorep($line,1); next; }
    if (index($line,"\t") < 0) { $item = $line; }
    else { ($item,$time,$dist,$stops,$fare,$nxtime,$ref) = split("\t",$line); }
    if ($item eq 'sum') {
      $legno = 1;
      addtorep(".planres\t$line",1);
      $nxtstr = sprintf("next in %s",$nxtime) if $nxtime ne '-';
      printf("%s %s %u stops %s%s  ref %s",$time,$dist,$stops,$nxtstr,$fare == 0 ? '-' : $fare,$ref);
    } elsif ($item eq 'trip') {

# tdep,name,txtime;
      if ($triprow == 0) {
        print "\n";
        ($item,$tdep,$name,$sdist,$txtime,$xtra) = split("\t",$line);
        $sdist = '' unless defined $sdist;
        $txtime = '' unless defined $txtime;
        $rline = join("\t",'.planres',$item,$tdep,$name,$sdist,$txtime);
        addtorep($rline,1);
        if ($legno > 1) {
          if ($name ne $aname) {
            print "                $name within $sdist\n";
          }
          print "$legno. ";
          print join(' ',$tdep,'continue with',$txtime,'transfer time');
        } else {
          print "$legno. ";
          print join(' ',$tdep,$name);
        }
        $triprow++;

# mode,route,dist
      } elsif ($triprow == 1) {
        ($item,$mode,$rname,$thop,$dist,$xtra) = split("\t",$line);
        $rline = join("\t",'.planres',$item,$mode,$rname,$thop,$dist);
        $xtra = '' unless defined $xtra;
        addtorep($rline,1);
        print join(' ','                 ',$mode,$rname,$thop,$dist,$xtra);
        $triprow++;

# tarr,name
      } elsif ($triprow == 2) {
        ($item,$tarr,$aname) = split("\t",$line);
        $rline = join("\t",'.planres',$item,$tarr,$aname);
        addtorep($rline,1);
        print join(' ','  ',$tarr,$aname);
        $triprow = 0;
        $legno++;
      }
    } elsif ($item eq 'stat') {
      addtorep(".planres\t$line",1);
      @cols = split("\t",$line);
      splice(@cols,0,1);
      print join("\t",@cols);
    } else { print $line; }
    print "\n";
  }

  print($logfd @lines) if defined $logfd;
  unlink $qname_rcv or return error("cannot remove $qname_rcv:$!");
}

# issue an update ( = realtime) command : similar to query, yet no response
sub updcmd($)
{
  my ($str) = @_;
  my ($stamp,$qfile,$qname,$qname_new,$qname_sub,$qname_rep,$qname_rcv,$serverid);
  my $cmd = 'u';

# prepare the query. use atomic file renames, server does the same
# query filename: 
#  [a-z]_     command
#  [a-z]_     (format todo) region
#  [0-9a-f]_  hex timestamp in sec
#  [0-9a-f]   hex client id
#  .sub

# file content is lines with list of hex integers only:
# first number is command : 0=fares 1=trips 2=routes 3=stops
# fares : rrid,t0,(dt mask fare[n])+

  $stamp = time();
  $qname = sprintf("%s/%s_glob_%010x_%04x",$querydir,$cmd,$stamp,$clientid);
  $qname_new = $qname . '.new';
  $qname_sub = $qname . '.sub';
  vrb("create $qname_new");

  if ($dryrun) {
    info("$qname");
    info("  $str");
    return 1;
  }

  open($qfile,'>',$qname_new) or error_exit("cannot create $qname_new: $!");
  print($qfile $str);
  close($qfile);

  vrb("submit '$cmd' '$str'");

# rename to submit: server will pick up from here.
  vrb("rename to $qname_sub");
  rename($qname_new,$qname_sub);
}

sub cntbits($)
{
  my $x = shift;
  my $n = 0;

  $x = hex($x) & 0xf;
  while ($x) { $n++ if ($x & 1); $x >>= 1; }
  return $n
}

my $nix2to = 946684800; # seconds Epoch 2000 since 1970

# from yyyymmdd to minutes since Epoch
sub cd2day($)
{
  my $cd = shift;

  my $dd = int($cd % 100); $cd /= 100;
  my $mm = int($cd % 100);
  my $yy = int($cd / 100);
  my $nixsec = int POSIX::mktime(0,0,0,$dd,$mm-1,$yy-1900,0,0,0);
  my $tomin = ($nixsec - $nix2to) / 60;
  return int($tomin + $sysutcofs);
}

# hhmm to minutes
sub cd2time($)
{
  my $cd = shift;

  my $hh = int($cd / 100);
  my $mm = int($cd % 100);
  return int($hh * 60 + $mm);
}

sub update($$$$$$)
{
  my ($rid,$dep,$arr,$cd_day0,$cd_time0,$xargs) = @_;
  my ($cd_day,$cd_time,$t,$dt,$mask,$farecnt);

  $xargs = trimws($xargs);

  info("rid $rid t0 $cd_day0 xargs '$xargs'");
  my $d = cd2day($cd_day0);
  my $tt = cd2time($cd_time0);
  my $t0 = int($d + $tt - $utcofsmin);

  my @args = split(' ',$xargs);
  my $argcnt = scalar(@args);
  my $argno = 0;
  my $str = sprintf("0 %x %x %x %x ",$rid,$dep,$arr,$t0);
  while ($argno + 3 < $argcnt) {
    $cd_day = $args[$argno];
    $cd_time = $args[$argno+1];
    $d = cd2day($cd_day);
    $tt = cd2time($cd_time);
    $t = int($d + $tt - $utcofsmin);
    return info("t $t t0 $t0") if ($t < $t0);
    $dt = $t - $t0;
    $mask = $args[$argno+2];
    $argno += 3;
    $farecnt = cntbits($mask);
    return info("farecnt $farecnt argno $argno") if ($argno + $farecnt >= $argcnt);
    $str .= sprintf("%x %x ",$dt,hex $mask);
    while ($farecnt--) { $str .= sprintf("%x ",$args[$argno++]); }
  }
  $str .= "\n";
  updcmd($str);
}

# obtain query dir from current config
sub readcfg()
{
  my ($cfg,$var,$val);

  open($cfg,'<',$currentconfig)  or error_exit("cannot open $currentconfig: $!\n\nCheck if the tripover server is running in this dir");

  my @cfglines = readline($cfg);
  unless (scalar @cfglines) { error_exit("$currentconfig is empty\n\nCheck if the tripover server is running in this dir"); }

  my $varisval = qr'^([-a-zA-Z0-9_.]+)\s*=?\s*([-a-zA-Z0-9_.]+)';

  foreach my $line (@cfglines) {
    ($var,$val) = ($line =~ $varisval);
    next unless defined $var;
    next if $var ne $querydirvar;
    $querydir = $val;
    last;
  }
  error_exit("empty query config") unless length($querydir);
  vrb("query dir $querydir/");
}

sub usage()
{
  info("usage: plantrip [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("plan <from> <to>   plan a trip");
  info("stop               stop server");
  info("set <var> <value>  set variable");
  info("get [var]          get variable (? for list)\n");
  info("without command, interactive mode is entered\n");

  info("variables: specify as var=value on plan commands");
  info("startdate          start date / time for depart : yyyymmdd[.hhmm]");
  info("days               number of days to consider (search horizon) [3]");
  info("maxstops           max number of transfers to consider [4]");
  info("maxnetstop         max number of transfers to base on precomputed info [3]");
  info("maxtxtime          max transfer (waiting time) in minutes [120]");
  info("mintxtime          min tranfer time in minutes [5]");
  info("transfercost       extra cost per tranfser in minutes [10]");
  info("walklimit          max walk distance in meters for a single go [1000]");
  info("sumwalklimit       max summed up walk distance in meters [3000]");
  info("timezone           timezone to use : country/city");
  info("utcoffset          UTC offset to use [+-]hh:mm\n");
  info("example:  plan beerwah elimbah date=20150218.0800 transfercost=0 walklimit=300");
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover commandline client version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

my (%tzofs,%tzdstofs);

sub readtzinfo()
{
  my $tzname = 'tzinfo.txt';
  my $tzfile;
  my $col = 0;
  my ($line,$tzstr,$tz,$ofs,$dstofs,$a,$b,$c,$alt);
  my @tzs;
  my $tzcol = 3;
  my $ofscol = 5;
  my $dstofscol = 6;

  # read timezone info from wikipedia export, in turn from iana TZ database 
  open($tzfile,'<:encoding(UTF-8)',$tzname) or return warning("cannot open $tzname:$!");
  my @lines = readline($tzfile);
  close($tzfile);
  for $line (@lines) {
    next unless length($line);
    next if index($line,'#') == 0;

    @tzs = ();
    if (index($line,'|-') == 0) {
      $col = 0;
    } elsif (index($line,'|') == 0) {
      $line = substr($line,1);
      $col++;
    }

    if ($col == $tzcol) {
      $a = index($line,'[[');
      $b = index($line,']]');
      $tzstr = substr($line,$a+2,$b-3);
    } elsif ($col == $ofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      $ofs = substr($line,$a+5,$c-6);
      if (substr($ofs,0,1) eq "\x{2212}") { $ofs = '-' . substr($ofs,1); }
    } elsif ($col == $dstofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      if ($a < 0) { vrb("no dstofs for $tz abc $line"); $dstofs = $ofs; }
      else { $dstofs = substr($line,$a+5,$c-6); }
    } elsif ($col > $dstofscol) {
      while (length($tzstr)) {
        $alt = index($tzstr,'|');
        if ($alt < 0) {
          push @tzs,$tzstr;
          $tzstr = '';
        } else {
          $tz = substr($tzstr,0,$alt);
          vrb("tz '$tz' ofs '$ofs'");
          push @tzs,$tz;
          $tzstr = substr($tzstr,$alt + 1);
          vrb("tzstr '$tzstr'");
        }
      }
      foreach $tz (@tzs) {
        $tzofs{$tz} = $ofs;
        $tzdstofs{$tz} = $dstofs;
        vrb("tz '$tz' ofs '$ofs'");
      }
      $col = 0;
    }
  }
  return 1;
}

sub tz2ofs($)
{
  my ($str) = @_;
  my ($hh,$mm,$hhmm);

  unless (exists($tzofs{$str})) { warning("no timezone info for $str"); return (0,0); }

  $hhmm = $tzofs{$str};
  $a = index($hhmm,':');
  $hh = substr($hhmm,0,$a);
  $mm = substr($hhmm,$a+1);
  vrb("utc offset hh $hh mm $mm");
  return ($hh,$mm);
}

sub ofs2tz($)
{
  my ($hhmm) = @_;
  my ($hm,$str) = @_;

  while (($str,$hm) = each %tzofs) {
    return $str if $hm eq $hhmm;
  }
  return $hhmm;
}

sub init()
{
  readcfg();
  unless (-d $querydir) {
    info("creating configured query dir $querydir");
    mkdir($querydir) || error_exit("cannot create query dir:$!");
  }
  readtzinfo();
  my $sec70 = time;
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $sec70;
  my $ltsec = strftime('%s',$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,0);
  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime $sec70;
  my $utcsec = strftime('%s',$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,0);
  $sysutcofs = int(($ltsec - $utcsec) / 60);
  info("localtime $ltsec utc $utcsec ofs $sysutcofs");
}

my ($Aver,$Ver,$Id,$Cmd,$Deplat,$Deplon,$Arrlat,$Arrlon,$Dep,$Arr,$Date,$Time,$PMday,$Utcofs,$Delay,$Walklim,$Srcmode);

sub initcgi()
{
  return 0 unless exists $ENV{'GATEWAY_INTERFACE'};
  return 0 if index($ENV{'GATEWAY_INTERFACE'},'CGI/') < 0;
  return 1;
}

sub runcgi()
{
  my $clntip = $ENV{'REMOTE_ADDR'};

  my ($sec, $usec) = gettimeofday;
  my $msec = int ($usec / 1000);

  print "Access-Control-Allow-Origin: *\r\n";

  print "Content-type: text/plain\r\n\r\n";

#  print "test\n\n$0\n";

  my ($dev,$ino,$mode) = lstat($0);
  my $progpath = $0;
  if (S_ISLNK($mode)) {
    $progpath = readlink($0);
#    print " xx progpath $progpath\n";
  }
#  print "progpath $progpath\n";

  my $progdir = rindex $progpath,'/';
  my $cwd;
  if ($progdir > 0) {
    $cwd = substr($progpath,0,$progdir);
    chdir $cwd;
  }

  my $url = $ENV{'PATH_INFO'};
  $url = substr($url,1) if index($url,'/') == 0;

  my @rargs =  split('/',$url);
  my @args;
  for my $arg (@rargs) {
#    print "$arg\n";
    $arg = 0 if $arg =~ qr'[^0-9]';
    push(@args,$arg) 
  }
  while (@args < 20) { push @args,0; }
  ($Aver,$Ver,$Id,$Cmd,$Deplat,$Deplon,$Arrlat,$Arrlon,$Dep,$Arr,$Date,$Time,$PMday,$Utcofs,$Walklim,$Srcmode,$Delay) = @args;

  print("aver $Aver\n") if defined $Aver;
  print("ver $Ver\n") if defined $Ver;

  print("dep $Dep\n") if defined $Dep;
  print("arr $Arr\n") if defined $Arr;

  print("date $Date\n") if defined $Date;
  print("time $Time\n") if defined $Time;

  my $pday = int($PMday / 100);
  my $mday = int($PMday % 100);

  $repfile = "$repdir/plantrip-$clntip-$$-$Cmd-$Deplat-$Deplon-$Dep-$Arr-$sec.$msec";
  $reqid = $Id;

#  print("reqfile $repfile");

  init();

  if ($Delay) { sleep($Delay); }  # engineering provision

  my ($rlat,$rlon);
  my $geoscale = 1000000; # match with .js

  if ($Cmd == 0) { # plan
    set_var("date=$Date.$Time");
    set_var("plusday=$pday");
    set_var("minday=$mday");
    set_var("utcofs12=$Utcofs");
    set_var("walklimit=$Walklim");

    if ($Srcmode == 0) { set_var("transfercost=2"); }  # fewest transfers
    elsif ($Srcmode == 1) { set_var("transfercost=1"); }  # balanced
    else { set_var("transfercost=0"); }  # fastest

    iplan($Dep,$Arr);
    agedir($querydir,time() - $agelimit);
  } elsif ($Cmd == 1) { # local geocode
    $rlat = ($Deplat / $geoscale) - 90;
    $rlon = ($Deplon / $geoscale) - 180;
    info("lat $rlat lon $rlon");
    geocode($rlat,$rlon);
  } elsif ($Cmd == 2) { # tripover geocode
    geocode2($Deplat,$Deplon,$geoscale);
  }

  return 1;
}

if (initcgi()) {
  $iscgi = 1;
  runcgi();
  exit 0;
}

my ($arg,$xargs,$opt,$optarg,$eqpos,$inopt,$cmd,$line,$prvline);
my ($dep,$arr,$rid,$d0,$t0);
my @args;

my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
$startdatetime = sprintf("%04u%02u%02u.%02u%02u",$year+1900,$mon+1,$mday,$hour,$min);
vrb("$startdatetime");

if (@ARGV > 0) {
  foreach $arg (@ARGV) {
    if (substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
      if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
    }
  }

  $inopt = 1;
  foreach $arg (@ARGV) {
    if ($inopt and substr($arg,0,1) eq '-') {

      $opt = $arg;
      $opt =~ s/^-+//;
      $eqpos = index($opt,'=');
      if ($eqpos > 0) {
        $optarg = substr($opt,$eqpos+1);
        $opt = substr($opt,0,$eqpos);
      }
      if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
      elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
      elsif ($opt eq 'h' or $opt eq 'help') { usage(); exit 1; }
      elsif ($opt eq 'x') {} # dummy
      elsif ($opt eq 'f') { $foreground = 1; }
      elsif ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      elsif ($opt eq 'o' and length($optarg)) {
        $repfile = $repdir . '/' . $optarg;
        ($reqid) = ($repfile =~ qr'[-a-z_]+([0-9]+)\.[-a-z]');
        $reqid = 0 unless defined $reqid;
        info("repfile $repfile id $reqid");
      }
      else { info("ignoring unknown option -$opt"); }
    } else {
      $inopt = 0;
      push(@args,$arg);
    }
  }

  if (@args > 0) {
    init();
    $cmd = $args[0];
    $xargs = '';
    info("cmd $cmd");
    if ($cmd eq 'stop') {
      stop($cmd);
    } elsif ($cmd eq 'plan') {
      exit info("plan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      splice(@args,0,3);
      foreach $arg (@args) { set_var($arg); }
      plan($dep,$arr);
      agedir($querydir,time() - $agelimit);
    } elsif ($cmd eq 'iplan') {
      exit info("iplan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      if ($arr eq 'to') { $arr = $args[3]; splice(@args,0,4); }
      else {splice(@args,0,3); }
      foreach $arg (@args) { set_var($arg); }
      iplan($dep,$arr);
      agedir($querydir,time() - $agelimit);
    } elsif ($cmd eq 'geocode') {
      exit info("geocode needs lat and lon arg") unless (@args > 2);
      geocode($args[1],$args[2]);
    } elsif ($cmd eq 'update') {  # dev provision
      exit info("update needs: 'rid,dep,arr,date,time'") unless (@args > 5);
      $rid = $args[1]; $dep = $args[2]; $arr = $args[3]; $d0 = $args[4]; $t0 = $args[5];
      splice(@args,0,6);
      foreach $arg (@args) { $xargs .= set_var($arg); }
      update($rid,$dep,$arr,$d0,$t0,$xargs);
    } elsif ($cmd eq 'geo2') {
      geocode2($args[1],$args[2],$args[3]);
    } else { info("unknown command"); }
#    agedir($repdir,time() - $repagelimit);
    exit 0;
  }
}

init();

if ($iscgi) { usage(); exit 0; }

if (-t STDIN) {
  info("entering command loop. commands:\n");
  info("  plan <from> <to> name or coords");
  info("  quit, exit");
}

# loop 
$cmd = ''; $prvline = '';
while ($cmd ne 'quit') {
  print("plantrip % ") if -t STDIN;
  $line = <STDIN>;
  next unless defined $line and length($line);
  next if index($line,'#') == 0;

  $line = trimws($line);
  $line = $prvline if $line eq '!!';
  @args = split(' ',$line);
  $cmd = '';
  $cmd = 'quit' if index($line,'quit') == 0;
  $cmd = 'quit' if index($line,'exit') == 0;
  $cmd = 'plan' if index($line,'plan') == 0;
  $cmd = 'iplan' if index($line,'iplan') == 0;
  $cmd = 'update' if index($line,'update') == 0;
  $cmd = 'stop' if index($line,'stop') == 0;
  $cmd = 'set' if index($line,'set') == 0;
  $cmd = 'get' if index($line,'get') == 0;
  info("unrecognised command '$line'") if length($line) and not length($cmd);
  $prvline = $line;
  if ($cmd eq 'plan') {
    exit info("plan needs 'from' and 'to' arg") unless (@args > 2);
    $dep = $args[1]; $arr = $args[2];
    splice(@args,0,3);
    foreach $arg (@args) { set_var($arg); }
    plan($dep,$arr);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'iplan') {
    exit info("iplan needs 'from' and 'to' arg") unless (@args > 2);
    $dep = $args[1]; $arr = $args[2];
    splice(@args,0,3);
    foreach $arg (@args) { set_var($arg); }
    iplan($dep,$arr);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'update') {  # dev provision
    unless (@args > 5) {
      info("update needs: 'rid,dep,arr,date,time'");
      exit;
    }
    $rid = $args[1]; $dep = $args[2]; $arr = $args[3]; $d0 = $args[4]; $t0 = $args[5];
    splice(@args,0,6);
    foreach $arg (@args) { $xargs .= set_var($arg); }
    update($rid,$dep,$arr,$d0,$t0,$xargs);
  } elsif ($cmd eq 'stop') {
    stop($line);
  } elsif ($cmd eq 'set') {
    setvar($args[1],$args[2]);
  } elsif ($cmd eq 'get') {
    getvar($args[1]);
  }
}
