#!/usr/bin/perl -W

# plantrip - local commandline client for tripover

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014-2015 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# rudimentary interface and implementation : to be elaborated

# post trip requests to a local queue, and watch that queue for answers
# the queue location is configured in the server, yet created here if nonexistent

use 5.012;
use strict;

use Fcntl ':mode';

my $version_maj = 0;
my $version_min = 16;
my $lastchanged = "2 feb 2015";

my $copyright = "Copyright (C) 2014-2015, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $currentconfig = 'tripover.cfg.cur';
my $querydirvar = 'querydir';
my $querydir;

my $portrefname = 'portrefs.txt';

my $timeout = 6; # seconds

my $agelimit = 60; # seconds

# defaults, modifyable with 'set' cmd or args
my $maxstop = 4;
my $dayrange = 3;
my $startdate = 0; # implies start of service
my $tzdef = 'Australia/Brisbane';
my $tz;
my $utcofs = '+10:00';

my $utcofs12 = 2200;  # biased coded decimal
my $utcofs12_def = 2200;

# stop at compile-time warnings
local $SIG{__WARN__} = sub { print "$_[0]\n"; exit 1; };

my $logname = 'plantrip.log';
my $logfd;

# rotate log
if (-t STDOUT) {
  for (my $bck = 8; $bck >= 0; $bck--) {
    rename($logname . '.' . $bck,$logname . '.' . ($bck+1)) if (-f $logname . '.' . $bck);
  }
  rename($logname,$logname . '.0') if -f $logname;
  open($logfd,'>:encoding(UTF-8)',$logname) or print("cannot create $logname:$!");
}

# unbuffered i/o
my $orgfh = select STDOUT; $| = 1; select STDERR; $| = 1; select $orgfh;

binmode(STDOUT,':utf8');

my %portnames;
my %portpnames;
my %portids;
my %idbysub;
my (%portlats,%portlons);
my $portcnt = 0;

my ($latscale,$lonscale);

sub msg($) {
  my ($m) = @_;

  print("$m\n");
  print($logfd "$m\n") if defined $logfd;
  return 1;
}

sub vrb($)     { msg("$_[0]") if $verbose; return 1; }
sub info($)    { return msg("$_[0]"); }
sub warning($) { return msg("warning: $_[0]"); }
sub error($)   { msg("error: $_[0]"); return 0; }

sub error_exit($) { print ("error: $_[0]\n"); exit 1; }

sub filepatindir($$$$)
{
  my ($pat,$stamp,$clientid,$dir) = @_;

  my ($dh,$serverid,$tstamp,$tid,$hstamp,$hid,$name);
  my @names;

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    ($hstamp,$hid,$serverid) = ($name =~ $pat);
    next unless (defined $hstamp and defined $hid and defined $serverid);
    $tstamp = hex($hstamp);
    $tid = hex($hid);
    if ($tstamp == $stamp and $tid == $clientid)  {
      info("reply handled by server $serverid");
      return $serverid;
    } else { vrb("reply from $tstamp $tid, expect $stamp $clientid $serverid"); }
  }
  return '';
}

# catchall for any leftover file in query queue.
sub agedir($$)
{
  my ($dir,$limit) = @_;

  my ($dh,$serverid,$tstamp,$tid,$name,$path);
  my @names;

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    next if $name eq '.' or $name eq '..';

    $path = $dir . '/' . $name;

    stat($path) or return error("cannot access $path: $!");
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
    return error("$path is not a regular file") unless S_ISREG($mode);

    if ($mtime < $limit)  {
      vrb("removing $path on timestamp $mtime below $limit");
      return 1 if $dryrun;
      unlink $path or return error("cannot remove $path: $!");
    }
  }
  return 1;
}

my $pi = 3.141592655;
my $geolow = $pi * 1.0e-4;
my $geolimit = $pi * 1.0e-8;
my $mean_earth_radius = 6371.0;

sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

sub geodist($$$$)
{
  my ($slat,$slon,$lat,$lon) = @_;

  my ($dist,$dlat,$dlon);

  my $phi1 = ($slat * $pi) / 180;
  my $lam1 = ($slon * $pi) / 180;
  my $phi2 = ($lat * $pi) / 180;
  my $lam2 = ($lon * $pi) / 180;

  my $dlam = $lam2 - $lam1;
  my $dphi = $phi2 - $phi1;

  if (abs($dlam) < $geolow and abs($dphi) < $geolow) { # trivial case: assume flat
    if (abs($dlam) < $geolimit and abs($dphi) < $geolimit) { # flush to zero
      return 0;
    }
    $dlat = ($dlam * $mean_earth_radius * 2) / $pi;
    $dlon = ($dphi * $mean_earth_radius * 2) / $pi;
    $dist = sqrt( ($dlat * $dlat) + ($dlon * $dlon));
    return $dist;
  }

  my ($d,$dsig);

  $d = sin($phi1) * sin($phi2) + cos($phi1) * cos($phi2) * cos($dlam);
  if ($d >= 1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }
  elsif ($d <= -1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }

  $dsig = acos($d);

  return $dsig * $mean_earth_radius;
}

my $haveportrefs = 0;

# read port to id mappings
sub readportrefs($)
{
  my ($fname) = @_;

  my ($id,$subid,$name,$lcname,$nlen,$lat,$lon);
  my ($fh,$line,$c,$var,$val);

  open($fh,'<:encoding(UTF-8)',$fname) or error_exit("cannot open $fname: $!");

  my @lines = readline($fh);
  unless (scalar @lines) { error_exit("$fname is empty"); }

  foreach $line (@lines) {
    next unless length($line);
    $c = substr($line,0,1);
    next if $c eq '#';
    if ($c eq '.') {
      ($var,$val) = split("\t",substr($line,1));
      $tzdef = $val if $var eq 'tz';
      $latscale = $val if $var eq 'latscale';
      $lonscale = $val if $var eq 'lonscale';
      next;
    }
    ($id,$subid,$name,$lat,$lon) = split("\t",$line);
    next unless defined $id and defined $name;
    $lcname = lc($name);
    $portnames{$name} = $subid;
    $portnames{$lcname} = $subid;
    $portids{$subid} = $name unless defined $portids{$subid};
    $idbysub{$subid} = $id;
    $portlats{$subid} = $lat;
    $portlons{$subid} = $lon;
  }
  $portcnt = scalar(keys %portids);
  info("$portcnt ports");

  # prepare partial ( prefix) matching
  while (($name,$subid) = each %portnames) {
    $nlen = length($name);
    next if $nlen < 4;
    while ($nlen-- > 3) {
      chop $name;
      if (defined($portpnames{$name})) { $portpnames{$name} .= "\t" . $subid; }
      else { $portpnames{$name} = $subid; }
    }
  }
  $haveportrefs = 1;
}

# returns sub-id by name
sub portbyname($)
{
  my ($name) = @_;

  my ($port,$id,$subid,$seq,$lcname,$plen,$line);
  my @plist;

  readportrefs($portrefname) unless $haveportrefs;

  $lcname = lc($name);
  if (exists($portnames{$name})) { return $portnames{$name}; }
  if (exists($portnames{$lcname})) { return $portnames{$lcname}; }
  $name = $lcname unless exists($portpnames{$name});
  unless (exists($portpnames{$name})) {
    info("no matches for prefix '$name'");
    return '';
  }
  @plist = split("\t",$portpnames{$name});
  $plen = scalar(@plist);
  return $plist[0] if $plen == 1;
  info("$plen matches for $name");
  if ($plen < 40) {
    $seq = 1;
    foreach $subid (@plist) {
      printf("%2u %s\n",$seq++,$portids{$subid});
    }
    do {
      print('Choose port by number or q to quit: ');
      $line = <STDIN>;
      next unless defined $line and length($line);
      $line = trimws($line);
      next unless length($line);
      return '' if $line eq 'q' or $line eq 'x';
      if ($line =~ qr'^[0-9]+$') {
        $seq = $line;
        if ($seq <= $plen and $seq != 0) {
          return $plist[$seq - 1];
        } else {
          print("port number not in above list\n");
        }
      } else {
        print("expected port number or command\n");
      }
    } while 1;

  } else {  # list too long
    return ''; # todo
  }
  return '';
}

sub portbygeo($$)
{
  my ($lat,$lon) = @_;
  my ($clat,$clon,$dist,$lodist,$loid,$id,$name);

  readportrefs($portrefname) unless $haveportrefs;

  $lodist = 999999999; $loid = 0;
  while (($id,$name) = each %portids) {
    $clat = $portlats{$id};
    $clon = $portlons{$id};
    $clat = ($clat / $latscale) - 90;
    $clon = ($clon / $lonscale) - 180;

    $dist = geodist($lat,$lon,$clat,$clon);
    if ($dist < $lodist) { vrb("dist $dist id $id $name"); $lodist = $dist; $loid = $id; }
  }
  warning("$lat,$lon not found") unless exists $portids{$loid};

  return $loid;
}

sub iplan($$)
{
  my ($dep,$arr) = @_;

  my ($depname,$arrname,$qstr,$hh,$mm);

  if ($haveportrefs) {
    if (exists($portids{$dep})) { $depname = $portids{$dep}; }
    else { $depname = "unknown"; }
    if (exists($portids{$arr})) { $arrname = $portids{$arr}; }
    else { $arrname = "unknown"; }

    info("dep $dep '$depname'");
    info("arr $arr '$arrname'");
  } else {
    info("dep $dep");
    info("arr $arr");
  }

  if ($dep ne '*' and $dep == $arr) {
    info("departure and arrival identical");
    return 1;
  }

  my $region = 'glob';

  unless (defined $tz) {
    $utcofs12 = $utcofs12_def;
    $hh = ($utcofs12 / 100) - 12;
    $mm = $utcofs12 % 100;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    $tz = ofs2tz($utcofs);
    info("using default display tz $tz utc$utcofs from portrefs");
  }

  if ($dep eq '*') {
    readportrefs($portrefname) unless $haveportrefs;
    foreach $dep (keys %portids) {
      $dep = $idbysub{$dep};
      $qstr = "dep i $dep\narr i $arr\ntspan i $dayrange\ndeptmin i $startdate\n";
      $qstr .= "histop i $maxstop\nutcofs i $utcofs12\n";
      query('p',$region,$qstr);
    }
    return;
  }
  $qstr = "dep i $dep\narr i $arr\ntspan i $dayrange\ndeptmin i $startdate\n";
  $qstr .= "histop i $maxstop\nutcofs i $utcofs12\n";
  query('p',$region,$qstr);
}

sub plan($$)
{
  my ($depname,$arrname) = @_;

  my ($dep,$arr);
  my $isgeo = qr'^\s*([+-]?[0-9]+\.[0-9]+)\s*,\s*([+-]?[0-9]+\.[0-9]+)\s*$';
  my ($dlat,$dlon,$alat,$alon);

  unless (defined $depname and length($depname)) {
    print('depart from: ');
    $depname=<STDIN>;
  }
  return unless defined $depname and length($depname);
  unless (defined $arrname and length($arrname)) {
    print('arrive at: ');
    $arrname=<STDIN>;
  }
  return unless defined $arrname and length($arrname);

  ($dlat,$dlon) = ($depname =~ $isgeo);
  if (defined $dlat and defined $dlon) {
    $dep = portbygeo($dlat,$dlon)
  } else {
    $dep = portbyname($depname);
  }
  return 1 unless length($dep) and exists $portids{$dep};
  info("$depname resolved into $portids{$dep}");

  ($alat,$alon) = ($arrname =~ $isgeo);
  if (defined $dlat and defined $dlon) {
    $arr = portbygeo($alat,$alon) 
  } else {
    $arr = portbyname($arrname);
  }
  return 1 unless length($arr) and exists $portids{$arr};
  info("$arrname resolved into $portids{$arr}");

  my $pdep = $idbysub{$dep};
  my $parr = $idbysub{$arr};

  iplan($pdep,$parr);
}

sub getvar($)
{
  my ($var) = @_;

  unless (defined $var and length($var)) {
    print('variable (? for list): ');
    $var=<STDIN>;
  }
  return unless defined $var and length($var);
  if (substr($var,0,1) eq '?') {
    info('startdate - search for departure from this day onward');
    info('daterange - number of days to search');
    info('transferlimit - maximum number of transfers allowed');
    info('timezone - specify timezone to show results in');
    info('utcoffset- idem, in hh:mm offset from UTC');
    return;
  }
  info("startdate: $startdate") if index($var,'startdate') >= 0;
  info("daterange: $dayrange") if index($var,'daterange') >= 0;
  info("transferlimit: $maxstop") if index($var,'transerlimit') >= 0;
  info("timezone: $tz") if index($var,'timezone') >= 0;
  info("utcoffset: $utcofs") if index($var,'utcoffset') >= 0;
}

sub setvar($$)
{
  my ($var,$val) = @_;

  my ($hh,$mm,$col);

  unless (defined $var and length($var)) {
    print('variable: ');
    $var=<STDIN>;
  }
  return unless defined $var and length($var);
  unless (defined $var and length($var)) {
    print('value: ');
    $var=<STDIN>;
  }
  return unless defined $var and length($var);

  info("set $var to '$val'");
  $startdate = $val if index($var,'startdate') >= 0;
  $dayrange = $val if index($var,'daterange') >= 0;
  $maxstop = $val if index($var,'transerlimit') >= 0;
  if (index($var,'timezone') >= 0) {
    ($hh,$mm) = tz2ofs($val);
    return unless defined $hh;
    $tz = $val;
    $utcofs12 = ($hh + 12) * 100 + $mm;
    $utcofs = sprintf("%+02d:%02d",$hh,$mm);
    info("new utcofs $hh:$mm");
  }
  if (index($var,'utcoffset') >= 0) {
    $col = index($val,':');
    return unless $col > 0;
    $hh = substr($val,0,$col);
    $mm = substr($val,$col+1);
    $utcofs12 = ($hh + 12) * 100 + $mm;
    info("new utcofs $hh:$mm");
    $tz = ofs2tz($val);
    info("new tz $tz");
  }
}

sub stop($)
{
  my ($cmd) = @_;

  query('s','');
}

my $clientid = "$$";

sub ret_close_err($$)
{
  my ($fh,$msg) = @_;

  error("$msg:$!");
  close($fh);
  return 0;
}

sub query($$$)
{
  my ($cmd,$region,$str) = @_;
  my ($stamp,$qfile,$qname,$qname_new,$qname_sub,$qname_rep,$qname_rcv,$serverid);

# prepare the query. use atomic file renames, server does the same
# query filename: 
#  [a-z]_     command
#  [a-z]_     (format todo) region
#  [0-9a-f]_  hex timestamp in sec plus _
#  [0-9a-f]   hex client id
#  .sub

# file content:
# list of (var type value) each on 1 line
# var:  [a-z] dep arr
# type [is] i = int s = string

  $stamp = time();
  $qname = sprintf("%s/%s_%s_%010x_%04x",$querydir,$cmd,$region,$stamp,$clientid);
  $qname_new = $qname . '.new';
  $qname_sub = $qname . '.sub';
  vrb("create $qname_new");
  return 1 if $dryrun;

  open($qfile,'>',$qname_new) or error_exit("cannot create $qname_new: $!");
  print($qfile $str . "\n");
  close($qfile);

  vrb("submit '$cmd' '$str'");

# rename to submit: server will pick up from here. reply has serverid appended
  vrb("rename to $qname_sub");
  rename($qname_new,$qname_sub);

  # cmd,region,stamp,clientid,serverid
  my $pat = qr'^[a-z]_[a-z]+_([0-9a-f]+)_([0-9a-f]+)_([0-9a-f]+)\.rep';

  while (time() - $stamp < $timeout) {
    {
      no integer;
      select(undef,undef,undef,0.1);  # = sleep 100 millisec
    }
    $serverid = filepatindir($pat,$stamp,$clientid,$querydir);
    last if length($serverid);
  }
  unless (length($serverid)) {
    info("no reply in $timeout sec");
    return;
  }

  # reply present: read and delete
  $qname_rep = $qname . '_' . $serverid . '.rep';
  $qname_rcv = $qname . '_' . $serverid . '.rcv';

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  my $reply;
  open($reply,'<',$qname_rep) or return error("cannot open $qname_rep:$!");

  stat $reply or return ret_close_err($reply,"cannot access $qname_rep: $!");
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
  return ret_close_err($reply,"$qname_rep is not a regular file") unless S_ISREG($mode);
  return ret_close_err($reply,"$qname_rep is empty") unless $size > 0;
  return ret_close_err($reply,"$qname_rep is empty") unless -r $qname_rep;

  my @lines = readline($reply);
  close($reply);
  unlink $qname_rep or return error("cannot remove $qname_rep:$!");

  return error("$qname_rep is empty") unless (scalar @lines);
#  foreach my $line (@lines) info("$line");
  print @lines;
  unlink $qname_rcv or return error("cannot remove $qname_rcv:$!");
}

# obtain query dir from current config
sub readcfg()
{
  my ($cfg,$var,$val);

  open($cfg,'<',$currentconfig)  or error_exit("cannot open $currentconfig: $!\n\nCheck if the tripover server is running in this dir");

  my @cfglines = readline($cfg);
  unless (scalar @cfglines) { error_exit("$currentconfig is empty\n\nCheck if the tripover server is running in this dir"); }

  my $varisval = qr'^([-a-zA-Z0-9_.]+)\s*=?\s*([-a-zA-Z0-9_.]+)';

  foreach my $line (@cfglines) {
    ($var,$val) = ($line =~ $varisval);
    next unless defined $var;
    next if $var ne $querydirvar;
    $querydir = $val;
    last;
  }
  error_exit("empty query config") unless length($querydir);
  vrb("query dir $querydir/");
}

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub usage()
{
  info("usage: plantrip [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("plan <from> <to>   plan a trip");
  info("stop               stop server\n");
  info("set <var> <value>  set variable\n");
  info("get [var]          get variable (? for list)\n");
  info("without command, interactive mode is entered");
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover commandline client version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

my (%tzofs,%tzdstofs);

sub readtzinfo()
{
  my $tzname = 'tzinfo.txt';
  my $tzfile;
  my $col = 0;
  my ($line,$tzstr,$tz,$ofs,$dstofs,$a,$b,$c,$alt);
  my @tzs;
  my $tzcol = 3;
  my $ofscol = 5;
  my $dstofscol = 6;

  # read timezone info from wikipedia export, in turn from iana TZ database 
  open($tzfile,'<:encoding(UTF-8)',$tzname) or return warning("cannot open $tzname:$!");
  my @lines = readline($tzfile);
  close($tzfile);
  for $line (@lines) {
    next unless length($line);
    next if index($line,'#') == 0;

    @tzs = ();
    if (index($line,'|-') == 0) {
      $col = 0;
    } elsif (index($line,'|') == 0) {
      $line = substr($line,1);
      $col++;
    }

    if ($col == $tzcol) {
      $a = index($line,'[[');
      $b = index($line,']]');
      $tzstr = substr($line,$a+2,$b-3);
    } elsif ($col == $ofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      $ofs = substr($line,$a+5,$c-6);
      if (substr($ofs,0,1) eq "\x{2212}") { $ofs = '-' . substr($ofs,1); }
    } elsif ($col == $dstofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      if ($a < 0) { vrb("no dstofs for $tz abc $line"); $dstofs = $ofs; }
      else { $dstofs = substr($line,$a+5,$c-6); }
    } elsif ($col > $dstofscol) {
      while (length($tzstr)) {
        $alt = index($tzstr,'|');
        if ($alt < 0) {
          push @tzs,$tzstr;
          $tzstr = '';
        } else {
          $tz = substr($tzstr,0,$alt);
          vrb("tz '$tz' ofs '$ofs'");
          push @tzs,$tz;
          $tzstr = substr($tzstr,$alt + 1);
          vrb("tzstr '$tzstr'");
        }
      }
      foreach $tz (@tzs) {
        $tzofs{$tz} = $ofs;
        $tzdstofs{$tz} = $dstofs;
        vrb("tz '$tz' ofs '$ofs'");
      }
      $col = 0;
    }
  }
  return 1;
}

sub tz2ofs($)
{
  my ($str) = @_;
  my ($hh,$mm,$hhmm);

  unless (exists($tzofs{$str})) { warning("no timezone info for $str"); return (0,0); }

  $hhmm = $tzofs{$str};
  $a = index($hhmm,':');
  $hh = substr($hhmm,0,$a);
  $mm = substr($hhmm,$a+1);
  vrb("utc offset hh $hh mm $mm");
  return ($hh,$mm);
}

sub ofs2tz($)
{
  my ($hhmm) = @_;
  my ($hm,$str) = @_;

  while (($str,$hm) = each %tzofs) {
    return $str if $hm eq $hhmm;
  }
  return $hhmm;
}

sub init()
{
  readcfg();
  unless (-d $querydir) {
    info("creating configured query dir $querydir");
    mkdir($querydir) || error_exit("cannot create query dir:$!");
  }
  readtzinfo();
}

my ($arg,$opt,$inopt,$cmd,$line,$prvline);
my ($dep,$arr);
my @args;

if (@ARGV > 0) {
  foreach $arg (@ARGV) {
    if (substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
      if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
    }
  }

  $inopt = 1;
  foreach $arg (@ARGV) {
    if ($inopt and substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
      elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
      elsif ($opt eq 'h' or $opt eq 'help') { usage(); exit 1; }
      elsif ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      else { info("ignoring unknown option -$opt"); }
    } else {
      $inopt = 0;
      push(@args,$arg);
    }
  }
  if (@args > 0) {
    init();
    $cmd = $args[0];
    if ($cmd eq 'stop') {
      stop($cmd);
    } elsif ($cmd eq 'plan') {
      exit info("plan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      $maxstop = $args[3] if (@args > 3);
      $dayrange = $args[4] if (@args > 4);
      $startdate = $args[5] if (@args > 5);
      plan($dep,$arr);
      agedir($querydir,time() - $agelimit);
    } elsif ($cmd eq 'iplan') {
      exit info("iplan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      $maxstop = $args[3] if (@args > 3);
      $dayrange = $args[4] if (@args > 4);
      $startdate = $args[5] if (@args > 5);
      iplan($dep,$arr);
      agedir($querydir,time() - $agelimit);
    } else { info("unknown command"); }
  }
  exit 0;
}

init();

info("entering command loop. commands:\n");
info("  plan <from> <to> name or coords");
info("  quit, exit");

# loop 
$cmd = ''; $prvline = '';
while ($cmd ne 'quit') {
  print("plantrip % ");
  $line = <STDIN>;
  next unless defined $line and length($line);
  $line = trimws($line);
  $line = $prvline if $line eq '!!';
  @args = split(' ',$line);
  $cmd = '';
  $cmd = 'quit' if index($line,'quit') == 0;
  $cmd = 'quit' if index($line,'exit') == 0;
  $cmd = 'plan' if index($line,'plan') == 0;
  $cmd = 'iplan' if index($line,'iplan') == 0;
  $cmd = 'stop' if index($line,'stop') == 0;
  $cmd = 'set' if index($line,'set') == 0;
  $cmd = 'get' if index($line,'get') == 0;
  info("unrecognised command '$line'") if length($line) and not length($cmd);
  $prvline = $line;
  if ($cmd eq 'plan') {
    plan($args[1],$args[2]);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'iplan') {
    iplan($args[1],$args[2]);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'stop') {
    stop($line);
  } elsif ($cmd eq 'set') {
    setvar($args[1],$args[2]);
  } elsif ($cmd eq 'get') {
    getvar($args[1]);
  }
}
