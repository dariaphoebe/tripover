#!/usr/bin/perl -W

# plantrip - local commandline client for tripover

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014-2015 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# rudimentary interface and implementation : to be elaborated

# post trip requests to a local queue, and watch that queue for answers
# the queue location is configured in the server, yet created here if nonexistent

use 5.012;
use strict;
use integer;

use Fcntl ':mode';

my $version_maj = 0;
my $version_min = 13;
my $lastchanged = "20 jan 2015";

my $copyright = "Copyright (C) 2014-2015, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $currentconfig = 'tripover.curcfg';
my $querydirvar = 'querydir';
my $querydir;

my $portrefname = 'portrefs.txt';

my $timeout = 12; # seconds

my $agelimit = 60; # seconds

# stop at compile-time warnings
local $SIG{__WARN__} = sub { print "$_[0]\n"; exit 1; };

my $logname = 'plantrip.log';
my $logfd;

if (-t STDOUT) {
  for (my $bck = 8; $bck >= 0; $bck--) {
    rename($logname . '.' . $bck,$logname . '.' . ($bck+1)) if (-f $logname . '.' . $bck);
  }
  rename($logname,$logname . '.0') if -f $logname;
  open($logfd,'>:encoding(UTF-8)',$logname) or print("cannot create $logname:$!");
}

# unbuffered i/o
my $orgfh = select STDOUT; $| = 1; select STDERR; $| = 1; select $orgfh;

binmode(STDOUT,':utf8');

my %portnames;
my %portpnames;
my %portids;
my %idbysub;
my $portcnt = 0;

sub msg($) {
  my ($m) = @_;

  print("$m\n");
  print($logfd "$m\n") if defined $logfd;
  return 1;
}

sub vrb($)     { msg("$_[0]") if $verbose; return 1; }
sub info($)    { return msg("$_[0]"); }
sub warning($) { return msg("warning: $_[0]"); }
sub error($)   { msg("error: $_[0]"); return 0; }

sub error_exit($) { print ("error: $_[0]\n"); exit 1; }

sub filepatindir($$$$)
{
  my ($pat,$stamp,$clientid,$dir) = @_;

  my ($dh,$serverid,$tstamp,$tid,$hstamp,$hid,$name);
  my @names;

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    ($hstamp,$hid,$serverid) = ($name =~ $pat);
    next unless (defined $hstamp and defined $hid and defined $serverid);
    $tstamp = hex($hstamp);
    $tid = hex($hid);
    if ($tstamp == $stamp and $tid == $clientid)  {
      info("reply handled by server $serverid");
      return $serverid;
    } else { vrb("reply from $tstamp $tid, expect $stamp $clientid $serverid"); }
  }
  return '';
}

# catchall for any leftover file in query queue.
sub agedir($$)
{
  my ($dir,$limit) = @_;

  my ($dh,$serverid,$tstamp,$tid,$name,$path);
  my @names;

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  opendir($dh,$dir) or error_exit("cannot open $dir:$!");
  @names = readdir($dh);
  closedir($dh);
  foreach $name (@names) {
    next if $name eq '.' or $name eq '..';

    $path = $dir . '/' . $name;

    stat($path) or return error("cannot access $path: $!");
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
    return error("$path is not a regular file") unless S_ISREG($mode);

    if ($mtime < $limit)  {
      vrb("removing $path on timestamp $mtime below $limit");
      return 1 if $dryrun;
      unlink $path or return error("cannot remove $path: $!");
    }
  }
  return 1;
}

my $haveportrefs = 0;

# read port to id mappings
sub readportrefs($)
{
  my ($fname) = @_;

  my ($fh,$line,$id,$subid,$name,$lcname,$nlen,$lat,$lon);

  open($fh,'<:encoding(UTF-8)',$fname) or error_exit("cannot open $fname: $!");

  my @lines = readline($fh);
  unless (scalar @lines) { error_exit("$fname is empty"); }

  foreach $line (@lines) {
    next unless length($line);
    next if index($line,'#') == 0;

    ($id,$subid,$name,$lat,$lon) = split("\t",$line);
    next unless defined $id and defined $name;
    $lcname = lc($name);
    $portnames{$name} = $subid;
    $portnames{$lcname} = $subid;
    $portids{$subid} = $name unless defined $portids{$subid};
    $idbysub{$subid} = $id;
  }
  $portcnt = scalar(keys %portids);
  info("$portcnt ports");

  # prepare partial ( prefix) matching
  while (($name,$subid) = each %portnames) {
    $nlen = length($name);
    next if $nlen < 4;
    while ($nlen-- > 3) {
      chop $name;
      if (defined($portpnames{$name})) { $portpnames{$name} .= "\t" . $subid; }
      else { $portpnames{$name} = $subid; }
    }
  }
  $haveportrefs = 1;
}

# returns sub-id by name
sub portbyname($)
{
  my ($name) = @_;

  my ($port,$id,$subid,$seq,$lcname,$plen,$line);
  my @plist;

  readportrefs($portrefname) unless $haveportrefs;

  $lcname = lc($name);
  if (exists($portnames{$name})) { return $portnames{$name}; }
  if (exists($portnames{$lcname})) { return $portnames{$lcname}; }
  $name = $lcname unless exists($portpnames{$name});
  unless (exists($portpnames{$name})) {
    info("no matches for prefix '$name'");
    return '';
  }
  @plist = split("\t",$portpnames{$name});
  $plen = scalar(@plist);
  return $plist[0] if $plen == 1;
  info("$plen matches for $name");
  if ($plen < 40) {
    $seq = 1;
    foreach $subid (@plist) {
      printf("%2u %s\n",$seq++,$portids{$subid});
    }
    do {
      print('Choose port by number or q to quit: ');
      $line = <STDIN>;
      next unless defined $line and length($line);
      $line = trimws($line);
      next unless length($line);
      return '' if $line eq 'q' or $line eq 'x';
      if ($line =~ qr'^[0-9]+$') {
        $seq = $line;
        if ($seq <= $plen and $seq != 0) {
          return $plist[$seq - 1];
        } else {
          print("port number not in above list\n");
        }
      } else {
        print("expected port number or command\n");
      }
    } while 1;

  } else {  # list too long
    return ''; # todo
  }
  return '';
}

sub iplan($$$$$)
{
  my ($dep,$arr,$stops,$dayrange,$startday) = @_;

  my ($depname,$arrname,$qstr);

  if ($haveportrefs) {
    if (exists($portids{$dep})) { $depname = $portids{$dep}; }
    else { $depname = "unknown"; }
    if (exists($portids{$arr})) { $arrname = $portids{$arr}; }
    else { $arrname = "unknown"; }

    info("dep $dep '$depname'");
    info("arr $arr '$arrname'");
  } else {
    info("dep $dep");
    info("arr $arr");
  }

  my $region = 'glob';

  $qstr = "dep i $dep\narr i $arr\ntspan i $dayrange\ndeptmin i $startday\n";
  if (length($stops)) { $qstr .= "histop i $stops\n"; }
  query('p',$region,$qstr);
}

sub plan($$$$$)
{
  my ($depname,$arrname,$stops,$dayrange,$startday) = @_;

  my ($dep,$arr);

  $dep = portbyname($depname);
  return 1 unless length($dep);
  info("$depname resolved into $portids{$dep}");
  $arr = portbyname($arrname);
  return 1 unless length($arr);
  info("$arrname resolved into $portids{$arr}");

  my $pdep = $idbysub{$dep};
  my $parr = $idbysub{$arr};

  iplan($pdep,$parr,$stops,$dayrange,$startday);
}

sub stop($)
{
  my ($cmd) = @_;

  query('s','');
}

my $clientid = "$$";

sub ret_close_err($$)
{
  my ($fh,$msg) = @_;

  error("$msg:$!");
  close($fh);
  return 0;
}

sub query($$$)
{
  my ($cmd,$region,$str) = @_;
  my ($stamp,$qfile,$qname,$qname_new,$qname_sub,$qname_rep,$qname_rcv,$serverid);

# prepare the query. use atomic file renames, server does the same
# query filename: 
#  [a-z]_     command
#  [a-z]_     (format todo) region
#  [0-9a-f]_  hex timestamp in sec plus _
#  [0-9a-f]   hex client id
#  .sub

# file content:
# list of (var type value) each on 1 line
# var:  [a-z] dep arr
# type [is] i = int s = string

  $stamp = time();
  $qname = sprintf("%s/%s_%s_%010x_%04x",$querydir,$cmd,$region,$stamp,$clientid);
  $qname_new = $qname . '.new';
  $qname_sub = $qname . '.sub';
  vrb("create $qname_new");
  return 1 if $dryrun;

  open($qfile,'>',$qname_new) or error_exit("cannot create $qname_new: $!");
  print($qfile $str . "\n");
  close($qfile);

  info("submit '$cmd' '$str'");

# rename to submit: server will pick up from here. reply has serverid appended
  vrb("rename to $qname_sub");
  rename($qname_new,$qname_sub);

  # cmd,region,stamp,clientid,serverid
  my $pat = qr'^[a-z]_[a-z]+_([0-9a-f]+)_([0-9a-f]+)_([0-9a-f]+)\.rep';

  while (time() - $stamp < $timeout) {
    {
      no integer;
      select(undef,undef,undef,0.1);  # = sleep 100 millisec
    }
    $serverid = filepatindir($pat,$stamp,$clientid,$querydir);
    last if length($serverid);
  }
  unless (length($serverid)) {
    info("no reply in $timeout sec");
    return;
  }

  # reply present: read and delete
  $qname_rep = $qname . '_' . $serverid . '.rep';
  $qname_rcv = $qname . '_' . $serverid . '.rcv';

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);

  my $reply;
  open($reply,'<',$qname_rep) or return error("cannot open $qname_rep:$!");

  stat $reply or return ret_close_err($reply,"cannot access $qname_rep: $!");
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat _;
  ret_close_err($reply,"$qname_rep is not a regular file") unless S_ISREG($mode);
  ret_close_err($reply,"$qname_rep is empty") unless $size > 0;
  ret_close_err($reply,"$qname_rep is empty") unless -r $qname_rep;

  my @lines = readline($reply);
  close($reply);
  unlink $qname_rep or return error("cannot remove $qname_rep:$!");

  return error("$qname_rep is empty") unless (scalar @lines);
#  foreach my $line (@lines) info("$line");
  print @lines;
  unlink $qname_rcv or return error("cannot remove $qname_rcv:$!");
}

# obtain query dir from current config
sub readcfg()
{
  my ($cfg,$var,$val);

  open($cfg,'<',$currentconfig)  or error_exit("cannot open $currentconfig: $!\n\nCheck if the tripover server is running in this dir");

  my @cfglines = readline($cfg);
  unless (scalar @cfglines) { error_exit("$currentconfig is empty\n\nCheck if the tripover server is running in this dir"); }

  my $varisval = qr'^([-a-zA-Z0-9_.]+)\s*=?\s*([-a-zA-Z0-9_.]+)';

  foreach my $line (@cfglines) {
    ($var,$val) = ($line =~ $varisval);
    next unless defined $var;
    next if $var ne $querydirvar;
    $querydir = $val;
    last;
  }
  error_exit("empty query config") unless length($querydir);
  vrb("query dir $querydir/");
}

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub usage()
{
  info("usage: plantrip [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("plan <from> <to>   plan a trip");
  info("stop               stop server\n");
  info("without command, interactive mode is entered");
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover commandline client version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

sub init()
{
  readcfg();
  unless (-d $querydir) {
    mkdir($querydir) || error_exit("cannot create query dir:$!");
  }
}

my ($arg,$opt,$cmd,$line,$prvline);
my ($dep,$arr,$stops,$dayrange,$startday);
my @args;

if (@ARGV > 0) {
  foreach $arg (@ARGV) {
    if (substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
      if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
    }
  }

  foreach $arg (@ARGV) {
    if (substr($arg,0,1) eq '-') {
      $opt = $arg;
      $opt =~ s/^-+//;
      if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
      elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
      elsif ($opt eq 'h' or $opt eq 'help') { usage(); exit 1; }
      elsif ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
      else { info("ignoring unknown option -$opt"); }
    } else {
      push(@args,$arg);
    }
  }
  if (@args > 0) {
    init();
    $cmd = $args[0];
    if ($cmd eq 'stop') {
      stop($cmd);
    } elsif ($cmd eq 'plan') {
      exit info("plan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      if (@args > 3) { $stops = $args[3]; }
      else { $stops = ''; }
      if (@args > 4) { $dayrange = $args[4]; }
      else { $dayrange = 3; }
      if (@args > 5) { $startday = $args[5]; }
      else { $startday = 20150110; } # eng provision: typ 
      plan($dep,$arr,$stops,$dayrange,$startday);
      agedir($querydir,time() - $agelimit);
    } elsif ($cmd eq 'iplan') {
      exit info("iplan needs 'from' and 'to' arg") unless (@args > 2);
      $dep = $args[1]; $arr = $args[2];
      if (@args > 3) { $stops = $args[3]; }
      else { $stops = ''; }
      if (@args > 4) { $dayrange = $args[4]; }
      else { $dayrange = 3; }
      if (@args > 5) { $startday = $args[5]; }
      else { $startday = 20150110; } # eng provision: typ 
      iplan($dep,$arr,$stops,$dayrange,$startday);
      agedir($querydir,time() - $agelimit);
    } else { info("unknown command"); }
  }
  exit 0;
}

init();

info("entering command loop. commands:\n");
info("  plan <from> <to>");
info("  quit, exit");

# loop 
$cmd = ''; $prvline = '';
while ($cmd ne 'quit') {
  print("plantrip % ");
  $line = <STDIN>;
  next unless defined $line and length($line);
  $line = trimws($line);
  $line = $prvline if $line eq '!!';
  @args = split(' ',$line);
  $cmd = '';
  $cmd = 'quit' unless index($line,'quit') < 0;
  $cmd = 'quit' unless index($line,'exit') < 0;
  $cmd = 'plan' unless index($line,'plan') < 0;
  $cmd = 'iplan' unless index($line,'iplan') < 0;
  $cmd = 'stop' unless index($line,'stop') < 0;
  info("unrecognised command") if length($line) and not length($cmd);
  $dayrange = 3; $startday = 20140916; $stops = 2;
  $prvline = $line;
  if ($cmd eq 'plan') {
    plan($args[1],$args[2],$stops,$dayrange,$startday);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'iplan') {
    iplan($args[1],$args[2],$stops,$dayrange,$startday);
    agedir($querydir,time() - $agelimit);
  } elsif ($cmd eq 'stop') { stop($line); }
}
