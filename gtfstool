#!/usr/bin/perl -W

# gtfstool - handle gtfs feeds

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# primary use is to import gtfs feeds into tripover format.
# feeds can be merged, filtered, or verified
# optional export from tripover format to gtfs

use 5.008;
use strict;
use integer;

my $ccmsg = '';
local $SIG{__WARN__} = sub { print "$ccmsg $_[0]"; exit 1;  };

my $version_maj = 0;
my $version_min = 10;
my $lastchanged = "15 oct 2014";

my $copyright = "Copyright (C) 2014, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $warningcnt = 0;
my $errorcnt = 0;

sub info($)    { print("$_[0]\n"); return 1; }
sub warning($) { print("warning: $_[0]\n"); $warningcnt++; return 1; }
sub error($)   { print("error: $_[0]\n"); $errorcnt++; return 0; }

sub error_exit($) { print ("error: $_[0]\n"); exit 1; }

sub vrb($) {
  $ccmsg = $_[0] . "\n";
  print("$_[0]\n") if $verbose;
  return 1;
}

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub usage()
{
  info("usage: gtfstool [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("import <indir> [outdir] import gtfs into tripover");
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover gtfs tool version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

sub init()
{
}

my $rtype_walk = 1699;

# use integer codes for fields
my $col_enum = 1;
my $col_stopid    = $col_enum++;
my $col_stopcode  = $col_enum++;
my $col_stopname  = $col_enum++;
my $col_stopdesc  = $col_enum++;
my $col_stoplat   = $col_enum++;
my $col_stoplon   = $col_enum++;
my $col_zoneid    = $col_enum++;
my $col_stopurl   = $col_enum++;
my $col_loctype   = $col_enum++;
my $col_parent    = $col_enum++;
my $col_platform  = $col_enum++;

my $col_tripid = $col_enum++;
my $col_arrtime = $col_enum++;
my $col_deptime = $col_enum++;
my $col_stopseq = $col_enum++;
my $col_picktype = $col_enum++;
my $col_droptype = $col_enum++;

my $col_routeid = $col_enum++;
my $col_routesname = $col_enum++;
my $col_routelname = $col_enum++;
my $col_routedesc = $col_enum++;
my $col_routetype = $col_enum++;

my $col_serviceid = $col_enum++;

my $col_unknown = $col_enum++;

# store field results here
my %stopids;

my %stopnames;

my @stops;

my @stopdeps;
my @stoparrs;

my %parents;

my %tripids;
my %tripseq;
my %triproutes;
my $walkroute;

my @trips;

my @hops;

my @routes;
my %routeids;
my %norouteids;
my %rtypes;

my @stentries;

my @trip_ids;
my @dep_times;
my @arr_times;

my $stopcnt = 0;
my $ttcnt = 0;
my $hopcnt = 0;
my $tripcnt = 0;
my $routecnt = 0;
my $noroutecnt = 0;

my $nondigits = qr'[^0-9]';

my $unquoter = qr'/""/"/g';

sub inarray($@) {
  my ($a,@arr) = @_;

  foreach my $b (@arr) { return 1 if $a eq $b; }
  return 0;
}

sub readstops($)
{
  my ($dir) = @_;

  my ($stopfile,$stopsname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req,$val);
  my ($id,$stopid,$code,$name,$desc,$lat,$lon,$zone_id,$url,$loctype,$parent,$platform);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $stopsname = $dir . '/' . 'stops.txt';

  info("reading $stopsname");
  return info("dryrun") if $dryrun;

  open($stopfile,'<',$stopsname) or return error("cannot open stops.txt:$!");
  my $headline = readline($stopfile);
  error_exit("stops.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_stopid if ($colname eq 'stop_id');
    $colid = $col_stopcode if ($colname eq 'stop_code');
    $colid = $col_stopname if ($colname eq 'stop_name');
    $colid = $col_stopdesc if ($colname eq 'stop_desc');
    $colid = $col_stoplat if ($colname eq 'stop_lat');
    $colid = $col_stoplon if ($colname eq 'stop_lon');
    $colid = $col_zoneid if ($colname eq 'zone_id');
    $colid = $col_stopurl if ($colname eq 'stop_url');
    $colid = $col_loctype if ($colname eq 'location_type');
    $colid = $col_parent if ($colname eq 'parent_station');
    $colid = $col_platform if ($colname eq 'platform_code');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields") if (@cols < @colnames);

  foreach $req ('stop_id','stop_name','stop_lat','stop_lon') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($stopfile);
  close($stopfile);
  error_exit("stops.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $line .= ',';

    $linno++;
#    last if ($linno > 10);

    $id = ''; $code = ''; $name = ''; $lat = ''; $lon = '';
    $loctype = ''; $parent = ''; $platform = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;
      $val = substr($line,0,$comma);

      if ($col == $col_stopid) {
        $id = substr($line,0,$comma);
        # may be integer or string. must be unique in set
        # tripover needs an integer : use line number as derived id

        if (exists($stopids{$id})) {
          warning("$linno: stop id $id already defined on line $stopids{$id}");
        } else {
          $stopid = $linno;
          $stopids{$id} = $stopid;
          $stopdeps[$stopid] = 0;
          $stoparrs[$stopid] = 0;
        }

      } elsif ($col == $col_stopcode) {
        $code = substr($line,0,$comma);

      } elsif ($col == $col_stopname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $name = substr($line,0,$endq);
          $name =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else { # unquoted
          $name = substr($line,0,$comma);
        }

      } elsif ($col == $col_stopdesc) {
        if (substr($line,0,1) eq '"') {
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $desc = substr($line,0,$endq);
          $desc =~ $unquoter;
          $line = substr($line,$endq+1);
          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else {
          $desc = substr($line,0,$comma);
        }

      } elsif ($col == $col_stoplat) {
        $lat = $val;

      } elsif ($col == $col_stoplon) {
        $lon = $val;

      } elsif ($col == $col_parent) {
        $parent = $val;

      } elsif ($col == $col_platform) {
        $platform = $val;

      } elsif ($col == $col_loctype) {
        $loctype = $val;
      }

      $line = substr($line,$comma+1);

    } # each col

    warning("$id has empty lon") if length($lon) < 1;
    warning("$id has empty lat") if length($lat) < 1;

    $stopnames{$stopid} = $name;

    if (length($parent) > 0) {
      $parents{$parent} .= $stopid . ' ';
      if (length($loctype) > 0 and $loctype == 1) {
        info("$name is a station");
      }
    }
    push(@stops,join("\t",$id,$name,$code,$desc,$lat,$lon));

  }

  $stopcnt = scalar(@stops);
  info("$stopcnt stops");

#  for $name (values %stopnames) { info($name); }

  return 1;
}

# todo from config or cmdline
my $include_tram = 1;
my $include_metro = 1;
my $include_rail = 1;
my $include_bus = 1;

sub filtermode($)
{
  my ($type) = @_;

  return 1 if ($type == 0 and $include_tram == 1);
  return 1 if ($type == 1 and $include_metro == 1);
  return 1 if ($type == 2 and $include_rail == 1);
  return 1 if ($type == 3 and $include_bus == 1);
  return 0;
}

sub readroutes($)
{
  my ($dir) = @_;

  my ($routefile,$routefname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$name,$slname,$rtype);

  $routefname = $dir . '/' . 'routes.txt';

  info("reading $routefname");
  return info("dryrun") if $dryrun;

  open($routefile,'<',$routefname) or return error("cannot open routes.txt:$!");
  my $headline = readline($routefile);
  error_exit("routes.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_routeid if ($colname eq 'route_id');
    $colid = $col_routesname if ($colname eq 'route_short_name');
    $colid = $col_routelname if ($colname eq 'route_long_name');
    $colid = $col_routedesc if ($colname eq 'route_desc');
    $colid = $col_routetype if ($colname eq 'route_type');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  error_exit("missing required route name") unless inarray('route_short_name',@colnames) or inarray('route_long_name',@colnames);

  foreach $req ('route_id','route_type') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($routefile);
  close($routefile);
  error_exit("routes.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';
    $name = ''; $slname = ''; $route_id = ''; $rtype = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $col_routeid) {
        $route_id = substr($line,0,$comma);

      } elsif ($col == $col_routesname or $col == $col_routelname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $name = substr($line,0,$endq);
          $name =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else { # unquoted
          $name = substr($line,0,$comma);
        }
        $slname = $name if length($name);

      } elsif ($col == $col_routetype) {
        $rtype = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    vrb("$linno $route_id '$slname' $rtype");
    $routeid = $linno;

    if (exists($routeids{$route_id})) {
      warning("$linno: route id $route_id already defined on line $routeids{$route_id}");
    } elsif (filtermode($rtype)) {
      $routeids{$route_id} = $routeid;
      $rtypes{$routeid} = $rtype;
      push(@routes,join("\t",$route_id,$slname,$rtype));
    } else {
      $rtypes{$routeid} = $rtype;
      $noroutecnt++;
      $routeids{$route_id} = $routeid;
      $norouteids{$route_id} = $routeid;
    }

  } # each line

  $route_id = 'walk';
  $walkroute = $linno + 1;
  $rtype = $rtype_walk;
  $slname = 'walk inferred from parent station';
  $routeids{$route_id} = $walkroute;
  $rtypes{$walkroute} = $rtype;
  push(@routes,join("\t",$route_id,$slname,$rtype));

  info("add inferred walk route $walkroute as type $rtype");
  $routecnt = scalar(@routes);
  info("$routecnt routes, $noroutecnt filtered out");

  return 1;
}

sub readtrips($)
{
  my ($dir) = @_;

  my ($tripfile,$tripfname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$trip_id,$service_id);

  $tripfname = $dir . '/' . 'trips.txt';

  info("reading $tripfname");
  return info("dryrun") if $dryrun;

  open($tripfile,'<',$tripfname) or return error("cannot open trips.txt:$!");
  my $headline = readline($tripfile);
  error_exit("trips.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_routeid if ($colname eq 'route_id');
    $colid = $col_serviceid if ($colname eq 'service_id');
    $colid = $col_tripid if ($colname eq 'trip_id');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  foreach $req ('route_id','service_id','trip_id') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($tripfile);
  close($tripfile);
  error_exit("trips.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';

    $trip_id = ''; $route_id = ''; $service_id = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $col_routeid) {
        $route_id = substr($line,0,$comma);
      } elsif ($col == $col_serviceid) {
        $service_id = substr($line,0,$comma);
      } elsif ($col == $col_tripid) {
        $trip_id = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    if (length($trip_id) == 0) {
      warning("$linno: missing trip id for route  $route_id");
      next;
    }
    if (exists($tripids{$trip_id})) {
      warning("$linno: trip id $trip_id previously defined on line $tripids{$trip_id}");
      next;
    } elsif (exists($norouteids{$route_id})) {  # filtered
      $tripids{$trip_id} = $linno;
      $triproutes{$trip_id} = $route_id;
    } elsif (exists($routeids{$route_id})) {
      $tripids{$trip_id} = $linno;
      $triproutes{$trip_id} = $route_id;
      $tripseq{$trip_id} = '';
      push(@trips,join("\t",$route_id,$service_id,$trip_id));
    } else {
      warning("$linno: undefined route id $route_id");
    }

  } # each line

  $tripcnt = scalar(@trips);
  info("$tripcnt trips");

  return 1;
}

sub readstoptimes($)
{
  my ($dir) = @_;

  my ($stoptimes,$stoptimesname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$rid,$trip_id,$arr_time,$dep_time,$stop_id,$stopid,$stop_seq,$dep);
  my ($route,$trip,$seq,$prvseq,$hop,$dep_id,$arr_id,$prvstop_id);
  my ($concnt,$depcnt,$arrcnt);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $stoptimesname = $dir . '/' . 'stop_times.txt';

  info("reading $stoptimesname");
  return info("dryrun") if $dryrun;

  open($stoptimes,'<',$stoptimesname) or return error("cannot open stop_times.txt:$!");
  my $headline = readline($stoptimes);
  error_exit("stoptimes.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_tripid if ($colname eq 'trip_id');
    $colid = $col_arrtime if ($colname eq 'arrival_time');
    $colid = $col_deptime if ($colname eq 'departure_time');
    $colid = $col_stopid if ($colname eq 'stop_id');
    $colid = $col_stopseq if ($colname eq 'stop_sequence');
    $colid = $col_picktype if ($colname eq 'pickup_type');
    $colid = $col_droptype if ($colname eq 'drop_off_type');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields") if (@cols < @colnames);

  foreach $req ('trip_id','arrival_time','departure_time','stop_id','stop_sequence') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($stoptimes);
  close($stoptimes);
  error_exit("stop_times.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;
#    last if ($linno > 10000);

    $line .= ',';
    $trip_id = ''; $stop_id = ''; $stop_seq = ''; $dep_time = ''; $arr_time = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $col_tripid) {
        $trip_id = substr($line,0,$comma);

      } elsif ($col == $col_stopid) {
        $stop_id = substr($line,0,$comma);
        warning("$linno: undefined stop id $stop_id") unless exists $stopids{$stop_id};

      } elsif ($col == $col_stopseq) {
        $stop_seq = substr($line,0,$comma);

      } elsif ($col == $col_deptime) {
        $dep_time = substr($line,0,$comma);

      } elsif ($col == $col_arrtime) {
        $arr_time = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    unless (exists($tripids{$trip_id})) {
      warning("$linno: undefined trip id $trip_id");
      next;
    }

    if (length($stop_seq) == 0) { warning("$linno: empty stop_seq for $stop_id"); next; }
    elsif ($stop_seq =~ $nondigits) { warning("$linno: stop_seq '$stop_seq' not numerical for $stop_id"); next; }

    unless (exists($triproutes{$trip_id})) {
      warning("$linno: undefined route for trip id $trip_id");
      next;
    }
    $route_id = $triproutes{$trip_id};
    next if exists $norouteids{$route_id};

    $stopid = $stopids{$stop_id};

    $tripseq{$trip_id} .= $stopid . ' ';

    push(@stentries,join("\t",$route_id,$trip_id,$stop_id,$stop_seq,$dep_time,$arr_time));

    info("line $linno of $linecnt") if ($linno % 100000) == 0;

  } # each line

  $ttcnt = scalar(@stentries);
  info("$ttcnt time entries");

  my @das;
  my @tripstops;
  my ($id,$troute,$seqlen,$i,$seq2,$deparr,$arr,$depid,$arrid,$routeno,$name);

  $routeno = 0;
  while (($route,$rid) = each %routeids) {
#    next if ($rid > 100);
    next if exists $norouteids{$route};

    info("processing route $routeno of $routecnt") if ($routeno++ % 100) == 0;

    my %routeseqs;

    while (($trip,$troute) = each %triproutes) {
      next if $troute ne $route;
      @tripstops = split(' ',trimws($tripseq{$trip}));

      $seqlen = scalar @tripstops;
      next unless $seqlen > 1;

      $dep = $tripstops[0];
      for ($i = 1; $i < $seqlen; $i++) {
        $arr = $tripstops[$i];
        next if $dep == $arr;
        $deparr = $dep . '_' . $arr;
        $routeseqs{$deparr} = $i;
        $dep = $arr;
      }
    }

    for $deparr (keys %routeseqs) {
      @das = split('_',$deparr);
      $dep = $das[0]; $arr = $das[1];

      push (@hops, join("\t",$dep,$arr,$route,$hopcnt));

      $stopdeps[$dep]++;
      $stoparrs[$arr]++;

      $hopcnt++;
    }

    info("$hopcnt hops") if ($hopcnt % 1000) == 0;
  }
  info("$hopcnt hops");

  if ($noroutecnt == 0) {
    while (($id,$stopid) = each %stopids) {
      $name = $stopnames{$stopid};
      if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0) {
        warning("stop $id $name is unconnected");
      } elsif ($stopdeps[$stopid] == 0) {
        info("stop $id $name has no departures");
      } elsif ($stoparrs[$stopid] == 0) {
        info("stop $id $name has no arrivals");
      }
    }
  }

  foreach $concnt (0 .. 6) {
    $depcnt = 0; $arrcnt = 0;
    for $stopid (values %stopids) {
      $depcnt++ if $stopdeps[$stopid] == $concnt;
      $arrcnt++ if $stoparrs[$stopid] == $concnt;
    }
    info("stops with $concnt departures : $depcnt");
    info("stops with $concnt arrivals   : $arrcnt");
  }

  my ($parent,$stoplst,@sibstop);

  # add walk connection to sibling stops
  while (($parent,$stoplst) = each %parents) {
    @sibstop = split(' ',trimws($stoplst));
    for $dep (@sibstop) {
      for $arr (@sibstop) {
        next if $dep == $arr;

        next if $stopdeps[$dep] == 0 and $stoparrs[$dep] == 0;
        next if $stopdeps[$arr] == 0 and $stoparrs[$arr] == 0;
        push (@hops, join("\t",$dep,$arr,'walk',$hopcnt++));
        push (@hops, join("\t",$arr,$dep,'walk',$hopcnt++));

        $stopdeps[$dep]++;
        $stoparrs[$arr]++;
        $stopdeps[$arr]++;
        $stoparrs[$dep]++;
      }
    }
  }

  foreach $concnt (0 .. 6) {
    $depcnt = 0; $arrcnt = 0;
    for $stopid (values %stopids) {
      $depcnt++ if $stopdeps[$stopid] == $concnt;
      $arrcnt++ if $stoparrs[$stopid] == $concnt;
    }
    info("stops with $concnt departures : $depcnt");
    info("stops with $concnt arrivals   : $arrcnt");
  }

  return 1;
}

sub import($)
{
  my ($dir) = @_;

  readstops($dir) or return 0;
  readroutes($dir) or return 0;
  readtrips($dir) or return 0;
  readstoptimes($dir) or return 0;
  return 1;
}

# todo autoscale on bbox and have tripover read bbox+scale
sub str2lat($)
{
  my ($inlat) = @_;

  no integer;

  my $lat;
  my $scale = 100000;

  $lat = ($inlat + 90.0) * $scale;
  return $lat;
}

sub str2lon($)
{
  my ($inlon) = @_;

  no integer;

  my $lon;
  my $scale = 100000;

  $lon = ($inlon + 180.0) * $scale;
  return $lon;
}

sub getdate()
{
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($^T);

  return sprintf("%u-%02u-%02u %u:%02u utc",$year+1900,$mon+1,$mday,$hour,$min);
}

sub writext($$)
{
  my ($indir,$outdir) = @_;

  my ($name,$portfile,$hopfile,$stop,@stopln,$stopid,$hop,@hopln,$route,$hopid);
  my ($dep_id,$arr_id,$dep,$arr,$fstopcnt,$depname,$arrname);
  my ($routeid,$rtype);

  info("writing tripover external format");
  return info("dryrun") if $dryrun;

  $fstopcnt = 0;
  for $stopid (values %stopids) {
    $fstopcnt++ if ($stopdeps[$stopid] > 0 or $stoparrs[$stopid] > 0);
  }

  info("writing $fstopcnt of $stopcnt ports in $outdir");

  my $portname = $outdir . '/ports.txt';
  my $oldportname = $portname . '.bak';
  unlink($oldportname) if -f $oldportname;
  rename($oldportname,$portname)if -f $portname;

  open($portfile,'>',$portname) or error_exit("cannot create $portname:$!");

  print($portfile "# ports.txt - tripover external port aka stops file\n\n");
  printf($portfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($portfile "# %u ports from %s/stops.txt\n\n",$fstopcnt,$indir);

  my ($stop_id,$stop_name,$stop_code,$stop_lat,$stop_lon,$lat,$lon);

  foreach $stop (@stops) {
    @stopln = split("\t",$stop);  #  $id,$name,$code,$desc,$lat,$lon));

    $stop_id = $stopln[0];
    $stopid = $stopids{$stop_id};
    next if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0);

    $stop_name = $stopln[1];
    $stop_code = $stopln[2];
    $stop_lat = $stopln[4];
    $stop_lon = $stopln[5];
    $lat = str2lat($stop_lat);
    $lon = str2lon($stop_lon);

    printf($portfile "%x\t%s\t%x\t%x # id %s code %s\n",$stopid,$stop_name,$lat,$lon,$stop_id,$stop_code);
  }
  close($portfile);

  info("writing $hopcnt hops");

  my $hopname = $outdir . '/hops.txt';
  my $oldhopname = $hopname . '.bak';
  unlink($oldhopname) if -f $oldhopname;
  rename($oldhopname,$hopname)if -f $hopname;

  open($hopfile,'>',$hopname) or error_exit("cannot create ports.txt:$!");
  print($hopfile "# hops.txt - tripover external hops aka trips file\n\n");
  printf($hopfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($hopfile "# %u hops from %s/stoptimes.txt\n\n",$hopcnt,$indir);

  foreach $hop (@hops) {
    @hopln = split("\t",$hop);
    $dep = $hopln[0];
    $arr = $hopln[1];
    $route = $hopln[2];
    $hopid = $hopln[3];

    $depname = $stopnames{$dep};
    $arrname = $stopnames{$arr};

    warning("route $route not found") unless exists $routeids{$route};
    $routeid = $routeids{$route};
    warning("$route type found") unless exists $rtypes{$routeid};
#    info("$dep $arr $route");
    $rtype = $rtypes{$routeid};
    if ($routeid eq $walkroute) {
    }
    printf($hopfile "%s\t%x\tD%u\tD%u\t%x # %s to %s\n",$route,$hopid,$dep,$arr,$rtype,$depname,$arrname);
  }
  return 1;
}

my ($arg,$opt,$cmd,$indir,$outdir);
my @args;

if (@ARGV == 0) { usage(); exit 1; }

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
    if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
  }
}

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
    elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
    elsif ($opt eq 'h' or $opt eq 'help') { usage(); exit 1; }
    elsif ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    else { info("ignring unknown option -$opt"); }
  } else {
    push(@args,$arg);
  }
}
if (@args > 0) {
  init();
  $cmd = $args[0];
  if ($cmd eq 'import') {
    error_exit("missing arg 'dir' for import") unless (@args > 1);
    $indir = $args[1];
    $outdir = (@args > 2) ? $args[2] : '.';
    import($indir) and writext($indir,$outdir);
  }
  else { info("unknown command"); }
}

info("$warningcnt warnings") if $warningcnt > 0;
info("$errorcnt errors") if $errorcnt > 0;
