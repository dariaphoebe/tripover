#!/usr/bin/perl -W

# gtfstool - handle gtfs feeds

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014-2015 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# primary use is to import gtfs feeds into tripover format.
# see usage below
# basic provisions for feed merge : add agencyID to all IDs, have tiumezone per agency in routes, trips and calendar
# basic filtering on transport mode

use 5.012;
use strict;
use utf8;

my $version_maj = 0;
my $version_min = 30;
my $lastchanged = "6 mar 2015";

my $copyright = "Copyright (C) 2014-2015, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;
my $testonly = 0;

my $anaout = 0;
my $anadir = '.';

my $canonout = 0;
my $canondir = '.';

my $warningcnt = 0;
my $errorcnt = 0;

my $verbose_hops = 1;

my $idprefix = '';

my $merge_dup = 0;  # merge if lat,lon,name almost identical: nl
my $dup_limit = 0.2; # todo in feedcfg
my $showmerge = 1;

my $merge_dup_parent = 0;  # merge if lat,lon,name identical: nl
my $infer_parent = 0;   # infer parent when seemingly missing : seq
my $infer_limit = 0.1;
my $showinfer = 0;

my $dateshift = 0;

my $allreserved = 0;

my $geoacc = 6; # decimals for lat/lon in canon output

my $omit_unconnect = 1;
my $omit_noparent = 1;

my $watchfile = 'watches.cfg';
my $gtfscfgfile = 'gtfsfeed.cfg';

my %stops2watch = ('0','noname');
my %rsids2watch;

my $logname = 'gtfstool.log';
my $logfd;

my $canonmagic = 'x4BAb35S';
my $iscanonin = 0;

my ($indir,$outdir);

# stop at compile-time warnings
local $SIG{__WARN__} = sub { print "$_[0]\n"; exit 1; };

if (-t STDOUT) {
  for (my $bck = 8; $bck >= 0; $bck--) {
    rename($logname . '.' . $bck,$logname . '.' . ($bck+1)) if (-f $logname . '.' . $bck);
  }
  rename($logname,$logname . '.0') if -f $logname;
  open($logfd,'>:encoding(UTF-8)',$logname) or print("cannot create $logname:$!");
}

# unbuffered i/o
my $orgfh = select STDOUT; $| = 1;
  select STDERR; $| = 1;
  if (defined $logfd) { select $logfd; $| = 1; }
select $orgfh;

binmode(STDOUT,':utf8');

sub basemsg($) {
  my ($m) = @_;

  print("$m\n");
  print($logfd "$m\n") if defined $logfd;
  return 1;
}

my $clron = sprintf('%c[1;36m',27); # 32 green 36 cyan
my $clrof = sprintf('%c[0m',27);
my $inprogress = 0;

sub msg($) {
  my ($m) = @_;

  my $t = time2yyyymmdd(time(),1,'sec');
  my $tt = substr($t,11);  # only from hh in yyyy-mm-dd hh:mm:ss

  my ($package,$filename,$line,$sub,$hasargs) = caller(1);
  my $fln = sprintf("%4u",$line);
  print "\n" if $inprogress;
  print("$clron$tt $fln $clrof$m\n");
  print($logfd "$t $fln $m\n") if defined $logfd;
  $inprogress = 0;
  return 1;
}

sub info($) { return msg($_[0]); }

sub progress($$$) {
  my ($fmt,$a,$b) = @_;

  my $t = time2yyyymmdd(time(),1,'sec');
  my $tt = substr($t,11);

  my ($package,$filename,$line) = caller(1);
  my $fln = sprintf("%4u",$line);

  my $perc = ($a * 100) / $b;
  if ($a < $b) {
    print "\n" unless $inprogress;
    $inprogress = 1;
    printf("\r%s%s %4u %s $fmt %.0f %%\r",$clron,$tt,$line,$clrof,$a,$b,$perc);
  } else {
    printf("\r%s%s %4u %s $fmt done\n",$clron,$tt,$line,$clrof,$a,$b);
    $inprogress = 0;
  }
}

sub dinfo($) {
  my ($package,$filename,$line,$sub,$hasargs) = caller(0);
  return msg($_[0] . " fn $sub ln $line");
}

my (%warnings,%warncnts);
sub warning($) {
  my ($package,$filename,$line,$sub,$hasargs) = caller(0);
#  msg("warning: " . $_[0] . "  at fn $sub.$line");
  msg("warning: " . $_[0]);
  $warnings{$line} = $_[0] unless exists $warnings{$line};
  $warncnts{$line}++;
  $warningcnt++;
  return 1;
}

sub error($) {
  my ($package,$filename,$line,$sub) = caller(0);
  ($package,$filename,$line,$sub) = caller(1) if $sub eq 'main::error';
  msg("error: $_[0] in $sub");
  $errorcnt++;
  return 0;
}

sub error_exit($) {
  my ($package,$filename,$line,$sub) = caller(0);
  ($package,$filename,$line,$sub) = caller(1) if $sub eq 'main::error';

  msg("error: $_[0] in $sub");
  $errorcnt++;
  exit 1;
}

sub vrb($) {
  msg($_[0]) if $verbose;
  return 1;
}
sub vrb0($) { vrb($_[0]); }

sub infovrb($$) {
  info($_[1]) if $_[0];
  vrb($_[1]);
}

sub max($$) {
  my ($a,$b) = @_;
  return ($a > $b ? $a : $b);
}
sub min($$) {
  my ($a,$b) = @_;
  return ($a < $b ? $a : $b);
}

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\r\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub time2yyyymmdd($$$) {
  my ($nixsec,$local,$res) = @_;

  my ($fmt,$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);

  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = ($local ? localtime($nixsec) : gmtime($nixsec));
  return sprintf('%04u-%02u-%02u %02u:%02u:%02u',($year + 1900,$mon + 1,$mday,$hour,$min,$sec)) if $res eq 'sec';
  return sprintf('%04u-%02u-%02u %02u:%02u',($year + 1900,$mon + 1,$mday,$hour,$min)) if $res eq 'min';
  return sprintf('%04u-%02u-%02u %02u:%02u',($year + 1900,$mon + 1,$mday));
}

sub usage()
{
  my $m = "usage: gtfstool [options] [cmd]\n\n";
  $m .= "options:\n";
  $m .= "-v -verbose        verbose mode\n";
  $m .= "-n -dryrun         dryrun mode\n";
  $m .= "-h -help           show help and quit\n";
  $m .= "-a -analysis       enable analysis output\n";
  $m .= "-c -canonical      enable canonical output\n";
  $m .= "-r -reserve        mark all routes as requiring reservation\n";
  $m .= "-t -test           test only, no output\n";
  $m .= "-V -version        show version and quit\n";
  $m .= "-L -license        show license and quit\n\n";
  $m .= "commands:\n\n";

  $m .= "import <outdir> [indir]  import gtfs into tripover\n";
  $m .= "merge  <outdir> [indirs] merge canonical gtfs feeds";
  basemsg($m);
}

# these are written as options to ext output

my $hisid = 0;
my $nosid = 0xffff;

my $hirstopid = 0;

my $dowstart = 'monday';

my $fmt_prvsid = 1;
my $fmt_diftid = 2;
my $fmt_difdep = 4;
my $fmt_difarr = 8;
my $fmt_prvdep = 16;
my $fmt_prvarr = 32;

my $opt_childstop = 1;
my $opt_parentstop = 2;
my $opt_inferred = 4;

# store field results here

my $defutcofs12;

# defaults
my $agencyname;
my $agencyid;
my $feedpublisher = '';

my @agencies;
my %agencytz;
my %agencyutcofs;

my %stopids;    # ext to int
my %stop_ids;   # int to ext

my %stops2ignore;

my %stopnames;

my %stops;

my @stopdeps;
my @stoparrs;

my %parents;
my %parentids;
my %parent_ids;
my %parentbyid;
my $parentcnt = 0;
my $parentdupcnt = 0;
my %stop2parent;

my %uniparents;
my %parentdups;

my @calendar;
my @caldates;

my %serviceids;
my %noserviceids;
my %servicedow;
my %servicet0;
my %servicet1;
my %serviceadd;
my %servicesub;
my $sidcnt = 0;
my %sidrefs;
my %sids2ignore;
my %sidutcofs;

my %tripids;
my %trip_ids;
my %tripseq;
my %tripseq1;
my %trippseq;
my %tripref;
my $hitripid = 0;
my @uniqids;

my %triproutes;
my %tripsids;

my @trips;

my @stop_times;

my %tripservice;

my @hops;

my @routes;
my %routeids;
my %norouteids;
my %routebyids;
my %routeagency;
my %rtypes;
my %agency_ids;
my %routeres;

my $hirrid = 0;

# my %uniqhops;

my $sumtimes = 0;

my @trip_ids;
my @dep_times;
my @arr_times;

my $stopcnt = 0;
my $ttcnt = 0;
my $hopcnt = 0;
my $tripcnt = 0;
my $routecnt = 0;
my $noroutecnt = 0;

# overall date range : coded decimal yyyymmdd
my $mint0 = 20200101;
my $maxt1 = 0;

my $nondigits = qr'[^0-9]';

my $unquoter = qr'/""/"/g';

sub inarray($@) {
  my ($a,@arr) = @_;

  foreach my $b (@arr) { return 1 if $a eq $b; }
  return 0;
}

sub showvers($)
{
  my ($full) = @_;

  basemsg("Tripover gtfs tool version $version_maj.$version_min");
  basemsg("last changed $lastchanged") if $full; 
  basemsg("$copyright\n");
}

sub rdwatches()
{
  my ($fh,$line,$linno);
  my ($var,$val,$fmt);

  info("inspecting $watchfile");
  return unless -r $watchfile and -s $watchfile;

  open($fh,"<",$watchfile) or return warning("cannot open $watchfile: $!");

  my $varxval = qr?^([a-z_.]+)\s+([x,\*])([0-9a-f]*)?;

  $linno = 0;
  while($line = readline $fh) {
    $linno++;
    next if index($line,'#') == 0;
    next if length $line < 2;
    ($var,$fmt,$val) = ($line =~ $varxval);
    next unless defined $var and defined $fmt;

    info("$var $fmt $val");

    if ($fmt eq 'x' and defined $val) { $val = hex($val); }
    elsif ($fmt eq '*') { $val = '*'; }
    elsif ($fmt eq  ',') { }

    printf("%s %x.%u\n",$var,$val,$val) unless $fmt eq '*';
    $rsids2watch{$val} = 1 if $var eq 'rsid';
  }
}

# one file with a config section per agency.
# once agency is known, load and apply the relevant section
#
# prefix
# ignore-stop
# ignore-service
# infer-parent
# merge-x
#
sub rdgtfscfg($$)
{
  my ($name1,$name2) = @_;

  my ($fh,$line,$linno);
  my ($var,$val,$varlen,$sec,$arg,$args,$rest);

  info("inspecting $gtfscfgfile for '$name1' or '$name2'");
  return unless -r $gtfscfgfile and -s $gtfscfgfile;

  open($fh,"<",$gtfscfgfile) or return warning("cannot open $gtfscfgfile: $!");

  my $secpat = qr?^=([-_.A-Za-z\s0-9]+)=?;
  my $varpat = qr?^([-a-z_.]+)?;
  my $arg1pat = qr?^\s+([-_./0-9a-zA-Z]+)(.*)?;

  my $state = 0;

  $linno = 0;
  while($line = readline $fh) {
    $linno++;
    $line = trimws($line);
    next if index($line,'#') == 0;
    next if length $line < 2;

    if ($state == 0) {
      ($sec) = ($line =~ $secpat);
      next unless defined $sec and ($sec eq $name1 or $sec eq $name2);
      info("config section for $sec starts at line $linno");
      $state = 1;
    } elsif ($state == 1) {
      last if (substr($line,0,1) eq '='); # next section

      ($var) = ($line =~ $varpat);
      next unless defined $var and length($var) > 0;
      $varlen = length($var);
      $args = substr($line,$varlen);
      $args = '' unless defined $args;
      if ($var eq 'description' and length $args) {
        info("$args");
      } elsif ($var eq 'prefix') {
        ($arg,$rest) = ($args =~ $arg1pat);
        next unless defined $arg and length($arg) > 0;
        info("ID prefix '$arg'");
        $idprefix = $arg;
      } elsif ($var eq 'ignore-stop') {
        ($arg,$rest) = ($args =~ $arg1pat);
        next unless defined $arg and length($arg) > 0;
        $rest = '(no description)' unless defined $rest;
        info("ignore stop $arg $rest");
        $stops2ignore{$arg} = "$gtfscfgfile:$linno $rest";
      } elsif ($var eq 'ignore-service') {
        ($arg,$rest) = ($args =~ $arg1pat);
        next unless defined $arg and length($arg) > 0;
        $rest = '(no description)' unless defined $rest;
        info("ignore service $arg $rest");
        $sids2ignore{$arg} = "$gtfscfgfile:$linno $rest";
      } elsif ($var eq 'shift-date') {
        ($arg,$rest) = ($args =~ $arg1pat);
        next unless defined $arg and length($arg) > 0;
        $rest = '(no description)' unless defined $rest;
        info("shift date by $arg $rest");
        $dateshift = $arg;
      } elsif ($var eq 'merge-duplicate-stations') {
        info("option $var disabled");
#        $merge_dup_parent = 1;
#        info("merging duplicate stations if name,lat,lon equal $args");
      } elsif ($var eq 'infer-common-station') {
        info("option $var disabled");
#        $infer_parent = 1;
#        info("infer common parent station if name,lat,lon almost equal $args");
      } elsif ($var eq 'no-infer-common-station') {
        $infer_parent = 0;
        info("not infer common parent station if name,lat,lon almost equal $args");
      } else { info("line $linno: skip unknown var '$var'"); }
    }
  }
  info("no section for '$name1' or '$name2' in $gtfscfgfile") if $state == 0;

  $idprefix = $outdir . '/' unless length $idprefix;
  info("ID prefix for merges: '$idprefix'");
  info('');
}

my (%tzofs,%tzdstofs);

sub init()
{
  my $tzname = 'tzinfo.txt';
  my $tzfile;
  my $col = 0;
  my ($line,$tzstr,$tz,$ofs,$dstofs,$a,$b,$c,$alt);
  my @tzs;
  my $tzcol = 3;
  my $ofscol = 5;
  my $dstofscol = 6;

  rdwatches() if $anaout;

  # read timezone info from wikipedia export, in turn from iana TZ database 
  open($tzfile,'<:encoding(UTF-8)',$tzname) or return warning("cannot open $tzname:$!");
  my @lines = readline($tzfile);
  close($tzfile);
  for $line (@lines) {
    next unless length($line);
    next if index($line,'#') == 0;
#    info($line);

    @tzs = ();
    if (index($line,'|-') == 0) {
      $col = 0;
    } elsif (index($line,'|') == 0) {
      $line = substr($line,1);
      $col++;
    }

    if ($col == $tzcol) {
      $a = index($line,'[[');
      $b = index($line,']]');
      $tzstr = substr($line,$a+2,$b-3);
    } elsif ($col == $ofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      $ofs = substr($line,$a+5,$c-6);
      if (substr($ofs,0,1) eq "\x{2212}") { $ofs = '-' . substr($ofs,1); }
    } elsif ($col == $dstofscol) {
      $a = index($line,'[[');
      $c = index($line,'|');
      if ($a < 0) { vrb("no dstofs for $tz abc $line"); $dstofs = $ofs; }
      else { $dstofs = substr($line,$a+5,$c-6); }
    } elsif ($col > $dstofscol) {
      while (length($tzstr)) {
        $alt = index($tzstr,'|');
        if ($alt < 0) {
          push @tzs,$tzstr;
          $tzstr = '';
        } else {
          $tz = substr($tzstr,0,$alt);
#          vrb("tz '$tz' ofs '$ofs'");
          push @tzs,$tz;
          $tzstr = substr($tzstr,$alt + 1);
#          vrb("tzstr '$tzstr'");
        }
      }
      foreach $tz (@tzs) {
        $tzofs{$tz} = $ofs;
        $tzdstofs{$tz} = $dstofs;
#        vrb("tz '$tz' ofs '$ofs'");
      }
      $col = 0;
    }
  }

  $tzofs{'ACST'} = '+09:30';
  $tzofs{'ACT'} = '-05:00';
  $tzofs{'ACWST'} = '+08:45';
  $tzofs{'AEST'} = '+10:00';

  $tzofs{'AKST'} = '-09:00';
  $tzofs{'AST'} = '+03:00';
  $tzofs{'AWST'} = '+08:00';
  $tzofs{'BRT'} = '-03:00';
  $tzofs{'BST'} = '+01:00';
  $tzofs{'CDT'} = '-05:00';
  $tzofs{'CEST'} = '+02:00';
  $tzofs{'CET'} = '+01:00';
  $tzofs{'CST'} = '-06:00';
  $tzofs{'EDT'} = '-04:00';
  $tzofs{'EEST'} = '+03:00';
  $tzofs{'EET'} = '+02:00';
  $tzofs{'EST'} = '-05:00';
  $tzofs{'GMT'} = '+00:00';
  $tzofs{'HKT'} = '+08:00';
  $tzofs{'I'} = '+09:00';
  $tzofs{'IST'} = '+05:30';
  $tzofs{'JST'} = '+09:00';
  $tzofs{'KST'} = '+09:00';
  $tzofs{'MDT'} = '-06:00';
  $tzofs{'MSK'} = '+03:00';
  $tzofs{'MST'} = '-07:00';
  $tzofs{'NZST'} = '+12:00';
  $tzofs{'PDT'} = '-07:00';
  $tzofs{'PKT'} = '+05:00';
  $tzofs{'PST'} = '-08:00';
  $tzofs{'SAST'} = '+02:00';
  $tzofs{'SGT'} = '+08:00';
  $tzofs{'UTC'} = '+08:00';
  $tzofs{'WET'} = '+00:00';
  $tzofs{'WIB'} = '+07:00';
  $tzofs{'WIT'} = '+09:00';
  $tzofs{'WITA'} = '+08:00';

  return 1;
}

sub tz2ofs($)
{
  my ($str) = @_;
  my ($hh,$mm,$hhmm);

  unless (exists($tzofs{$str})) { warning("no timezone info for $str"); return (0,0); }

  $hhmm = $tzofs{$str};
  $a = index($hhmm,':');
  $hh = substr($hhmm,0,$a);
  $mm = substr($hhmm,$a+1);
  vrb("utc offset hh $hh mm $mm");
  return ($hh,$mm);
}

sub opengtfs($$$)
{
  my ($name,$cvsmode,$utf8) = @_;
  my ($fh,$mode,$headline,$c);

  return error("required $name not present") unless -f $name;
  return error("required $name is empty") unless -s $name;

  if ($cvsmode) {
    open($fh,'<:encoding(UTF-8)',$name) or return error("cannot open $name:$!");
    $headline = readline($fh);
    return error("$name is empty") unless defined $headline and length($headline);
    $headline =~ s/^\x{FEFF}//;  # remove BOM
    $headline =~ s/[\r\n]+$//;
    return (1,$fh,$headline);
  } else {
    if ($utf8) { $mode = '<:encoding(UTF-8)'; }
    else { $mode = '<'; }
    open($fh,$mode,$name) or return error("cannot open $name:$!");
    $c = '#';
    while ($c eq '#' or $c eq "\n") {
      $headline = readline($fh);
      return error("$name is empty") unless defined $headline and length($headline);
      $c = substr($headline,0,1);
    }
    chop $headline;
    return (1,$fh,$headline);
  }
}

sub readagency($)
{
  my ($dir) = @_;

  my ($rv,$agency,$agencyfname);
  my ($col,$colname,$line,$headline);
  my ($col_id,$col_name,$col_tz,$col_url);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $agencyfname = $dir . '/' . 'agency.tab';

  return error("required $agencyfname not present") unless -f $agencyfname;
  return error("required $agencyfname is empty") unless -s $agencyfname;

  info("reading $agencyfname");
  return info("dryrun") if $dryrun;

  ($rv,$agency,$headline) = opengtfs($agencyfname,0,1);
  return 0 unless $rv;

  my $canoncols = "agency_id\tagency_name\tagency_timezone\tagency_url";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($agency);
  close($agency);
  error_exit("$agencyfname is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  my ($id,$name,$url,$tzstr);
  my ($utchh,$utcmm,$utcofs12);

  info("$linecnt lines") if $linecnt > 1;

  $linno = 0;
  foreach $line (@lines) {
    chop $line;
    $linno++;
    next if $line eq $headline;  # support catenated files if same col layout

    ($id,$name,$tzstr,$url) = split "\t",$line;

    $id = 'agency_id-' . $linno unless defined $id and length $id;

    # take first one to identify overall feed if feed_info missing
    $agencyname = $name unless defined $agencyname;
    $agencyid = $id unless defined $agencyid;

    if (length($tzstr)) {
      ($utchh,$utcmm) = tz2ofs($tzstr);
      vrb("$utchh $utcmm");
    }

    $agencytz{$id} = $tzstr;
    ($utchh,$utcmm) = (0,0) unless defined $utchh;
    $utcofs12 = int(($utchh + 12) * 100) + $utcmm;
    info("agency $id utc$utchh:$utcmm");
    $agencyutcofs{$id} = $utcofs12;
    push @agencies,join("\t",$id,$name,$url,$tzstr);
  }

  ($utchh,$utcmm) = (0,0) unless defined $utchh;
  $defutcofs12 = int(($utchh + 12) * 100) + $utcmm;

  $agencyid = $agencyname unless defined $agencyid;
  info("Agency: '$agencyname'") if $linecnt == 1;
  return 1;
}

sub readfeedinfo($)
{
  my ($dir) = @_;

  my ($rv,$file,$fname,$headline);
  my ($col,$colname,$line);
  my ($col_id,$col_name,$col_tz);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $fname = $dir . '/' . 'feed_info.txt';

  return info("optional $fname not present") unless -f $fname;
  return info("optional $fname is empty") unless -s $fname;

  info("reading $fname");
  return info("dryrun") if $dryrun;

  ($rv,$file,$headline) = opengtfs($fname,1,1);
  return 0 unless $rv;

  my @colnames = split(',',$headline);
  my @cols;
  my $colid = 0;

  foreach $colname (@colnames) {
    $col_name = $colid if ($colname eq 'feed_publisher_name');
    $col_id = $colid if ($colname eq 'feed_id');
    $colid++;
  }

  my @lines = readline($file);
  close($file);
  return warning ("$fname is empty") unless (@lines > 0);

  my $linecnt = scalar(@lines);

  info("$fname has $linecnt entries, reading first entry only") if $linecnt > 1;

  my $id = '';
  my $name = '';

  $line = $lines[0];

  @cols = split ',',trimws($line);

  $id = $cols[$col_id] if defined $col_id;
  $name = $cols[$col_name] if defined $col_name;

  $feedpublisher = $name;

  return 1;
}

my $latscale = 1000000;  # 10 cm
my $lonscale = 1000000;  # 20 cm
my $pi = 3.141592655;

# todo autoscale on bbox and have tripover read bbox+scale
sub str2lat($$)
{
  my ($lat,$linno) = @_;

  my ($ilat);

  $ilat = ($lat + 90) * $latscale;
  return int($ilat);
}

sub str2lon($$)
{
  my ($lon,$linno) = @_;

  my ($ilon);

  $ilon = ($lon + 180) * $lonscale;
  return int($ilon);
}

sub ilat2lat($)
{
  my ($ilat) = @_;

  my $lat = ($ilat / $latscale) - 90;
  return sprintf("%.*f",$geoacc,$lat);
}

sub ilon2lon($)
{
  my ($ilon) = @_;

  my $lon = ($ilon / $lonscale) - 180;
  return sprintf("%.*f",$geoacc,$lon);
}

my $geolow = $pi * 2.0e-5;  # ~500m
my $geolimit = $pi * 1.0e-7;
my $mean_earth_radius = 6371.0;
my $approx_surface = sqrt($mean_earth_radius * $mean_earth_radius + $mean_earth_radius * $mean_earth_radius);

sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

# Adapted from Tripover:math.c which in turn is adapted from Wikipedia article
sub geodist($$$$)
{
  my ($slat,$slon,$lat,$lon) = @_;

  my ($dist,$dlat,$dlon);

  my $phi1 = ($slat * $pi) / 180;
  my $lam1 = ($slon * $pi) / 180;
  my $phi2 = ($lat * $pi) / 180;
  my $lam2 = ($lon * $pi) / 180;

  my $dlam = $lam2 - $lam1;
  my $dphi = $phi2 - $phi1;

  if (abs($dlam) < $geolow and abs($dphi) < $geolow) { # trivial case: assume flat
    if (abs($dlam) < $geolimit and abs($dphi) < $geolimit) { # flush to zero
      return 0;
    }
    $dlat = $dlam * $approx_surface * 2 / $pi;
    $dlon = ($dphi * $approx_surface * 2) / $pi;
    $dist = sqrt( ($dlat * $dlat) + ($dlon * $dlon));
#    info(sprintf("geodist trivial %.5f,%.5f %.5f,%.5f  dist %.3f",$slat,$slon,$lat,$lon,$dist));
    return $dist;
  }
# info("geodist $dlon $dlat");

  my ($d,$dsig);

  $d = sin($phi1) * sin($phi2) + cos($phi1) * cos($phi2) * cos($dlam);
  if ($d >= 1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }
  elsif ($d <= -1.0) { error("geodist d $d for $phi1 $phi2 $lam1 $lam2"); return 0; }

  $dsig = acos($d);

  $dist = $dsig * $mean_earth_radius;
#  info(sprintf("geodist %.5f,%.5f %.5f,%.5f  dist %.3f",$slat,$slon,$lat,$lon,$dist));
  return $dist;
}

my (%rstops,%rstopids,%rstopbyid,%stopmerge,%rstopbyname);

sub readstops($)
{
  my ($dir) = @_;

  my ($stopfile,$stopsname,$anafile,$rv,$headline);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req,$val);
  my ($id,$stopid,$stopid2,$rstopid,$xname);
  my ($code,$name,$sname,$desc,$lat,$lon,$zone_id,$url,$loctype,$parent,$platform,$opt);
  my ($name2,$lat2,$lon2,$ilat2,$ilon2,$parent2,$loctype2,$code2,$desc2);
  my ($uniparent,$parentid,$parent1,$rparent,$isparent,$hasparent,$newparent,$newparentid);
  my ($ilat,$ilon);
  my ($simlst,$simstr,$simstop,$stopstr);
  my ($slat,$slon,$dist,$diststr,$nearby);
  my (%simlats,%simlons);
  my ($ilatcell,$iloncell,$acell,$ocell,$candidate,$candidates);
  my %sims;
  my (@simocells,@simacells);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $stopsname = $dir . '/' . 'stops.tab';

  info("reading $stopsname");
  return info("dryrun") if $dryrun;

  ($rv,$stopfile,$headline) = opengtfs($stopsname,0,1);
  return 0 unless $rv;

  my $canoncols = "stop_id\tstop_code\tlocation_type\tparent_station\tstop_name\tstop_lat\tstop_lon\tstop_desc";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($stopfile);
  close($stopfile);
  error_exit("$stopsname is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  my $filtercnt = 0;
  my $infercnt = 0;
  my $instopcnt = 0;
  my $childstopcnt = 0;
  my $mergedupcnt = 0;
  my $mergedupcnt2 = 0;
  my $mergedupcnt3 = 0;

  $linno = 1;
  foreach $line (@lines) {
    $c = chop $line;
    $linno++;
    next if $line eq $headline;  # support catenated files if same col layout

    ($id,$code,$loctype,$parent,$name,$lat,$lon,$desc) = split "\t",$line;
    $desc = '' unless defined $desc;

    $instopcnt++;

    if (exists($rstopids{$id})) {
      warning("$linno: stop id $id already defined on line $rstopids{$id}");
      $filtercnt++;
      next;
    } elsif (defined $stops2ignore{$id}) {
      info("$linno: filter stop id $id : $stops2ignore{$id}");
      $filtercnt++;
      next;
    }
    # gtfs ID may be integer or string. must be unique in set
    # tripover needs an integer : use line number as derived id
    $rstopid = $linno;
    $hirstopid = max($hirstopid,$rstopid);
    $rstopids{$id} = $rstopid;
    $rstopbyid{$rstopid} = $id;

    if (length($lon) < 1) { warning("$id has empty lon"); $lon = 0; }
    if (length($lat) < 1) { warning("$id has empty lat"); $lat = 0; }
    $ilat = str2lat($lat,$linno);
    $ilon = str2lon($lon,$linno);

    $isparent = 0;
    if (length($loctype)) {
      if ($loctype eq '1') { $isparent = 1; }
      elsif ($loctype eq '0') { $isparent = 0; }
      else {
        warning("$linno: stop $name has unknown location type $loctype");
        $loctype = '0';
      }
    }

    $stopmerge{$rstopid} = $rstopid;

    # merge if name identical and colocated : meant for gtfs merges
    if ($merge_dup) {
      $xname = $loctype . '_' . $name;
      if (exists $rstopbyname{$xname}) {
        $stopid2 = $rstopbyname{$xname};
        ($name2,$lat2,$lon2,$ilat2,$ilon2,$parent2,$loctype2,$code2,$desc2) = split("\t",$rstops{$stopid2});
        if ($ilat == $ilat2 and $ilon == $ilon2) {
          infovrb($showmerge,"merge $name id $rstopid to $stopid2 on distance 0");
          $stopmerge{$rstopid} = $stopid2;
          $mergedupcnt++;
        } else {
          $dist = geodist($lat,$lon,$lat2,$lon2);
          $diststr = sprintf ("distance %.2f",$dist);
          if ($dist < $dup_limit or ($xname eq $loctype2 . '_' . $name2 and $dist < $dup_limit * 5) ) {
            if ($isparent && $loctype2 == 1) {
              infovrb($showmerge > 1,"merge parents $name + $name2 id $rstopid to $stopid2 on $diststr");
              $stopmerge{$rstopid} = $stopid2;
              $mergedupcnt2++;
            } elsif ($isparent == 0 and $loctype2 == 0) {
              if ( (length($parent) == 0 and length($parent2) == 0) or ($parent eq $parent2) ) { # same parent or both plain
                infovrb($showmerge > 1,"merge $name + $name2 $rstopid to $stopid2 on $diststr");
                $stopmerge{$rstopid} = $stopid2;
                $mergedupcnt2++;
              } else {
                infovrb($showmerge,"not merge $name + $name2 at $diststr different parents");
              }
            } else {
              infovrb($showmerge,"not merge $name + $name2 at $diststr different types");
#              $stopmerge{stopid2} = $rstopid;
            }
          } else {
            infovrb($showmerge,"not merge $name id $rstopid to $stopid2 on $diststr");
            $mergedupcnt3++;
          }
        }
      } else { $rstopbyname{$xname} = $rstopid; }
    }

    $rstops{$rstopid} = join("\t",$name,$lat,$lon,$ilat,$ilon,$parent,$loctype,$code,$desc);

  } # each line / stop in pass 1

  info("merged $mergedupcnt + $mergedupcnt2 stops on duplicate name and colocated") if $mergedupcnt or $mergedupcnt2;
  info("not merged $mergedupcnt3 stops on duplicate name and colocated > $dup_limit") if $mergedupcnt3;

  # rescan stops, applying duplicate merging
  my %rstops1;

  foreach $rstopid (sort { $a <=> $b } keys %rstops) { # parents
    $id = $rstopbyid{$rstopid};

    $stopstr = $rstops{$rstopid};
    ($name,$lat,$lon,$ilat,$ilon,$rparent,$loctype,$code,$desc) = split("\t",$stopstr);

    $hasparent = (length($rparent) > 0);
    if ($hasparent) {
      unless (exists($rstopids{$rparent})) {
        if ($omit_noparent) {
          info("omitting member stop id $id $name on no parent $rparent line $rstopid");
        } else {
          warning("$id $name has nonexistent parent $rparent on line $rstopid");
        }
        next;
      }
      $parentid = $stopmerge{$rstopids{$rparent}};
      $parent = $rstopbyid{$parentid};
      if ($parent ne $rparent) {
        infovrb($showmerge,"reparent $rparent to $parent for $id");
        $rstops1{$rstopid} = join("\t",$name,$lat,$lon,$ilat,$ilon,$parent,$loctype,$code,$desc);
      } else { $rstops1{$rstopid} = $stopstr; }
    } else { $rstops1{$rstopid} = $stopstr; }
  }

  foreach $rstopid (sort { $a <=> $b } keys %rstops1) {  # stops
    $id = $rstopbyid{$rstopid};
    $stopstr = $rstops1{$rstopid};
    ($name,$lat,$lon,$ilat,$ilon,$parent,$loctype,$code,$desc) = split("\t",$stopstr);

    $hasparent = (length($parent) > 0);
    if ($hasparent) {
      next unless exists($rstopids{$parent});
    }

    $stopid = $stopmerge{$rstopid};
    $id = $rstopbyid{$stopid};
    if ($stopid != $rstopid) {
      infovrb($showmerge,"merge $name id $id $rstopid to $stopid");
      next;
    }

    $stopids{$id} = $stopid;
    $stop_ids{$stopid} = $id;
    $stopdeps[$stopid] = 0;
    $stoparrs[$stopid] = 0;

    $stopnames{$stopid} = $name;

    $isparent = 0;
    if ($loctype eq '1') { $isparent = 1; }

    $hasparent = (length($parent) > 0);
    if ($hasparent and $isparent) {
      warning("$linno: parent stop $name has parent $parent");
      $hasparent = 0;
    }

    $simlats{$stopid} = $lat;
    $simlons{$stopid} = $lon;

    # infer common parent: for missing parent stations
    if ($infer_parent and not $isparent and not $hasparent and length($name) > 3) {

      $ilatcell = ($ilat >> 13) + 1; # ~ 300m
      $iloncell = ($ilon >> 13) + 1;

      $candidates = '';
      for ($acell = $ilatcell - 1; $acell < $ilatcell + 2; $acell++) {
        $candidates .= $simacells[$acell]  . '_' if length $simacells[$acell];
      }
      for ($ocell = $iloncell - 1; $ocell < $iloncell + 2; $ocell++) {
        $candidates .= $simocells[$ocell] . '_' if length $simocells[$ocell];
      }

      foreach $candidate (split('_',$candidates)) {
        next unless length $candidate and $candidate ne '_' and $candidate != $stopid;
        next unless exists $simlats{$candidate} and exists $simlons{$candidate};
        next if exists $parent_ids{$candidate} or exists $parentbyid{$candidate};

        $slat = $simlats{$candidate};
        $slon = $simlons{$candidate};
        $sname = $stopnames{$candidate};
        $dist = geodist($slat,$slon,$lat,$lon);
        $diststr = sprintf('%.2f',$dist);
        if ($name eq $sname and $dist < $infer_limit * 8) {
          infovrb($showinfer,"infer common parent for '$name' within $diststr of samenamed");
          $sims{$candidate} .= $stopid . '_';
        } elsif (substr($name,0,-2) eq substr($sname,0,-2) and $dist < $infer_limit * 4) {
          infovrb($showinfer,"infer common parent for '$name' within $diststr of similar-named '$sname'");
          $sims{$candidate} .= $stopid . '_';
        } elsif ($dist < $infer_limit) {
           infovrb($showinfer,"infer common parent for '$name' within $diststr of '$sname'");
          $sims{$candidate} .= $stopid . '_';
        } elsif ($name eq $sname) {
          info("not infer common parent for '$name' within $diststr of samenamed");
        }
      }

      $simacells[$ilatcell] .= $stopid . '_';
      $simocells[$iloncell] .= $stopid . '_';
    }

    # use external id, as parent ids can refer forward
    if ($merge_dup_parent) {
      if ($isparent) {
        error_exit("duplicate parent id $stopid, first defined at line $parentids{$id}") if exists $parentids{$id};
        $uniparent = substr($name,0,3) . int($ilat >> 4) . int($ilon >> 4);
        if (exists $uniparents{$uniparent}) {
          $parent = $uniparents{$uniparent};
          $parentdups{$id} = $parent;
          info("merge duplicate id $parent for $id $name");
          $parentdupcnt++;
          next;
        } else { $uniparents{$uniparent} = $id; }
      } elsif ($hasparent) {
        if (exists $parentdups{$parent}) {
          $parent1 = $parentdups{$parent};
          info("dup parent $parent to $parent1 for stop $id");
          $parent = $parent1;
        }
      }
    }

    if ($isparent) {
      $parentids{$id} = $stopid;
      $parent_ids{$stopid} = $id;
      $parentcnt++;
      $opt = $opt_parentstop;
    } elsif ($hasparent) {  # refers to id above
      $opt = $opt_childstop;
      $parents{$parent} .= $stopid . ' ';
      $parentbyid{$stopid} = $parent;
    } else {
      $opt = 0;
    }

    error_exit("no stop code for $rstopid") unless defined $code;
    error_exit("no id for $rstopid") unless defined $id;
    error_exit("no parent for $rstopid") unless defined $parent;
    error_exit("duplicate stop $stopid for $rstopid") if exists $stops{$stopid};

    $stops{$stopid} = join("\t",$name,$ilat,$ilon,$code,$desc,$opt);
  }

  my (@sibstops,$stoplst);

  while (($parent,$parent1) = each %parentdups) {
    next unless exists $parents{$parent};
    $stoplst = $parents{$parent};
    $parents{$parent} = '';
    $parents{$parent1} .= $stoplst;
    @sibstops = split(' ',trimws($stoplst));
    for $stopid (@sibstops) {
      $parentbyid{$stopid} = $parent1;
    }
  }

  my ($simname,$simdiff,$candidate2);
  my (@sims1);
  my %simdups;

  $stopcnt = scalar(keys %stops);

  $infercnt = 0;
  foreach $candidate (sort { $a <=> $b } keys %sims) {
    $simlst = $sims{$candidate};
    @sims1 = split('_',$simlst);
    next if @sims1 == 0;

    my @sims2;
    foreach $stopid (@sims1) {
      push @sims2,$sims{$stopid} if exists $sims{$stopid};
    }
    push @sims2,@sims1;

    my @sims3;
    push @sims3,$candidate;
    $simdups{$candidate} = $candidate;
    foreach $simlst (@sims2) {
      foreach $candidate2 (split('_',$simlst)) {
        next if exists $simdups{$candidate2};
        push @sims3,$candidate2;
        $simdups{$candidate2} = $candidate;
      }
    }
    next if @sims3 < 2;

    $infercnt++;
    $newparentid = $infercnt + $hirstopid;
    $newparent = join('_','inferred',$newparentid,@sims3);

    $parentids{$newparent} = $newparentid;
    $parent_ids{$newparentid} = $newparent;

    $stopnames{$newparentid} = $newparent;
    $stopids{$newparent} = $newparentid;
    $stop_ids{$newparentid} = $newparent;
    $stopdeps[$newparentid] = 0;
    $stoparrs[$newparentid] = 0;

    infovrb($showinfer,"inferred parent id $newparent $newparentid name $newparent");
    foreach $stopid (@sims3) {
      next unless length $stopid and $stopid ne '_';
      error_exit("no name for '$stopid'") unless exists $stopnames{$stopid};
      $name = $stopnames{$stopid};
      $lat = $simlats{$stopid};
      $lon = $simlons{$stopid};
      infovrb($showinfer,"  member id $stopid name $name lat $lat lon $lon");
      $parents{$newparent} .= $stopid . ' ';
      $parentbyid{$stopid} = $newparent;
      $stopstr = $stops{$stopid};
      ($name,$ilat,$ilon,$code,$desc,$opt) = split("\t",$stopstr);
      $stops{$stopid} = join("\t",$name,$ilat,$ilon,$code,$desc . ' infer',$opt_childstop);
    }
    $stops{$newparentid} = join("\t",$name . '-parentsta',$ilat,$ilon,$code,$desc . ' infer',$opt_parentstop);
  }
  $parentcnt += $infercnt;
  $stopcnt += $infercnt;

  foreach $stopid (keys %stops) {
    if (exists $parentbyid{$stopid}) {
      $parent = $parentbyid{$stopid};
      warning("no parent for $parent") unless exists $parentids{$parent};
      $parentid = $parentids{$parent};
      $stop2parent{$stopid} = $parentid;
      $childstopcnt++
    } else {
      $stop2parent{$stopid} = $stopid;
    }
  }

  my $mline = "$stopcnt from $instopcnt stops";
  $mline .= " $parentcnt stations" if $parentcnt;
  $mline .= " $infercnt inferred" if $infercnt;
  $mline .= " $parentdupcnt merged" if $parentdupcnt;
  $mline .= " $filtercnt filtered" if $filtercnt;
  info($mline);
  my $outstopcnt = $stopcnt - $childstopcnt;
  info("$childstopcnt station members $outstopcnt total planning stops");

  return 1;
}

my $include_tram = 1;
my $include_metro = 1;
my $include_rail = 1;
my $include_bus = 1;
my $include_ferry = 1;
my $include_cabcar = 1;
my $include_gondola = 1;
my $include_dom_air = 1;
my $include_int_air = 1;

my @modenames = ( "tram","metro","rail","bus","ferry","cable car","gondola" );

# extended types from support.google.com/transitpartners/answer/3520902
sub extrtype($)
{
  my $xr = shift;

  return 2 if $xr >= 100 and $xr < 118;
  return 3 if $xr >= 200 and $xr < 210;
  return 2 if $xr == 300 or $xr == 400 or $xr == 403 or $xr == 404;
  return 1 if $xr == 401 or $xr == 402 or $xr == 405 or $xr == 500 or $xr == 600;
  return 3 if $xr >= 700 and $xr < 717;
  return 3 if $xr == 800;
  return 2 if $xr >= 900 and $xr < 907;
  return 4 if $xr >= 1000 and $xr < 1022;
  return 1101 if $xr == 1103 or $xr == 1106 or $xr == 1107 or $xr == 1112 or $xr == 1114;
  return 1102 if $xr == 1104 or $xr == 1105 or $xr == 1108 or $xr == 1109 or $xr == 1110 or $xr == 1111 or $xr == 1113;
  return 4 if $xr == 1200;
  return $xr;
}

sub filtermode($)
{
  my ($xtype) = @_;

  my $type = extrtype($xtype);
  return 0 if $type == 0 and $include_tram == 0;
  return 0 if $type == 1 and $include_metro == 0;
  return 0 if $type == 2 and $include_rail == 0;
  return 0 if $type == 3 and $include_bus == 0;
  return 0 if $type == 4 and $include_ferry == 0;
  return 0 if $type == 5 and $include_cabcar == 0;
  return 0 if $type == 6 and $include_gondola == 0;
  return 0 if $type == 6 and $include_gondola == 0;
  return 0 if $type == 1101 and $include_int_air == 0;
  return 0 if $type == 1102 and $include_dom_air == 0;
  return 1;
}

sub readroutes($)
{
  my ($dir) = @_;

  my ($routefile,$routefname,$rv,$headline);
  my ($val,$col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$agency_id,$routeid,$utcofs12,$name,$sname,$lname,$slname,$desc,$rtype,$modename);
  my ($reserveprefix,$reserve,$magic);

  $routefname = $dir . '/' . 'routes.tab';

  info("reading $routefname");
  return info("dryrun") if $dryrun;

  ($rv,$routefile,$headline) = opengtfs($routefname,0,1);
  return 0 unless $rv;

  my $canoncols = "route_id\tagency_id\troute_type\troute_short_name\troute_long_name\troute_desc";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($routefile);
  close($routefile);
  error_exit("$routefname is empty") unless (@lines > 0);

  my $linno = 1;
  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  foreach $line (@lines) {
    $c = chop $line;

    $linno++;

    next if $line eq $headline;  # support catenated files if same col layout

    ($route_id,$agency_id,$rtype,$sname,$lname,$desc) = split "\t",$line;

    $agency_id = $agencyid unless defined $agency_id and length $agency_id;
    $desc = '' unless defined $desc;
    $sname = '' unless defined $sname;
    $slname = $sname;
    $slname .= ' ' . $lname if defined $lname;

    vrb("$linno $route_id '$slname' $rtype");
    $routeid = $linno;

    if (exists($routeids{$route_id})) {
      warning("$linno: route id $route_id already defined on line $routeids{$route_id}");
      next;
    }

    unless ($rtype =~ qr'^[0-9]+$') {
      error_exit("line $linno: route_type $rtype not numerical");
      next;
    }
    $routebyids{$routeid} = $route_id;
    $routeids{$route_id} = $routeid;
    $routeagency{$routeid} = $agency_id;
    $rtypes{$routeid} = $rtype;

    $reserve = 0;
    if (index($route_id,$canonmagic) == 0) {
      $iscanonin = 1;
      ($magic,$reserveprefix) = split '_',$route_id;
      $reserve = 1 if defined $reserveprefix and $reserveprefix eq 'r';
    } else { $reserve = $allreserved; }
    $routeres{$routeid} = $reserve;

    $agency_ids{agency_id} = $routeid;

    if (exists($agencyutcofs{$agency_id})) {
      $utcofs12 = $agencyutcofs{$agency_id};
#      info("route $route_id utcofs $utcofs12");
    } else {
      $utcofs12 = $defutcofs12;
      info("route $route_id agency $agency_id has no timezone, fallback utcofs $utcofs12");
    }

    if (filtermode($rtype)) {
      push(@routes,join("\t",$route_id,$agency_id,$reserve,$utcofs12,'',$slname,$rtype));
      $hirrid = max($hirrid,$routeid);
    } else {
      $noroutecnt++;
      if ($rtype < @modenames) { $modename = $modenames[$rtype]; }
      else { $modename = "unknown"; }
      info("filter route $route_id mode $modename = $rtype at line $linno");
      $norouteids{$route_id} = $routeid;
    }

  } # each line

  $routecnt = scalar(@routes);
  info("$routecnt routes, $noroutecnt filtered out");

  return 1;
}

sub readtrips($)
{
  my ($dir) = @_;

  my ($tripfile,$tripfname,$rv,$headline);
  my ($val,$col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$trip_id,$tripid,$service_id,$sid,$agency_id,$headsign,$utcofs);

  $tripfname = $dir . '/' . 'trips.tab';

  info("reading $tripfname");
  return info("dryrun") if $dryrun;

  ($rv,$tripfile,$headline) = opengtfs($tripfname,0,1);
  return 0 unless $rv;

  my $canoncols = "route_id\tservice_id\ttrip_id\ttrip_headsign";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($tripfile);
  close($tripfile);
  error_exit("$tripfname is empty") unless (@lines > 0);

  my $filtercnt = 0;
  my $linno = 1;
  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  foreach $line (@lines) {
    $c = chop $line;

    $linno++;
    next if $line eq $headline;  # support catenated files if same col layout

    ($route_id,$service_id,$trip_id,$headsign) = split "\t",$line;

    $headsign = '' unless defined $headsign;

    if (length($trip_id) == 0) {
      warning("$linno: missing trip id for route  $route_id");
      next;
    }
    if (exists($tripids{$trip_id})) {
      warning("$linno: trip id $trip_id previously defined on line $tripids{$trip_id}");
      next;
    }

    unless (exists($routeids{$route_id})) {
      $filtercnt++;
      warning("$linno: unknown route id $route_id");
      next;
    }

    if (exists($norouteids{$route_id})) {
      $filtercnt++;
      next;
    } elsif (exists($noserviceids{$service_id})) {
      $filtercnt++;
      next;
    }
    unless (exists($serviceids{$service_id})) {
      $filtercnt++;
      warning("$linno: unknown service id $service_id");
      next;
    }

    $tripid = $linno;
    $tripids{$trip_id} = $tripid;
    $trip_ids{$tripid} = $trip_id;
    $hitripid = $linno;

    $routeid = $routeids{$route_id};
    $triproutes{$tripid} = $routeid;

    $sid = $serviceids{$service_id};
    error_exit("undefined sid for $service_id") unless defined $sid;

    warning("no agency for route $routeid $route_id") unless exists $routeagency{$routeid};
    $agency_id = $routeagency{$routeid};
    if (exists $agencyutcofs{$agency_id}) {;
      $utcofs = $agencyutcofs{$agency_id};
    } else {
      warning("no timezone for agency $agency_id");
      $utcofs = $defutcofs12;
    }
    $sidutcofs{$sid} = $utcofs;
    push(@trips,join("\t",$route_id,$service_id,$trip_id,$headsign));
    $tripservice{$trip_id} = $service_id;

  } # each line

  $tripcnt = scalar(@trips);

  info("$tripcnt trips $filtercnt filtered highest ID $hitripid");

  return 1;
}

sub readcalendar($)
{
  my ($dir) = @_;

  my ($calfile,$calfname,$rv,$headline);
  my ($val,$col,$colid,$colname,$line,$comma,$endq,$c,$req,$fln);
  my ($service_id,$sid,$t0,$t1,$day,$dayno,$dows,$dow,$utcofs);
  my $filtercnt = 0;
  my @dow;

  $calfname = $dir . '/' . 'calendar.tab';

  info("reading $calfname");
  return info("dryrun") if $dryrun;

  return info("optional $calfname not present") unless -f $calfname;
  return info("optional $calfname is empty") unless -s $calfname;

  ($rv,$calfile,$headline) = opengtfs($calfname,0,1);
  return 0 unless $rv;

  my $canoncols = "service_id\tmonday\ttuesday\twednesday\tthursday\tfriday\tsaturday\tsunday\tstart_date\tend_date";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($calfile);
  close($calfile);
  return info("optional $calfname is empty") unless (@lines > 0);

  my $linno = 1;
  my $analines = '';

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  foreach $line (@lines) {
    $c = chop $line;

    $linno++;
    next if $line eq $headline;  # support catenated files if same col layout

    $fln = "calendar.tab:$linno";

    ($service_id,$dow[6],$dow[5],$dow[4],$dow[3],$dow[2],$dow[1],$dow[0],$t0,$t1) = split "\t",$line;

    $sid = $linno;

    if (length($service_id) == 0) {
      warning("$fln: missing service id");
      next;
    } elsif (exists($serviceids{$service_id})) {
      warning("$fln: service id $service_id previously defined on line $serviceids{$service_id}");
      $filtercnt++;
      next;
    } elsif (exists($sids2ignore{$service_id})) {
      $noserviceids{$service_id} = $sid;
      info("$fln: filter service id $service_id : $sids2ignore{$service_id}");
      $filtercnt++;
      next;
    }
    unless (length $t0) {
      warning("$fln: no start date");
      next;
    }
    unless (length $t1) {
      warning("$fln: no end date");
      $t1 = $t0;
    }

    $dows = '..............'; $dow = 0; $dayno = 0;
    for $dayno (0 .. 6) {
      $day = $dow[$dayno];
      return error("$fln: $day not 0 or 1") if $day ne '0' and $day ne '1';
      $dow <<= 1;
      if ($day) {
        $dow |= 1;
        substr($dows,(6 - $dayno) * 2,2,substr('SuSaFrThWeTuMo',$dayno * 2,2));
      }
    }

    if ($dow == 0) {
      info("$fln: empty service id $service_id");
    }

    warning("$fln: end time $t1 before start time $t0") if $t1 < $t0;

    $hisid = max($sid,$hisid);
    $serviceids{$service_id} = $sid;
    $servicedow{$sid} = $dow;
    $servicet0{$sid} = $t0;
    $servicet1{$sid} = $t1;
    $serviceadd{$sid} = [()];
    $servicesub{$sid} = [()];
    $mint0 = min($t0,$mint0);
    $maxt1 = max($t1,$maxt1);

    if (defined $rsids2watch{$sid} or defined $rsids2watch{'*'}) {
      $analines .= sprintf("rsid %02x.%02u: $t0 .. $t1 at $dows %x '$service_id'\n",$sid,$sid,$dow);
    }
    push @calendar,join("\t",$service_id,$dow[6],$dow[5],$dow[4],$dow[3],$dow[2],$dow[1],$dow[0],$t0,$t1);
  } # each line

# dummy for unknown
  $servicedow{0} = 0x7f;
  $servicet0{0} = $mint0;
  $servicet1{0} = $maxt1;

  $sidcnt = scalar(keys %serviceids);
  info("$sidcnt services $filtercnt filtered, overall period $mint0 to $maxt1");

  return 1 unless length $analines;

  my $anafile;
  open($anafile,'>',$anadir . '/rsids.log') or return 1;
  print($anafile $analines);
  close($anafile);

  return 1;
}

sub readcaldates($)
{
  my ($dir) = @_;

  my ($calfile,$calfname,$rv,$headline);
  my ($val,$col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($service_id,$sid,$date,$extype,$t0,$t1);
  my $filtercnt = 0;

  $calfname = $dir . '/' . 'calendar_dates.tab';

  info("reading $calfname");
  return info("dryrun") if $dryrun;

  return info("optional $calfname not present") unless -f $calfname;
  return info("optional $calfname is empty") unless -s $calfname;

  ($rv,$calfile,$headline) = opengtfs($calfname,0,1);
  return 0 unless $rv;

  my $canoncols = "service_id\texception_type\tdate";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($calfile);
  close($calfile);
  error_exit("$calfname is empty") unless (@lines > 0);

  my $linno = 1;
  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  foreach $line (@lines) {
    $c = chop $line;

    $linno++;
    next if $line eq $headline;  # support catenated files if same col layout

    ($service_id,$extype,$date) = split "\t",$line;

    $date += $dateshift;

    if (length($service_id) == 0) {
      warning("$linno: missing service id");
      $filtercnt++;
      next;
    } elsif ($extype ne '1' and $extype ne '2') {
      warning("$linno: exception_type $extype not 1 or 2");
      $filtercnt++;
      next;
    } elsif (exists($sids2ignore{$service_id})) {
      info("$linno: filter service id $service_id : $sids2ignore{$service_id}");
      $filtercnt++;
      next;
    } elsif (exists($serviceids{$service_id})) {  # modify existing regular sid
      $sid = $serviceids{$service_id};

      $t0 = $servicet0{$sid};
      $t1 = $servicet1{$sid};
      if ($extype == 1) {
        delete $noserviceids{$service_id};
        if ($date < $t0) {
          $servicet0{$sid} = $date;
        } elsif ($date > $t1) {
          $servicet1{$sid} = $date;
        }
        push (@{ $serviceadd{$sid} },$date);
        $mint0 = min($date,$mint0);
        $maxt1 = max($date,$maxt1);
      } elsif ($extype == 2) {
        if (exists($noserviceids{$service_id})) {  # filtered in calendar.txt
          $filtercnt++;
          next;
        }
        if ($date < $t0) {
          warning("$linno: excluding day $date below $service_id range $t0 .. $t1");
        } elsif ($date > $t1) {
          warning("$linno: excluding day $date above $service_id range $t0 .. $t1");
        } else {
          push (@{ $servicesub{$sid} },$date);
        }
      }
      push @caldates,join("\t",$service_id,$date,$extype);
    } elsif (exists($noserviceids{$service_id})) {
      vrb("$linno: service id $service_id previously filtered at calendar : $noserviceids{$service_id}");
      next;
    } else {            # not in calendar.txt
      $sid = $hisid + $linno;
      $serviceids{$service_id} = $sid;
      $servicet0{$sid} = $date;
      $servicet1{$sid} = $date;
      $servicedow{$sid} = 0;
      $serviceadd{$sid} = [($date)] if $extype == 1;
      $servicesub{$sid} = [($date)] if $extype == 2;
      $mint0 = min($date,$mint0);
      $maxt1 = max($date,$maxt1);
      push @caldates,join("\t",$service_id,$date,$extype);
    }
  } # each line

  $sidcnt = scalar(keys %serviceids);
  info("$sidcnt services $filtercnt filtered, overall period $mint0 to $maxt1");

  return 1;
}

my $hhmmpat = qr'^([0-9]+):([0-9]+):([0-9]+)';

sub toparent($)
{
  my ($stopid) = @_;

  return $stopid unless exists $parentbyid{$stopid};
  my $parent = $parentbyid{$stopid};
  return $parentids{$parent};
}

sub haveconns($)
{
  my ($stopid) = @_;

  $stopid = toparent($stopid);

  return 0 if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0);
  return 1;
}

# handle connectivity
sub do_conn()
{
  my ($stopid,$pstopid,$id,$cid,$name,$pname);
  my ($concnt,$ndep,$narr,$depcnt,$arrcnt,$parent,$parentid);
  my ($service_id,$sid);

  # show some connectivity stats
  if ($noroutecnt == 0) {
    while (($id,$stopid) = each %stopids) {
      $name = $stopnames{$stopid};
      if (exists $stops2watch{$id}) {
        info("stop $id $name $stops2watch{$id} has $stopdeps[$stopid] deps and $stoparrs[$stopid] arrs");
      }
      $pstopid = toparent($stopid);

      $ndep = $stopdeps[$pstopid]; $narr = $stoparrs[$pstopid];
      if ($ndep == 0 and $narr != 0) {
        info("stop $id $name has no departures, $narr arrivals");
      } elsif ($ndep != 0 and $narr == 0) {
        info("stop $id $name has no arrivals, $ndep departures");
      }
    }
    info('');
    while (($id,$stopid) = each %stopids) {
      $name = $stopnames{$stopid};
      $pstopid = toparent($stopid);
      $pname = $stopnames{$pstopid};
      if ($stopdeps[$pstopid] == 0 and $stoparrs[$pstopid] == 0) {
        if ($stopid == $pstopid) {
          warning("stop $id $name is unconnected");
          while (($cid,$parent) = each %parentbyid) {
            info("  member stop $cid $stop_ids{$cid} $stopnames{$cid}") if $parent eq $id;
          }
        } else { warning("stop $id $name parent $pname is unconnected"); }
      }
    }
  }

  info('');
  info("-- connection stats --");
  my ($nodacnt,$dep0cnt,$arr0cnt,$dep11cnt,$dep22cnt);
  $nodacnt = 0; $dep0cnt = 0; $arr0cnt = 0; $dep11cnt = 0; $dep22cnt = 0;

  for $stopid (values %stopids) {
    $stopid = toparent($stopid);
    $ndep = $stopdeps[$stopid]; $narr = $stoparrs[$stopid];
    $nodacnt++ if $ndep == 0 and $narr == 0;
    $dep0cnt++ if $ndep == 0 and $narr != 0;
    $arr0cnt++ if $narr == 0 and $ndep != 0;
    $dep11cnt++ if $ndep == 1 and $narr == 1;
    $dep22cnt++ if $ndep == 2 and $narr == 2;
  }
  info("stops without connection : $nodacnt") if $nodacnt;
  info("stops with no departures : $dep0cnt") if $dep0cnt;
  info("stops with no arrivals   : $arr0cnt") if $arr0cnt;
  info("stops with 1 departure and 1 arrival : $dep11cnt") if $dep11cnt;
  info("stops with 2 departures and 2 arrivals : $dep22cnt") if $dep22cnt;

  foreach $concnt (1 .. 6) {
    $depcnt = 0; $arrcnt = 0;
    for $stopid (values %stopids) {
      $stopid = toparent($stopid);
      $depcnt++ if $stopdeps[$stopid] == $concnt;
      $arrcnt++ if $stoparrs[$stopid] == $concnt;
    }
    info("stops with $concnt departures : $depcnt") if $depcnt;
    info("stops with $concnt arrivals   : $arrcnt") if $arrcnt;
  }
  $depcnt = 0; $arrcnt = 0; $concnt = 7;
  for $stopid (values %stopids) {
    $stopid = toparent($stopid);
    $depcnt++ if $stopdeps[$stopid] >= $concnt;
    $arrcnt++ if $stoparrs[$stopid] >= $concnt;
  }
  info("stops with $concnt + departures : $depcnt") if $depcnt;
  info("stops with $concnt + arrivals   : $arrcnt") if $arrcnt;

  while (($service_id,$sid) = each %serviceids) {
    info("service id $service_id not referenced") unless exists $sidrefs{$sid};
  }

  return 1;
}

my %ridsidtimes;

sub readstoptimes($)
{
  my ($dir) = @_;

  my ($stoptimes,$stoptimesname,$rv,$headline);
  my ($col,$colname,$line,$fldend,$endq,$c,$req,$tmpcol,$lastline);

  my ($route_id,$trip_id,$arr_time,$dep_time,$stop_id,$headsign);

  my ($routeid,$tripid,$stopid,$id,$rstopid,$rstop_id,$dep);
  my ($route,$trip,$seq,$hop,$dep_id,$arr_id);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $stoptimesname = $dir . '/' . 'stop_times.tab';

  info("reading $stoptimesname");
  return info("dryrun") if $dryrun;

  ($rv,$stoptimes,$headline) = opengtfs($stoptimesname,0,1);
  return 0 unless $rv;

  my $canoncols = "trip_id\tstop_id\tstop_sequence\tarrival_time\tdeparture_time";
  error_exit("expected $canoncols, found $headline") unless index($headline,$canoncols) == 0;

  my @lines = readline($stoptimes);
  close($stoptimes);
  error_exit("$stoptimesname is empty") unless (@lines > 0);

  my $linno = 1;
  my $linecnt = scalar(@lines);

  my $nottcnt = 0;

  my (@newtrip,@newstrip,@newstrip1);
  my ($newtripln,$parent,$parentid,$sid,$service_id,$xtripid,$xlinno,$prvpid,$pid);
  my $prvtrip = 0;
  my $prvroute = 0;
  $tripid = 0; $routeid = 0;

  my ($uniqid,$name,$tripline,$ridsidtime);
  my ($thh,$tmm,$tss,$tahh,$tamm,$tass,$tdepsec,$tarrsec,$tbias);
  my ($htdep,$htarr,$htdeparr);

  my ($prvseq,$prvid,$prvtdep,$prvtarr);

  info("$linecnt lines");

  foreach $line (@lines) {

    chop $line;
    $lastline = ($linno >= @lines);
    $linno++;
    vrb("last line") if $lastline;
    next if $line eq $headline;  # support catenated files if same col layout

    ($trip_id,$rstop_id,$seq,$arr_time,$dep_time) = split("\t",$line);
    $dep_time = '' unless defined $dep_time;
    $arr_time = '' unless defined $arr_time;

#     info("$linno $trip_id,$rstop_id,$seq,$arr_time,$dep_time");

    unless (exists($tripids{$trip_id})) {
#      vrb("line $linno: undefined or filtered trip id $trip_id");
      next;
    }
    $prvtrip = $tripid;
    $prvroute = $routeid;
    $tripid = $tripids{$trip_id};

    unless (exists($triproutes{$tripid})) {
      warning("line $linno: undefined route for trip $trip_id");
      next;
    }

    $routeid = $triproutes{$tripid};
    $route_id = $routebyids{$routeid};
    if (exists $norouteids{$route_id}) { # filtered
     info("filter $stop_id on route $route_id");
      next;
    }

    unless (exists $rstopids{$rstop_id}) {
      warning("line $linno: unknown stop ID $rstop_id");
      next;
    }
    $rstopid = $rstopids{$rstop_id};
    $stopid = $stopmerge{$rstopid};

    unless (exists $stop_ids{$stopid}) {
      warning("unknown stop ID $stopid line $linno"); # todo : at merge
      next;
    }
    $stop_id = $stop_ids{$stopid};
    unless (defined $stop_id) {
      warning("undefined stop ID for $stopid from $rstop_id $rstopid line $linno");
      next;
    }

    if ($prvtrip != $tripid) {
      $service_id = $tripservice{$trip_id};
      error_exit("undefined sid for $trip_id") unless defined $service_id;
      $sid = $serviceids{$service_id};
      error_exit("undefined $service_id") unless defined $sid;
      $sidrefs{$sid} = 1 unless exists $sidrefs{$sid};
      $tripsids{$tripid} = $sid;
    }

# todo check if valid
#    $ridsidtime = join('_',$routeid,$sid,$stopid,$dep_time);
#    if (exists $ridsidtimes{$ridsidtime}) {
#       info("line $linno duplicate entry $ridsidtime");
#      $prvtrip = $tripid;
#      next;
#    }
#    $ridsidtimes{$ridsidtime} = 1;

    push(@stop_times, join("\t",$tripid,$rstopid,$seq,$arr_time,$dep_time)) if $canonout;

#    if (exists($parentbyid{$stopid})) {
#      $parent = $parentbyid{$stopid};
#      $parentid = $parentids{$parent};
#      $id = $parentid;
#    } else { $id = $stopid; }
    $id = $stopid;

    if ($prvtrip == 0) {
      @newtrip = ();
      push @newtrip,sprintf("%03u\t%s\t%s\t%s\t%s\t%s",$seq,$tripid,$id,$dep_time,$arr_time,$linno);
    } elsif ($prvtrip == $tripid and not $lastline) {
      push(@newtrip,sprintf("%03u\t%s\t%s\t%s\t%s\t%s",$seq,$tripid,$id,$dep_time,$arr_time,$linno));
    } else {
      if ($prvtrip == $tripid) {
        push(@newtrip,sprintf("%03u\t%s\t%s\t%s\t%s\t%s",$seq,$tripid,$id,$dep_time,$arr_time,$linno));
      }
      next if @newtrip == 0;
      warning("1-hop trip $trip_id $tripid line $linno") if @newtrip == 1; # todo
      @newstrip = sort { substr($a,0,3) <=> substr($b,0,3) } @newtrip;
      @newstrip1 = ();
      foreach $tripline (@newstrip) { push @newstrip1,$tripline; }

      @newtrip = ();
      push @newtrip,sprintf("%03u\t%s\t%s\t%s\t%s\t%s",$seq,$tripid,$id,$dep_time,$arr_time,$linno);

      vrb("processing last line $newstrip[0]") if $lastline;

      $tdepsec = 0; $tarrsec = 0; $tbias = 0;
      ($seq,$xtripid,$id,$dep_time,$arr_time,$xlinno) = split("\t",$newstrip1[0]);

      foreach $tripline (@newstrip1) {
        $prvtdep = $tdepsec;
        $prvtarr = $tarrsec;
        $prvid = $id;
        $prvseq = $seq;

#        info("$tripline");

        ($seq,$xtripid,$id,$dep_time,$arr_time,$xlinno) = split("\t",$tripline);

        if ($xtripid ne $prvtrip) { # todo: at filter or at merge
          info("trip ID '$xtripid' mismatches '$prvtrip' $tripline");
#          last;
        }

        return error("trip ID '$xtripid' unsorted sequence $seq") if $seq < $prvseq;

        if (length($dep_time) and length($arr_time)) {
          ($thh,$tmm,$tss) = ($dep_time =~ $hhmmpat);
          ($tahh,$tamm,$tass) = ($arr_time =~ $hhmmpat);
          info("arrtime '$arr_time' trip $tripid") unless defined $tahh;
          $tss = 0 unless defined $tss;
          $tass = 0 unless defined $tass;
          $tdepsec = ($thh * 3600) + ($tmm * 60) + $tss;
          $tarrsec = ($tahh * 3600) + ($tamm * 60) + $tass;
          $tbias = 0 if ($tdepsec > $prvtdep and $tarrsec > $prvtarr);
        } elsif (length($dep_time)) {
          $tss = 0 unless defined $tss;
          ($thh,$tmm,$tss) = ($dep_time =~ $hhmmpat);
          warning("line $xlinno invalid time format '$dep_time'") unless defined $thh;
          $tdepsec = ($thh * 3600) + ($tmm * 60) + $tss;
          $tarrsec = $tdepsec;
        } elsif (length($arr_time)) {
          ($tahh,$tamm,$tass) = ($arr_time =~ $hhmmpat);
          unless (defined $tahh) {
            warning("line $xlinno: unrecognised tarr '$arr_time' in '$tripline'");
          }
          $tass = 0 unless defined $tass;
          $tarrsec = ($tahh * 3600) + ($tamm * 60) + $tass;
          $tdepsec = $tarrsec;
        } elsif ($prvtdep > 0 and $prvtarr > 0) {
          $tdepsec = $prvtdep;
          $tarrsec = $prvtarr;
          if ($seq > $prvseq) { $tbias += 2; }
          else { $tbias -= 2; }
# todo: common in e.q nsw
#          info("trip $xtripid has no time for seq $seq at line $xlinno : interpolated");
        } else {
          info("trip $xtripid stop $stopnames{$id} has no time");
          $sid = $nosid;
          $tdepsec = $prvtdep;
          $tarrsec = $prvtarr;
          next;
        }

        $tdepsec += $tbias;
        $tarrsec += $tbias;
        next if $id == $prvid;

        if ($seq == $prvseq) {
          warning("trip ID '$xtripid' duplicate sequence $seq line $xlinno");
          next;
        }

        if ( ($tdepsec / 3600) > 72 or ($tarrsec / 3600) > 72) {
          printf("dep %u h arr %u h %u\n",($tdepsec / 3600),($tarrsec / 3600),$tripid);
        }

        $htdep = int $prvtdep;
        $htarr = int $tarrsec;

        if ($htdep > $htarr) {
          info("line $xlinno bias $tbias $tripline");
          warning("line $xlinno tdep $htdep after tarr $htarr trip $trip_id d $thh:$tmm:$tss a $tahh:$tamm:$tass");
        }

        printf("d %u:%u a %u:%u\n",$htdep / 3600,($htdep % 3600) / 60,$htarr / 3600,($htarr % 3600) / 60) if $htdep > $htarr;
        $htarr++ if $htdep == $htarr;
        warning("tdep $htdep equals tarr $htarr") if $htdep == $htarr;

        # actual hop derived from key lateron
        warning("no 2parent for $prvid") unless exists $stop2parent{$prvid};
        $prvpid = $stop2parent{$prvid};
        $pid = $stop2parent{$id};
        $uniqid = join('_',$prvroute,$prvpid,$pid);
#        info("uniqid $uniqid");
        $sumtimes++;
        if (exists($tripseq{$uniqid})) {
          push @{ $tripseq{$uniqid} },join('_',$prvid,$id,$xtripid,$htdep,$htarr,$seq);
        } else {
          $tripseq{$uniqid} = [ join('_',$prvid,$id,$xtripid,$htdep,$htarr,$seq) ];
          push @uniqids,$uniqid;
          $stopdeps[$prvid]++;
          $stoparrs[$id]++;
          $stopdeps[$prvpid]++ if $prvid != $prvpid;
          $stoparrs[$pid]++ if $id != $pid;

          $hopcnt++;
        }
      } # each tripline
    }

    $ttcnt++;

    progress("line %u of %u",$linno,$linecnt) if $linno == 1 or ($linno % 100000) == 0;

  } # each line
  print "\n";
  info("$ttcnt time entries, $nottcnt skipped, $hopcnt hops");

  do_conn();

  my %ridrefs;
  my ($rid,$arr,$cnt);

  foreach $uniqid (@uniqids) {
    ($rid,$dep,$arr) = split('_',$uniqid);
    $ridrefs{$rid}++;
  }
  while (($rid,$cnt) = each %ridrefs) {
    vrb("rid $rid has $cnt hops");
  }
  return 1;
}

sub import($)
{
  my ($dir) = @_;

  info("excluding bus") unless $include_bus;
  info("excluding train") unless $include_rail;
  info("excluding metro") unless $include_metro;
  info("excluding ferry") unless $include_ferry;

  readfeedinfo($dir);
  readagency($dir) or return 0;
  $agencyname = '(none)' unless defined $agencyname;

  rdgtfscfg($agencyname,$feedpublisher);

  readroutes($dir) or return 0;
  readcalendar($dir) or return 0;
  readcaldates($dir) or return 0;
  readstops($dir) or return 0;
  readtrips($dir) or return 0;
  readstoptimes($dir) or return 0;
  return 1;
}

sub getdate()
{
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($^T);

  return sprintf("%u-%02u-%02u %u:%02u utc",$year+1900,$mon+1,$mday,$hour,$min);
}

sub iniext($$)
{
  my ($name,$cnt) = @_;

  my $bckname = $name . '.bak';

  info("writing $cnt items to $name");

  unlink($bckname) if -f $bckname;
  rename($name,$bckname) if -f $name;
}

sub inican($)
{
  my ($name) = @_;

  my $bckname = $name . '.bak';

  info("writing $name");

  unlink($bckname) if -f $bckname;
  rename($name,$bckname) if -f $name;
}

sub infoext($)
{
  my ($file) = @_;

  printf($file "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
}

sub writext($$)
{
  my ($indir,$outdir) = @_;

  my ($name,$portfile,$hopfile,$routefile);
  my ($stop,$stopid,$hop,$route,$hopid);
  my ($dep_id,$arr_id,$dep,$arr,$depname,$arrname);
  my ($routeid,$route_id,$agency_id,$reserve,$rid,$rtype,$srtype,$shortname,$longname);
  my ($cnt,$line);

  return 1 if $testonly;

  info("writing tripover external format");
  return info("dryrun") if $dryrun;

  my $portname = $outdir . '/ports.txt';
  iniext($portname,$stopcnt);

  open($portfile,'>:encoding(UTF-8)',$portname) or error_exit("cannot create $portname:$!");

  print($portfile "# ports.txt - tripover external port aka stops file\n\n");
  infoext($portfile);
  printf($portfile "# %u ports from %s/stops.txt\n\n",$stopcnt,$indir);

  printf($portfile ".latscale\t.%u\n",$latscale);
  printf($portfile ".lonscale\t.%u\n\n",$lonscale);

  printf($portfile "# name\tid\tsubid\tlat\tlon\topts\n\n");

  my ($stop_id,$stopid_to,$stop_name,$stop_code,$ilat,$ilon,$desc,$opts);
  my ($parent,$parentid,$stopstr);
  my $portcnt = $parentcnt;
  my $unconcnt = 0;

  foreach $stopid (sort { $a <=> $b } keys %stops) {
    $stopstr = $stops{$stopid};

    ($stop_name,$ilat,$ilon,$stop_code,$desc,$opts) = split("\t",$stopstr);

    $stop_id = $stop_ids{$stopid};  # gtfs-view : stop_id.parent = stopid@tripover

    if ($omit_unconnect and $stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0) {
      $unconcnt++;
      next;
    }

    $stop_code = '' unless defined $stop_code;
    $opts = 0 unless defined $opts;

    $parent = '';
    $parent = $parentbyid{$stopid} if exists $parentbyid{$stopid};

    if (length($parent) > 0 and exists $parentids{$parent}) {
      warning("$parent equal to $stop_id") if $parent eq $stop_id;
      $parentid = $parentids{$parent};
      $stopid_to = $parentid;   # tripover-view  parent@gtfs = stopid_to
    } else {
      $stopid_to = $stopid;
      $portcnt++;
    }

    printf($portfile "%s\t.%u\t.%u\t%x\t%x\t%x\t# id %s code %s %s\n",$stop_name,$stopid_to,$stopid,$ilat,$ilon,$opts,$stop_id,$stop_code,$parent);
  }
  close($portfile);
  info("wrote $stopcnt stops to $portcnt ports");
  info("omitted $unconcnt unconnected stops") if $unconcnt;

  my $timefile;
  my $timename = $outdir . '/times.txt';
  my ($service_id,$sid,$t0,$t1,$utcofs,$day,$dow,$addcnt,$subcnt,$addtimes,$subtimes);
  my @sidsubs;
  my @sidadds;

  iniext($timename,$sidcnt);

  open($timefile,'>',$timename) or error_exit("cannot create $timename:$!");
  print($timefile "# times.txt - tripover external timetable aka calendar file\n\n");
  infoext($timefile);
  printf($timefile "# %u entries from %s\n\n",$sidcnt,$indir);

  printf($timefile ".dowstart\t'%s\t# day a week starts at : lsb in mask\n",$dowstart);
  printf($timefile ".timebox\t.%u\t.%u\t# time span in days\n",$mint0,$maxt1);

  print($timefile "# service_id\tsid\tdow\tstart\tend\t# \n\n");

  while (($service_id,$sid) = each %serviceids) {
    next unless exists $sidrefs{$sid};
    unless (exists $sidutcofs{$sid}) {
      warning("service service_id has unknown timezone");
      $utcofs = 1200;
    } else { $utcofs = $sidutcofs{$sid}; }

    $dow = $servicedow{$sid};
    $t0 = $servicet0{$sid};
    $t1 = $servicet1{$sid};
    if (defined $serviceadd{$sid}) {
      @sidadds = @{ $serviceadd{$sid} };
      $addcnt = @sidadds;
    } else { $subcnt = 0; }
    if (defined $servicesub{$sid}) {
      @sidsubs = @{ $servicesub{$sid} };
      $subcnt = @sidsubs;
    } else { $subcnt = 0; }
    $addtimes = $addcnt ? join("\t",@sidadds) : '';
    $subtimes = $subcnt ? join("\t",@sidsubs) : '';
    printf($timefile "%s\t.%u\t%x\t..%u\t%u\t%u\t%u\t%u\t%s\t%s\tx\n",$service_id,$sid,$dow,$utcofs,$t0,$t1,$addcnt,$subcnt,$addtimes,$subtimes);
  }
  close($timefile);

  my $routename = $outdir . '/to_routes.txt';
  my $utcofs12;
  iniext($routename,$routecnt);

  open($routefile,'>:encoding(UTF-8)',$routename) or error_exit("cannot create $routename:$!");
  print($routefile "# to_routes.txt - tripover external route file\n\n");
  infoext($routefile);
  printf($routefile ".ridrange\t..%u\t%u\n\n",$routecnt,$hirrid);
  print($routefile "# name\trid\ttype\treserve\tutcofs\n\n");

  foreach $line (@routes) {
    ($route_id,$agency_id,$reserve,$utcofs12,$shortname,$longname,$rtype) = split("\t",$line);
    next unless exists $routeids{$route_id};
    $rid = $routeids{$route_id};

    if (keys %agency_ids == 1) {
      $name = join(' ',$shortname,$longname);
    } else {
      $name = join(' ',$agency_id,$shortname,$longname);
    }
    $srtype = extrtype($rtype);
    printf($routefile "%s\t%u\t%u\t%u\t%u # %u\n",$name,$rid,$srtype,$reserve,$utcofs12,$rtype);
  }
  close($routefile);
  info("wrote to_routes.txt");

  my $hopname = $outdir . '/hops.txt';
  iniext($hopname,$hopcnt);

  open($hopfile,'>:encoding(UTF-8)',$hopname) or error_exit("cannot create $hopname:$!");
  print($hopfile "# hops.txt - tripover external hops aka trips file\n\n");
  printf($hopfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($hopfile "# %u hops from %s/stoptimes.txt\n\n",$hopcnt,$indir);

  printf($hopfile ".sumtimes\t.%u\t# total number of time entries\n",$sumtimes);
  printf($hopfile ".trips\t.%u\t# total number of trips\n",$tripcnt);
  printf($hopfile ".hitrip\t.%u\t# highest trip ID\n\n",$hitripid);

  print($hopfile "# route\tID\tfrom\tto\ttype\trid\ttimes\t# from-name to-name\n");
  print($hopfile "#   times: fmt sdep sarr sid tid tdep tarr\n\n");

  my ($uniqid,$hoptime,$mark,$fmt,$timestr,$testr);
  my $xinfo = '';
  my $hopno = 0;
  my $dupcnt = 0;
  my @times;
  my @hoptimes;
  my ($tid,$tdep,$tarr,$seq,$tdeparr,$ztid,$ztdep,$ztarr,$prvsid,$prvtid,$prvtdep,$prvtarr);
  my ($sdep,$sarr,$prvsdep,$prvsarr);
  my ($depstr,$arrstr,$timecnt);

  foreach $uniqid (@uniqids) {

    my $testcnt1 = 0;
    my $testcnt2 = 0;

    @times = @{ $tripseq{$uniqid} };

    error_exit("invalid hop id $hopno") if ($hopno >= $hopcnt);

    ($rid,$dep,$arr) = split('_',$uniqid);
    error_exit("missing hop arguments") unless defined $arr;

    warning("route ID $rid not found") unless exists $routebyids{$rid};
    $route = $routebyids{$rid};
    warning("route $route not found") unless exists $routeids{$route};
    next if exists $norouteids{$route_id}; # filtered: should not reach upto here

    $hopid = $hopno;

    $timecnt = scalar @times;
    vrb("$timecnt time entries");

    $depname = $stopnames{$dep};
    $arrname = $stopnames{$arr};

    if ($dep == $arr) { # possible due to nearby dup merging
      vrb("hop $hopid dep $dep equals arr $depname");
      $dupcnt++;
      next;
    }

    warning("$route type not found") unless exists $rtypes{$rid};
    $rtype = $rtypes{$rid};
    $route = '.' . $route if (substr($route,0,1) eq '.');
    $xinfo = "\t# '$depname' to '$arrname'" if ($verbose_hops > 0);

    ($sdep,$sarr,$tid,$tdep,$tarr,$seq) = split('_',shift @times);
    $sid = $tripsids{$tid};
    $fmt = 0;
    $timestr = sprintf("%x\t%x\t%x\t%x\t%x\t%x\t%x\t%x",$fmt,$sdep,$sarr,$sid,$tid,$tdep,$tarr,$seq);

    warning("tdep $tdep after tarr $tarr for tid $tid") if $tdep > $tarr;
    warning("tdep $tdep equals tarr $tarr") if $tdep == $tarr;

    for $testr (@times) {
      $prvsid = $sid; $prvtid = $tid; $prvtdep = $tdep; $prvtarr = $tarr;
      $prvsdep = $sdep; $prvsarr = $sarr;
      ($sdep,$sarr,$tid,$tdep,$tarr,$seq) = split('_',$testr);
      $sid = $tripsids{$tid};

      warning("tdep $tdep after tarr $tarr") if $tdep > $tarr;
      warning("tdep $tdep equals tarr $tarr") if $tdep == $tarr;

      $fmt = 0;

      if ($sdep == $prvsdep) { $fmt |= $fmt_prvdep; $depstr = ''; }
      else { $depstr = sprintf("%x\t",$sdep); $testcnt1++; }
      if ($sarr == $prvsarr) { $fmt |= $fmt_prvarr; $arrstr = ''; }
      else { $arrstr = sprintf("%x\t",$sarr); $testcnt2++; }

      if ($tid >= $prvtid) {
        $fmt |= $fmt_diftid;
        $ztid = $tid - $prvtid;
      } else { $ztid = $tid; }
      if ($tdep >= $prvtdep) {
        $fmt |= $fmt_difdep;
        $ztdep = $tdep - $prvtdep;
      } else { $ztdep = $tdep; }
      if ($tarr >= $prvtarr) {
        $fmt |= $fmt_difarr;
        $ztarr = $tarr - $prvtarr;
      } else { $ztarr = $tarr; }
      if ($sid == $prvsid) {
        $fmt |= $fmt_prvsid;
        $timestr .= sprintf("\t%x\t%s%s%x\t%x\t%x\t%x",$fmt,$depstr,$arrstr,$ztid,$ztdep,$ztarr,$seq);
      } else {
        $timestr .= sprintf("\t%x\t%s%s%x\t%x\t%x\t%x\t%x",$fmt,$depstr,$arrstr,$sid,$ztid,$ztdep,$ztarr,$seq);
      }
    }
    printf($hopfile "%s\t%x\t.%u\t.%u\t%x\t.%u\t.%u\t%s%s\n",$route,$hopid,$dep,$arr,$rtype,$rid,$timecnt,$timestr,$xinfo);
    $hopno++;
    progress("hop %u of %u",$hopno,$hopcnt) if $hopno == 1 or $hopno >= $hopcnt or ($hopno % 10000) == 0;

#    info("eq dep $testcnt1  eq arr $testcnt2");

  }
  return error("wrote 0 hops") if $hopno == 0;
  print "\n";
  info("wrote $hopno hops, filtered $dupcnt duplicates");
  return 1;
}

# write input to canonical gtfs:
# prefix all IDs with an agency-unique ID
# only includes required fields, and fields needed for proper merging
sub writegtfs()
{
  my ($stopsfile,$calendarfile,$caldatesfile,$routesfile,$tripsfile,$stoptimfile,$agencyfile);
  my ($line,$fname);

  my ($name,$id,$parent,$lat,$lon,$ilat,$ilon,$code,$desc,$opt);
  my ($loctype,$stopid,$stopstr);

  my ($mon,$tue,$wed,$thu,$fri,$sat,$sun,$startdate,$enddate,$date,$extype);

  my ($route_id,$shortname,$longname,$rtype,$utcofs,$reserve);

  my ($service_id,$sid,$headsign,$dir);

  my ($tripid,$trip_id,$stop_id,$seq,$dep_time,$arr_time);

  my ($agency_id,$agency_name,$agency_url,$agency_timezone);

  return warning("input is canonical, no canonical output") if ($iscanonin);

# agency
  $fname = 'agency.tab';
  inican($canondir . "/$fname");
  open($agencyfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
  print($agencyfile "agency_id\tagency_name\tagency_timezone\tagency_url\n");

  foreach $line (@agencies) {
    ($agency_id,$agency_name,$agency_url,$agency_timezone) = split("\t",$line);
    print($agencyfile "$agency_id\t$agency_name\t$agency_timezone\t$agency_url\n");
  }
  close($agencyfile);
  info("wrote canonical agency.tab");

# stops
  $fname = 'stops.tab';
  inican($canondir . "/$fname");
  open($stopsfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
  print($stopsfile "stop_id\tstop_code\tlocation_type\tparent_station\tstop_name\tstop_lat\tstop_lon\tstop_desc\n");
  while (($stopid,$stopstr) = each %stops) {

    ($name,$ilat,$ilon,$code,$desc,$opt) = split("\t",$stopstr);

    $id = $stop_ids{$stopid};  # gtfs-view : stop_id.parent = stopid@tripover

    $code = '' unless defined $code;
    $opt = 0 unless defined $opt;

    $parent = '';
    $parent = $idprefix . $parentbyid{$stopid} if exists $parentbyid{$stopid};

    $loctype = ($opt & $opt_parentstop) ? 1 : 0;

#    next if ($omit_unconnect and $loctype == 1 and $stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0);
    next if ($omit_unconnect and $stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0);

    $lat = ilat2lat($ilat);
    $lon = ilon2lon($ilon);

    print($stopsfile join("\t",$idprefix . $id,$code,$loctype,$parent,$name,$lat,$lon,$desc));
    print($stopsfile "\n");
  }
  close($stopsfile);
  info("wrote canonical stops.tab");

# calendar
  if (@calendar > 0) {
    $fname = 'calendar.tab';
    inican($canondir . "/$fname");
    open($calendarfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
    print($calendarfile "service_id\tmonday\ttuesday\twednesday\tthursday\tfriday\tsaturday\tsunday\tstart_date\tend_date\n");

    foreach $line (@calendar) {
      ($service_id,$mon,$tue,$wed,$thu,$fri,$sat,$sun,$startdate,$enddate) = split("\t",$line);

      $sid = $serviceids{$service_id};
      next unless exists $sidrefs{$sid};

      $service_id = $idprefix . $service_id;
      print($calendarfile join("\t",$service_id,$mon,$tue,$wed,$thu,$fri,$sat,$sun,$startdate,$enddate));
      print($calendarfile "\n");
    }
    close($calendarfile);
    info("wrote canonical calendar.tab");
  }

  if (@caldates > 0) {
    $fname = 'calendar_dates.tab';
    inican($canondir . "/$fname");
    open($caldatesfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
    print($caldatesfile "service_id\texception_type\tdate\n");

    foreach $line (@caldates) {
      ($service_id,$date,$extype) = split("\t",$line);

      $sid = $serviceids{$service_id};
      next unless exists $sidrefs{$sid};

      $service_id = $idprefix . $service_id;
      print($caldatesfile "$service_id\t$extype\t$date\n");
    }
    close($caldatesfile);
    info("wrote canonical calendar_dates.tab");
  }

# routes
  my $reserveprefix = $allreserved ? 'r' : 'u';

  $fname = 'routes.tab';
  inican($canondir . "/$fname");
  open($routesfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
  print($routesfile "route_id\tagency_id\troute_type\troute_short_name\troute_long_name\troute_desc\n");

  foreach $line (@routes) {
    ($route_id,$agency_id,$reserve,$utcofs,$shortname,$longname,$rtype) = split("\t",$line);
    $route_id = join '_',$canonmagic,$reserveprefix,$idprefix,$route_id;
    print($routesfile "$route_id\t$agency_id\t$rtype\t$shortname\t$longname\t$desc\n");
  }
  close($routesfile);
  info("wrote canonical routes.tab");

#trips
  $fname = 'trips.tab';
  inican($canondir . "/$fname");
  open($tripsfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
  print($tripsfile "route_id\tservice_id\ttrip_id\ttrip_headsign\n");

  foreach $line (@trips) {
    ($route_id,$service_id,$trip_id,$headsign) = split("\t",$line);

    next if exists($norouteids{$route_id});

    $route_id = join '_',$canonmagic,$reserveprefix,$idprefix,$route_id;
    $service_id = $idprefix . $service_id;
    $trip_id = $idprefix . $trip_id;
    $headsign =~ tr','`';
    print($tripsfile "$route_id\t$service_id\t$trip_id\t$headsign\n");
  }
  close($tripsfile);
  info("wrote canonical trips.tab");

# stop times
  $fname = 'stop_times.tab';
  inican($canondir . "/$fname");
  open($stoptimfile,'>:encoding(UTF-8)',$canondir . "/$fname") or return 0;
  print($stoptimfile "trip_id\tstop_id\tstop_sequence\tarrival_time\tdeparture_time\n");

  foreach $line (@stop_times) {
    ($tripid,$stopid,$seq,$arr_time,$dep_time) = split("\t",$line);
    $trip_id = $idprefix . $trip_ids{$tripid};
    $stop_id = $idprefix . $rstopbyid{$stopid};
    print($stoptimfile "$trip_id\t$stop_id\t$seq\t$arr_time\t$dep_time\n");
  }
  close($stoptimfile);
  info("wrote canonical stop_times.tab");
  return 1;
}

sub merge($$$)
{
  my ($outdir,$indir,$first) = @_;

  my ($name,$infile,$outfile,$infname,$outfname,$headline,$line,$openmode);
  my @lines;

  info("merge $indir into $outdir " . ($first ? " " : " append"));
  for $name (qw/agency.tab stops.tab calendar.tab calendar_dates.tab routes.tab trips.tab stop_times.tab/) {
    $outfname = "$outdir/$name";

    if ($first) {
      $openmode = '>';
      unlink $outfname;
    } else {
      $openmode = '>>';
    }

    $infname = "$indir/$name";
    next unless -f $infname;

    open($infile,'<:encoding(UTF-8)',$infname) or return error("cannot open $infname:$!");
    $headline = readline($infile);
    next unless length $headline;
    @lines = readline($infile);
    close($infile);
    next unless (@lines > 0);

    open($outfile,$openmode . ':encoding(UTF-8)',$outfname) or return error("cannot open $outfname:$!");
    print($outfile $headline) unless -s $outfname;
    for $line (@lines) { print($outfile $line); }
    close($outfile);
  }
  return 1;
}

# main program starts here

my $starttime = time();

my ($arg,$opt,$cmd,$argno);
my @args;

if (@ARGV == 0) { usage(); exit 1; }

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
    if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
  }
}

showvers(0);

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
    elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
    elsif ($opt eq 'a' or $opt eq 'analysis') { info('analysis output enabled'); $anaout = 1; }
    elsif ($opt eq 'c' or $opt eq 'canonical') { info('canonical output enabled'); $canonout = 1; }
    elsif ($opt eq 'r' or $opt eq 'reserve') { info('mark all routes as requiring reservation'); $allreserved = 1; }
    elsif ($opt eq 't' or $opt eq 'test') { info('test only, no output'); $testonly = 1; }
    elsif ($opt eq 'nobus') { $include_bus = 0; }
    elsif ($opt eq 'nometro') { $include_metro = 0; }
    elsif ($opt eq 'noferry') { $include_ferry = 0; }
    elsif ($opt eq 'notrain' or $opt eq 'norail') { $include_rail = 0; }
    else { info("ignoring unknown option -$opt"); }
  } else {
    push(@args,$arg);
  }
}
if (@args > 0) {
  init();
  $cmd = $args[0];
  if ($cmd eq 'import') {
    unless (@args > 1) { basemsg("missing arg 'dir' for import"); exit 1; }
    $outdir = (@args > 1) ? $args[1] : '.';
    $indir = (@args > 2) ? $args[2] : $outdir;
    $anadir = $outdir;
    $canondir = $outdir;
    info("import from $indir to $outdir");
    if (import($indir)) {
      writext($indir,$outdir);
      writegtfs() if $canonout;
    }
  } elsif ($cmd eq 'merge') {
    unless (@args > 2) { basemsg("merge needs outdir and at least one indir arg"); exit 1; }
    $outdir = $args[1];
    for ($argno = 2; $argno < @args; $argno++) {
      merge($outdir,$args[$argno],$argno == 2) or exit 1;
    }
  }
  else { info("unknown command"); }
}

my $usertime = time() - $starttime;
if ($usertime > 60) { info("elapsed time " . int($usertime / 60) . " min " . $usertime % 60 . " sec"); }
else { info("elapsed time $usertime seconds"); }

info("1 warning") if $warningcnt == 1;
info("$warningcnt warnings") if $warningcnt > 1;
while (my ($line,$cnt) = each %warncnts) {
  info("line $line $warnings{$line} * $cnt");
}

info("1 error") if $errorcnt == 1;
info("$errorcnt errors") if $errorcnt > 1;

# POSIX::_exit($errorcnt > 0);
