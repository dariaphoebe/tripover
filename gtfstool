#!/usr/bin/perl -W

# gtfstool - handle gtfs feeds

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# primary use is to import gtfs feeds into tripover format.
# feeds can be merged, filtered, or verified
# optional export from tripover format to gtfs

use 5.008;
use strict;
use integer;

# stop at compile-time warnings
my $ccmsg = '';
local $SIG{__WARN__} = sub { print "$ccmsg $_[0]"; exit 1;  };

my $version_maj = 0;
my $version_min = 12;
my $lastchanged = "30 oct 2014";

my $copyright = "Copyright (C) 2014, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $warningcnt = 0;
my $errorcnt = 0;

my $verbose_hops = 1;

my $logname = 'gtfstool.log';
rename($logname,$logname . '.0') if -f $logname;
open(my $logfile,'>',$logname) or die("cannot create $logname:$!");

sub msg($)     { print("$_[0]\n"); print($logfile "$_[0]\n"); }
sub info($)    { msg($_[0]); return 1; }
sub warning($) { msg("warning: " . $_[0]); $warningcnt++; return 1; }
sub error($$)   { msg("error: " . $_[0] . " at " . $_[1]); $errorcnt++; return 0; }

sub error_exit($) { error($_[0],0); exit 1; }

sub vrb($) {
  $ccmsg = $_[0] . "\n";
  print("$_[0]\n") if $verbose;
  print($logfile "$_[0]\n") if $verbose;
  return 1;
}

sub max($$) {
  my ($a,$b) = @_;
  return ($a > $b ? $a : $b);
}

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub usage()
{
  info("usage: gtfstool [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("import <indir> [outdir] import gtfs into tripover");
}

# these are written as options to ext output
my $rtype_walk = 1699;
my $maxvariant = 16;
my $hivariant = 0;

# use integer codes for fields
my $col_enum = 1;
my $col_stopid    = $col_enum++;
my $col_stopcode  = $col_enum++;
my $col_stopname  = $col_enum++;
my $col_stopdesc  = $col_enum++;
my $col_stoplat   = $col_enum++;
my $col_stoplon   = $col_enum++;
my $col_zoneid    = $col_enum++;
my $col_stopurl   = $col_enum++;
my $col_loctype   = $col_enum++;
my $col_parent    = $col_enum++;
my $col_platform  = $col_enum++;

my $col_tripid    = $col_enum++;
my $col_headsign  = $col_enum++;
my $col_direction = $col_enum++;
my $col_arrtime   = $col_enum++;
my $col_deptime   = $col_enum++;
my $col_stopseq   = $col_enum++;
my $col_picktype  = $col_enum++;
my $col_droptype  = $col_enum++;

my $col_routeid   = $col_enum++;
my $col_routesname = $col_enum++;
my $col_routelname = $col_enum++;
my $col_routedesc = $col_enum++;
my $col_routetype = $col_enum++;

my $col_serviceid = $col_enum++;

my $col_unknown = $col_enum++;

my $opt_childstop = 1;
my $opt_parentstop = 2;
my $opt_inferred = 4;

# store field results here
my %stopids;
my %stop_ids;

my %stopnames;

my @stops;

my @stopdeps;
my @stoparrs;
my %railstops;

my %parents;
my %parentids;
my %parent_ids;
my %parentbyid;
my $parentcnt = 0;

my %tripids;
my %tripseq;
my %trippseq;
my %triprefs;
my %triproutes;
my $walkroute;

my @trips;

my @hops;

my @routes;
my %routeids;
my %norouteids;
my %routebyids;
my %rtypes;

my %uniqhops;

# my @stentries;

my @trip_ids;
my @dep_times;
my @arr_times;

my $stopcnt = 0;
my $ttcnt = 0;
my $hopcnt = 0;
my $tripcnt = 0;
my $routecnt = 0;
my $noroutecnt = 0;

my $nondigits = qr'[^0-9]';

my $unquoter = qr'/""/"/g';

sub inarray($@) {
  my ($a,@arr) = @_;

  foreach my $b (@arr) { return 1 if $a eq $b; }
  return 0;
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover gtfs tool version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

sub init()
{
}

sub readstops($)
{
  my ($dir) = @_;

  my ($stopfile,$stopsname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req,$val);
  my ($id,$stopid,$code,$name,$desc,$lat,$lon,$zone_id,$url,$loctype,$parent,$platform,$opt);

  return error("missing dir arg for import",__LINE__) unless defined $dir and length($dir);

  $stopsname = $dir . '/' . 'stops.txt';

  info("reading $stopsname");
  return info("dryrun") if $dryrun;

  open($stopfile,'<',$stopsname) or return error("cannot open stops.txt:$!",__LINE__);
  my $headline = readline($stopfile);
  error_exit("stops.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_stopid if ($colname eq 'stop_id');
    $colid = $col_stopcode if ($colname eq 'stop_code');
    $colid = $col_stopname if ($colname eq 'stop_name');
    $colid = $col_stopdesc if ($colname eq 'stop_desc');
    $colid = $col_stoplat if ($colname eq 'stop_lat');
    $colid = $col_stoplon if ($colname eq 'stop_lon');
    $colid = $col_zoneid if ($colname eq 'zone_id');
    $colid = $col_stopurl if ($colname eq 'stop_url');
    $colid = $col_loctype if ($colname eq 'location_type');
    $colid = $col_parent if ($colname eq 'parent_station');
    $colid = $col_platform if ($colname eq 'platform_code');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields") if (@cols < @colnames);

  foreach $req ('stop_id','stop_name','stop_lat','stop_lon') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($stopfile);
  close($stopfile);
  error_exit("stops.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $line .= ',';

    $linno++;
#    last if ($linno > 10);

    $id = ''; $code = ''; $name = ''; $lat = ''; $lon = '';
    $loctype = ''; $parent = ''; $platform = ''; $desc = '';

    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;
      $val = substr($line,0,$comma);

      if ($col == $col_stopid) {
        $id = substr($line,0,$comma);
        # may be integer or string. must be unique in set
        # tripover needs an integer : use line number as derived id

        if (exists($stopids{$id})) {
          warning("$linno: stop id $id already defined on line $stopids{$id}");
        } else {
          $stopid = $linno;
          $stopids{$id} = $stopid;
          $stop_ids{$stopid} = $id;
          $stopdeps[$stopid] = 0;
          $stoparrs[$stopid] = 0;
        }

      } elsif ($col == $col_stopcode) {
        $code = $val;

      } elsif ($col == $col_stopname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $name = substr($line,0,$endq);
          $name =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else { # unquoted
          $name = substr($line,0,$comma);
        }

      } elsif ($col == $col_stopdesc) {
        if (substr($line,0,1) eq '"') {
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $desc = substr($line,0,$endq);
          $desc =~ $unquoter;
          $line = substr($line,$endq+1);
          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else {
          $desc = substr($line,0,$comma);
        }

      } elsif ($col == $col_stoplat) {
        $lat = $val;

      } elsif ($col == $col_stoplon) {
        $lon = $val;

      } elsif ($col == $col_parent) {
        $parent = $val;

      } elsif ($col == $col_platform) {
        $platform = $val;

      } elsif ($col == $col_loctype) {
        $loctype = $val;
      }

      $line = substr($line,$comma+1);

    } # each col

    warning("$id has empty lon") if length($lon) < 1;
    warning("$id has empty lat") if length($lat) < 1;
    $desc = ' ' unless length($desc);
    $code = ' ' unless length($code);

    $stopnames{$stopid} = $name;

    if (length($loctype) > 0 and $loctype == 1) {
      vrb("station $name as $id code $code");
      $parentids{$id} = $stopid;
      $parent_ids{$stopid} = $id;
      $parentcnt++;
      $opt = $opt_parentstop;
    } elsif (length($parent) > 0) {  # refers to id above
      $opt = $opt_childstop;
      $parents{$parent} .= $stopid . ' ';
      $parentbyid{$stopid} = $parent;
    } else { $opt = 0; }

    error_exit("no stop code at line $linno") unless defined $code;

    push(@stops,join("\t",$name,$id,$parent,$lat,$lon,$code,$desc,$opt));

  }

  foreach $parent (keys %parentids) {
    error("parent station $parent not found",__LINE__) unless exists $parentids{$parent};
  }

  $stopcnt = scalar(@stops);
  info("$stopcnt stops $parentcnt parent stations");

  return 1;
}

my $include_tram = 1;
my $include_metro = 1;
my $include_rail = 1;
my $include_bus = 1;

sub filtermode($)
{
  my ($type) = @_;

  return 1 if ($type == 0 and $include_tram == 1);
  return 1 if ($type == 1 and $include_metro == 1);
  return 1 if ($type == 2 and $include_rail == 1);
  return 1 if ($type == 3 and $include_bus == 1);
  return 0;
}

sub readroutes($)
{
  my ($dir) = @_;

  my ($routefile,$routefname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$routeid1,$name,$slname,$rtype);

  $routefname = $dir . '/' . 'routes.txt';

  info("reading $routefname");
  return info("dryrun") if $dryrun;

  open($routefile,'<',$routefname) or return error("cannot open routes.txt:$!",__LINE__);
  my $headline = readline($routefile);
  error_exit("routes.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_routeid if ($colname eq 'route_id');
    $colid = $col_routesname if ($colname eq 'route_short_name');
    $colid = $col_routelname if ($colname eq 'route_long_name');
    $colid = $col_routedesc if ($colname eq 'route_desc');
    $colid = $col_routetype if ($colname eq 'route_type');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  error_exit("missing required route name") unless inarray('route_short_name',@colnames) or inarray('route_long_name',@colnames);

  foreach $req ('route_id','route_type') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($routefile);
  close($routefile);
  error_exit("routes.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';
    $name = ''; $slname = ''; $route_id = ''; $rtype = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_routeid) {
        $route_id = substr($line,0,$comma);

      } elsif ($col == $col_routesname or $col == $col_routelname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $name = substr($line,0,$endq);
          $name =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else { # unquoted
          $name = substr($line,0,$comma);
        }
        $slname = $name if length($name);

      } elsif ($col == $col_routetype) {
        $rtype = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    vrb("$linno $route_id '$slname' $rtype");
    $routeid = $linno * $maxvariant;    # possible alternatives
    $routeid = $routeid * 2;  # even ID for outbound, next odd ID for inbond
    $routeid1 = $routeid + 1;

    if (exists($routeids{$route_id})) {
      warning("$linno: route id $route_id already defined on line $routeids{$route_id}");
      next;
    }

    $routebyids{$routeid} = $route_id;
    $routebyids{$routeid1} = $route_id;
    $rtypes{$routeid} = $rtype;
    $rtypes{$routeid1} = $rtype;
    $routeids{$route_id} = $routeid;

    if (filtermode($rtype)) {
      push(@routes,join("\t",$route_id,$slname,$rtype));
    } else {
      $noroutecnt++;
      $norouteids{$route_id} = $routeid;
    }

  } # each line

  $linno++;

  $route_id = 'walk';
  $walkroute = $linno * $maxvariant * 2;
  $rtype = $rtype_walk;
  $slname = 'walk inferred from parent station';
  $routeids{$route_id} = $walkroute;
  $routebyids{$walkroute} = $route_id;
  $rtypes{$walkroute} = $rtype;
  push(@routes,join("\t",$route_id,$slname,$rtype));

  info("add inferred walk route $walkroute as type $rtype");
  $routecnt = scalar(@routes);
  info("$routecnt routes, $noroutecnt filtered out");

  return 1;
}

sub readtrips($)
{
  my ($dir) = @_;

  my ($tripfile,$tripfname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$trip_id,$service_id,$headsign,$dirid);

  $tripfname = $dir . '/' . 'trips.txt';

  info("reading $tripfname");
  return info("dryrun") if $dryrun;

  open($tripfile,'<',$tripfname) or return error("cannot open trips.txt:$!",__LINE__);
  my $headline = readline($tripfile);
  error_exit("trips.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_routeid if ($colname eq 'route_id');
    $colid = $col_serviceid if ($colname eq 'service_id');
    $colid = $col_tripid if ($colname eq 'trip_id');
    $colid = $col_headsign if ($colname eq 'trip_headsign');
    $colid = $col_direction if ($colname eq 'direction_id');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  foreach $req ('route_id','service_id','trip_id') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($tripfile);
  close($tripfile);
  error_exit("trips.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';

    $trip_id = ''; $route_id = ''; $service_id = ''; $dirid = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_routeid) {
        $route_id = substr($line,0,$comma);
      } elsif ($col == $col_serviceid) {
        $service_id = substr($line,0,$comma);
      } elsif ($col == $col_tripid) {
        $trip_id = substr($line,0,$comma);
      } elsif ($col == $col_headsign) {

        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $headsign = substr($line,0,$endq);
          $headsign =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,") if $comma < 0;

        } else { # unquoted
          $headsign = substr($line,0,$comma);
        }

      } elsif ($col == $col_direction) {
        $dirid = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    if (length($trip_id) == 0) {
      warning("$linno: missing trip id for route  $route_id");
      next;
    }
    if (exists($tripids{$trip_id})) {
      warning("$linno: trip id $trip_id previously defined on line $tripids{$trip_id}");
      next;
    }
    if ($dirid ne '0' and $dirid ne '1') {
      warning("$linno: trip id $trip_id head $headsign direction $dirid not 0 or 1");
      next;
    }

    $tripids{$trip_id} = $linno;

    $routeid = $routeids{$route_id} + $dirid;
#    info("route $route_id id $routeid");
    $triproutes{$trip_id} = $routeid;

    if (exists($norouteids{$route_id})) {  # filtered
    } elsif (exists($routeids{$route_id})) {
      my $seq = {};
      my $pseq = {};
      $tripseq{$trip_id} = $seq;
      $trippseq{$trip_id} = $pseq;
      push(@trips,join("\t",$routeid,$service_id,$trip_id,$dirid));
    } else {
      warning("$linno: undefined route id $route_id");
    }

  } # each line

  $tripcnt = scalar(@trips);
  info("$tripcnt trips");

  return 1;
}

sub readstoptimes($)
{
  my ($dir) = @_;

  my ($stoptimes,$stoptimesname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$trip_id,$arr_time,$dep_time,$stop_id,$stopid,$stop_seq,$dep);
  my ($route,$trip,$seq,$hop,$dep_id,$arr_id,$prvstop_id);
  my ($concnt,$depcnt,$arrcnt,$parent,$parentid);

  return error("missing dir arg for import",__LINE__) unless defined $dir and length($dir);

  $stoptimesname = $dir . '/' . 'stop_times.txt';

  info("reading $stoptimesname");
  return info("dryrun") if $dryrun;

  open($stoptimes,'<',$stoptimesname) or return error("cannot open stop_times.txt:$!",__LINE__);
  my $headline = readline($stoptimes);
  error_exit("stoptimes.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_tripid if ($colname eq 'trip_id');
    $colid = $col_arrtime if ($colname eq 'arrival_time');
    $colid = $col_deptime if ($colname eq 'departure_time');
    $colid = $col_stopid if ($colname eq 'stop_id');
    $colid = $col_stopseq if ($colname eq 'stop_sequence');
    $colid = $col_picktype if ($colname eq 'pickup_type');
    $colid = $col_droptype if ($colname eq 'drop_off_type');
    push(@cols,$colid);
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields") if (@cols < @colnames);

  foreach $req ('trip_id','arrival_time','departure_time','stop_id','stop_sequence') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($stoptimes);
  close($stoptimes);
  error_exit("stop_times.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);
  my $ttcnt = 0;
  my $prvseq = 0;
  my $prvtrip = '';

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;
#    last if ($linno > 10000);

    $line .= ',';
    $trip_id = ''; $stop_id = ''; $stop_seq = ''; $dep_time = ''; $arr_time = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_tripid) {
        $trip_id = substr($line,0,$comma);

      } elsif ($col == $col_stopid) {
        $stop_id = substr($line,0,$comma);
        warning("$linno: undefined stop id $stop_id") unless exists $stopids{$stop_id};

      } elsif ($col == $col_stopseq) {
        $stop_seq = substr($line,0,$comma);

      } elsif ($col == $col_deptime) {
        $dep_time = substr($line,0,$comma);

      } elsif ($col == $col_arrtime) {
        $arr_time = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    unless (exists($tripids{$trip_id})) {
      warning("$linno: undefined trip id $trip_id");
      next;
    }

    if (length($stop_seq) == 0) { warning("$linno: empty stop_seq for $stop_id"); next; }
    elsif ($stop_seq =~ $nondigits) { warning("$linno: stop_seq '$stop_seq' not numerical for $stop_id"); next; }

    info("$linno: seq $stop_seq prv $prvseq") unless $stop_seq == $prvseq + 1 or $trip_id ne $prvtrip;
    $prvseq = $stop_seq;
    $prvtrip = $trip_id;

    unless (exists($triproutes{$trip_id})) {
      warning("$linno: undefined route for trip id $trip_id");
      next;
    }
    $routeid = $triproutes{$trip_id};
    $route_id = $routebyids{$routeid};
    next if exists $norouteids{$route_id}; # filtered

    $stopid = $stopids{$stop_id};

    my ($seq,$pseq);
    if (exists($parentbyid{$stopid})) {
      $parent = $parentbyid{$stopid};
      $parentid = $parentids{$parent};
      $pseq = $trippseq{$trip_id};
      $pseq->{$stop_seq} = $parentid unless exists $pseq->{$stop_seq};
#      $trippseq{$trip_id} .= $parentid . ' ';
    }
    $seq = $tripseq{$trip_id};
    unless (exists $seq->{$stop_seq}) {
      $seq->{$stop_seq} = $stopid;
      $triprefs{$trip_id}{$stop_seq} = $linno;
#      info("add $stop_id seq $stop_seq") if $routeid == 0x3fa0;
    } else { info("skip dup $stop_id seq $stop_seq"); }

#    push(@stentries,join("\t",$routeid,$trip_id,$stop_id,$stop_seq,$dep_time,$arr_time));
    $ttcnt++;

    info("line $linno of $linecnt") if ($linno % 100000) == 0;

  } # each line

  info("$ttcnt time entries");

  my @das;
  my @tripstops;
  my ($tripstr,$varno,$rtype,$rid1,$pseq,$aref,$dref);
  my ($id,$rid,$trid,$seqlen,$i,$seq2,$deparr,$arr,$depid,$arrid,$uniq,$routeno,$name);

  # recognise and split routes
  $routeno = 0;
  while (($rid,$route_id) = each %routebyids) {
    next if exists $norouteids{$route_id};

    $rtype = $rtypes{$rid};

    info("processing route $routeno of $routecnt * 2") if ($routeno++ % 50) == 0;

    my %routeseqs;

    while (($trip,$trid) = each %triproutes) {
      next if $trid ne $rid;

      $arr = -1;
      foreach $seq (sort {$a <=> $b} keys %{ $tripseq{$trip} } ) {
        if ($arr == -1) {
          $arr = $tripseq{$trip}{$seq};
          $aref = $triprefs{$trip}{$seq};
          next;
        }
        $dep = $arr;
        $arr = $tripseq{$trip}{$seq};
        if ($dep == $arr) {
          vrb("route $route_id trip $trip dep $dep equals arr $stopnames{$dep}");
          next;
        }
        $deparr = $dep . '_' . $arr;
        $dref = $aref;
        $aref = $triprefs{$trip}{$seq};
        next if exists $routeseqs{$deparr};
        $routeseqs{$deparr} = $seq;
        $stopdeps[$dep]++;
        $stoparrs[$arr]++;
        push (@hops, join("\t",$dep,$arr,$rid,$hopcnt,$dref . '-' . $aref));
        if ($rtype < 3) { $railstops{$dep} = 1; $railstops{$arr} = 1; }
        $hopcnt++;
      }
    }
  }
  info("$hopcnt hops");

  # show some connectivity stats
  if ($noroutecnt == 0) {
    while (($id,$stopid) = each %stopids) {
      $name = $stopnames{$stopid};
      if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0) {
        warning("stop $id $name is unconnected");
      } elsif ($stopdeps[$stopid] == 0) {
        info("stop $id $name has no departures");
      } elsif ($stoparrs[$stopid] == 0) {
        info("stop $id $name has no arrivals");
      }
    }
  }

  info("-- connection stats before walk links --");
  foreach $concnt (0 .. 6) {
    $depcnt = 0; $arrcnt = 0;
    for $stopid (values %stopids) {
      $depcnt++ if $stopdeps[$stopid] == $concnt;
      $arrcnt++ if $stoparrs[$stopid] == $concnt;
    }
    info("stops with $concnt departures : $depcnt");
    info("stops with $concnt arrivals   : $arrcnt");
  }

  # merge connectivity to parents
  my ($pid,$stoplst,@sibstop,$ndep,$narr);

  while (($parent,$stoplst) = each %parents) {
    $pid = $parentids{$parent};
    @sibstop = split(' ',trimws($stoplst));
    for $dep (@sibstop) {

      $ndep = $stopdeps[$dep];
      $narr = $stoparrs[$dep];

      $stopdeps[$pid] += $ndep;
      $stoparrs[$pid] += $narr;
    }
  }

  return 1;
}

sub import($)
{
  my ($dir) = @_;

  info("excluding bus") unless $include_bus;
  info("excluding train") unless $include_rail;
  info("excluding metro") unless $include_metro;

  readstops($dir) or return 0;
  readroutes($dir) or return 0;
  readtrips($dir) or return 0;
  readstoptimes($dir) or return 0;
  return 1;
}

my $latscale = 100000;
my $lonscale = 100000;

# todo autoscale on bbox and have tripover read bbox+scale
sub str2lat($)
{
  my ($inlat) = @_;

  no integer;

  my $lat;
  my $scale = $latscale;

  $lat = ($inlat + 90.0) * $scale;
  return $lat;
}

sub str2lon($)
{
  my ($inlon) = @_;

  no integer;

  my $lon;
  my $scale = $lonscale;

  $lon = ($inlon + 180.0) * $scale;
  return $lon;
}

sub getdate()
{
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($^T);

  return sprintf("%u-%02u-%02u %u:%02u utc",$year+1900,$mon+1,$mday,$hour,$min);
}

sub writext($$)
{
  my ($indir,$outdir) = @_;

  my ($name,$portfile,$hopfile,$stop,@stopln,$stopid,$hop,@hopln,$route,$hopid);
  my ($dep_id,$arr_id,$dep,$arr,$fstopcnt,$depname,$arrname);
  my ($routeid,$rid,$rtype);

  info("writing tripover external format");
  return info("dryrun") if $dryrun;

  $fstopcnt = 0;
  for $stopid (values %stopids) {
    $fstopcnt++ if ($stopdeps[$stopid] > 0 or $stoparrs[$stopid] > 0);
  }

  info("writing $fstopcnt of $stopcnt stops in $outdir");

  my $portname = $outdir . '/ports.txt';
  my $oldportname = $portname . '.bak';
  unlink($oldportname) if -f $oldportname;
  rename($oldportname,$portname) if -f $portname;

  open($portfile,'>',$portname) or error_exit("cannot create $portname:$!");

  print($portfile "# ports.txt - tripover external port aka stops file\n\n");
  printf($portfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($portfile "# %u ports from %s/stops.txt\n\n",$fstopcnt,$indir);

  printf($portfile ".latscale\tD%u\n",$latscale);
  printf($portfile ".lonscale\tD%u\n\n",$lonscale);

  printf($portfile "# name\tid\tsubid\tlat\tlon\topts\n\n");

  my ($stop_id,$stopid_to,$stop_name,$stop_code,$stop_lat,$stop_lon,$lat,$lon,$desc,$opts);
  my ($parent,$parentid,$simstr);
  my %similar;
  my $portcnt = $parentcnt;

  foreach $stop (@stops) {
    @stopln = split("\t",$stop);  #  $name,$id,$parent,$lat,$lon,$code,$desc,$opts

    $stop_name = $stopln[0];

    $stop_id = $stopln[1];  # gtfs-view : stop_id.parent = stopid@tripover
    $stopid = $stopids{$stop_id};

    next if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0);

    $parent = $stopln[2];
    $stop_lat = $stopln[3];
    $stop_lon = $stopln[4];
    $stop_code = $stopln[5];
    $desc = $stopln[6];
    $opts = $stopln[7];
    $stop_code = '' unless defined $stop_code;
    $opts = 0 unless defined $opts;

#    info("port '$stop_name' code '$stop_code' desc '$desc' opt '$opts'");

    $lat = str2lat($stop_lat);
    $lon = str2lon($stop_lon);

    if (length($parent) > 0 and exists $parentids{$parent}) {
      warning("$parent equal to $stop_id") if $parent eq $stop_id;
      $parentid = $parentids{$parent};
      $stopid_to = $parentid;   # tripover-view  parent@gtfs = stopid_to
    } else {
      $stopid_to = $stopid;
      $portcnt++;
      if (defined($railstops{$stopid}) and $opts == 0) {

# todo: refine and base on config
        $simstr = join('_',($lat / 256,$lon / 256,substr($stop_name,0,-2)));
        if (exists($similar{$simstr})) {
          $stopid_to = $similar{$simstr};
          $opts = $opt_childstop | $opt_inferred;
          info("infer parent $stopid_to for $stopid $stop_name on $simstr");
        } else {
          $similar{$simstr} = $stopid;
        }
      }
    }

    printf($portfile "%s\t%x\t%x\t%x\t%x\t%x\t# id %s code %s %s\n",$stop_name,$stopid_to,$stopid,$lat,$lon,$opts,$stop_id,$stop_code,$parent);
  }
  close($portfile);
  info("wrote $fstopcnt stops to $portcnt ports");

  info("writing $hopcnt hops");

  my $hopname = $outdir . '/hops.txt';
  my $oldhopname = $hopname . '.bak';
  unlink($oldhopname) if -f $oldhopname;
  rename($oldhopname,$hopname) if -f $hopname;

  open($hopfile,'>',$hopname) or error_exit("cannot create ports.txt:$!");
  print($hopfile "# hops.txt - tripover external hops aka trips file\n\n");
  printf($hopfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($hopfile "# %u hops from %s/stoptimes.txt\n\n",$hopcnt,$indir);

  printf($hopfile ".variants\t%x\t%x\t0\t0\t0\t# possible route variants\n",$maxvariant,$hivariant);
  printf($hopfile ".walk_id\t%x\t0\t0\t0\t0\t# route ID for inferred walk\n\n",$rtype_walk);

  print($hopfile "# routename\tID\tfrom\tto\ttype\tid\t# from-name to-name\n\n");

  my ($mark,$ref);
  my $xinfo = '';

  foreach $hop (@hops) {
    @hopln = split("\t",$hop);
    $dep = $hopln[0];
    $arr = $hopln[1];
    $rid = $hopln[2];
    $hopid = $hopln[3];
    $ref = $hopln[4];

    $depname = $stopnames{$dep};
    $arrname = $stopnames{$arr};

    if ($dep == $arr) {
      warning("hop $hopid dep $dep equals arr $depname");
      next;
    }
    warning("route ID $rid not found") unless exists $routebyids{$rid};
    $route = $routebyids{$rid};
    warning("route $route not found") unless exists $routeids{$route};

    warning("$route type not found") unless exists $rtypes{$rid};
#    info("$dep $arr $route");
    $rtype = $rtypes{$rid};
    $mark = ($rid eq $walkroute) ? 'walk ' : '';
    $route = '.' . $route if (substr($route,0,1) eq '.');
    $xinfo = "\t# $mark $ref $depname,$arrname" if ($verbose_hops > 0);

    printf($hopfile "%s\t%x\t%x\t%x\t%x\t%x%s\n",$route,$hopid,$dep,$arr,$rtype,$rid,$xinfo);
  }
  return 1;
}

my ($arg,$opt,$cmd,$indir,$outdir);
my @args;

if (@ARGV == 0) { usage(); exit 1; }

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
    if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
  }
}

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
    elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
    elsif ($opt eq 'nobus') { $include_bus = 0; }
    elsif ($opt eq 'nometro') { $include_metro = 0; }
    elsif ($opt eq 'notrain' or $opt eq 'norail') { $include_rail = 0; }
    else { info("ignring unknown option -$opt"); }
  } else {
    push(@args,$arg);
  }
}
if (@args > 0) {
  init();
  $cmd = $args[0];
  if ($cmd eq 'import') {
    error_exit("missing arg 'dir' for import") unless (@args > 1);
    $indir = $args[1];
    $outdir = (@args > 2) ? $args[2] : '.';
    import($indir) and writext($indir,$outdir);
  }
  else { info("unknown command"); }
}

my $usertime = times();
if ($usertime > 60) { info("elapsed time " . $usertime / 60 . " min " . $usertime % 60 . " sec"); }
else { info("elapsed time $usertime seconds"); }

info("$warningcnt warnings") if $warningcnt > 0;
info("$errorcnt errors") if $errorcnt > 0;
