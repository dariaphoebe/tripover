#!/usr/bin/perl -W

# gtfstool - handle gtfs feeds

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# primary use is to import gtfs feeds into tripover format.
# feeds can be merged, filtered, or verified
# export from tripover format to gtfs

use 5.008;
use strict;
use integer;

local $SIG{__WARN__} = sub { print $_[0]; exit 1;  };

my $version_maj = 0;
my $version_min = 1;
my $lastchanged = "28 sep 2014";

my $copyright = "Copyright (C) 2014, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

sub vrb($)     { print("$_[0]\n") if $verbose; return 1; }
sub info($)    { print("$_[0]\n"); return 1; }
sub warning($) { print("warning: $_[0]\n"); return 1; }
sub error($)   { print("error: $_[0]\n"); return 0; }

sub error_exit($) { print ("error: $_[0]\n"); exit 1; }

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub usage()
{
  info("usage: gtfstool [options] [cmd]\n");
  info("options:");
  info('-v -verbose        verbose mode');
  info('-n -dryrun         dryrun mode');
  info('-h -help           show help and quit');
  info('-V -version        show version and quit');
  info('-L -license        show license and quit\n');
  info("commands:");
  info("import             import gtfs into tripover");
}

sub showvers($)
{
  my ($full) = @_;

  info("Tripover gtfs tool version $version_maj.$version_min");
  info("last changed $lastchanged") if $full; 
  info("$copyright\n");
}

sub init()
{
}

# use integer codes for fields
my $stopid    = 1;
my $stopcode  = 2;
my $stopname  = 3;
my $stopdesc  = 4;
my $stoplat   = 5;
my $stoplon   = 6;
my $zoneid    = 7;
my $stopurl   = 8;
my $loctype   = 9;
my $parentsta = 10;
my $platformc = 11;

my $tripid = 12;
my $arrtime = 13;
my $deptime = 14;
my $stopseq = 15;
my $picktype = 16;
my $droptype = 17;

my $routeid = 18;
my $routesname = 19;
my $routelname = 20;
my $routedesc = 21;
my $routetype = 22;

my $serviceid = 23;

# store field results here
my %stopids;

my @stopdeps;

my @stop_ids;
my @stop_rids;
my @stop_codes;
my @stop_names;
my @stop_descs;
my @stop_lats;
my @stop_lons;
my @zone_ids;
my @stop_urls;
my @loc_types;
my @parent_stas;
my @platform_cs;

my @lats;
my @lons;

my %tripids;
my %tripseq;
my %triproutes;

my @trips;

my @hops;

my @routes;
my %routeids;

my @stentries;

my @trip_ids;
my @dep_times;
my @arr_times;

my $stopcnt = 0;
my $ttcnt = 0;
my $hopcnt = 0;
my $tripcnt = 0;
my $routecnt = 0;

my $nondigits = qr'[^0-9]';

sub inarray($@) {
  my ($a,@arr) = @_;

  foreach my $b (@arr) { return 1 if $a eq $b; }
  return 0;
}

sub readstops($)
{
  my ($dir) = @_;

  my ($stops,$stopsname);
  my ($col,$colname,$line,$comma,$endq,$c,$req);
  my ($stop_id,$stop_code,$stop_name,$stop_desc,$stop_lat,$stop_lon,$zone_id,$stop_url,$location_type,$parent_station,$platform_code);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $stopsname = $dir . '/' . 'stops.txt';

  info("reading $stopsname");
  return info("dryrun") if $dryrun;

  open($stops,'<',$stopsname) or return error("cannot open stops.txt:$!");
  my $headline = readline($stops);
  error_exit("stops.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    push(@cols,$stopid) if ($colname eq 'stop_id');
    push(@cols,$stopcode) if ($colname eq 'stop_code');
    push(@cols,$stopname) if ($colname eq 'stop_name');
    push(@cols,$stopdesc) if ($colname eq 'stop_desc');
    push(@cols,$stoplat) if ($colname eq 'stop_lat');
    push(@cols,$stoplon) if ($colname eq 'stop_lon');
    push(@cols,$zoneid) if ($colname eq 'zone_id');
    push(@cols,$stopurl) if ($colname eq 'stop_url');
    push(@cols,$loctype) if ($colname eq 'location_type');
    push(@cols,$parentsta) if ($colname eq 'parent_station');
    push(@cols,$platformc) if ($colname eq 'platform_code');
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields") if (@cols < @colnames);

  foreach $req ('stop_id','stop_name','stop_lat','stop_lon') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($stops);
  close($stops);
  error_exit("stops.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  my $unquoter = qr'/""/"/g';

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $line .= ',';

    $linno++;
#    last if ($linno > 10);

    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $stopid) {
        $stop_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);
        # may be integer or string. must be unique in set
        # tripover needs an integer : use line number as derived id

        if (exists($stopids{$stop_id})) {
          warning("$linno: stop id $stop_id already defined on line $stopids{$stop_id}");
        } else {
          $stopids{$stop_id} = $linno;
          $stopdeps[$linno] = 0;
        }
        push(@stop_rids,$linno);
        push(@stop_ids,$stop_id);

      } elsif ($col == $stopcode) {
        $stop_code = substr($line,0,$comma);
        $line = substr($line,$comma+1);
        push(@stop_codes,$stop_code);

      } elsif ($col == $stopname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $stop_name = substr($line,0,$endq);
          $stop_name =~ $unquoter;
          $line = substr($line,$endq+1);
          $line = substr($line,1) if substr($line,0,1) eq ',';
        } else { # unquoted
          $stop_name = substr($line,0,$comma);
          $line = substr($line,$comma+1);
        }
        push(@stop_names,$stop_name);

      } elsif ($col == $stopdesc) {
        if (substr($line,0,1) eq '"') {
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote") if $endq < 0;
          $stop_desc = substr($line,0,$endq);
          $stop_desc =~ $unquoter;
          $line = substr($line,$endq+1);
          $line = substr($line,1) if substr($line,0,1) eq ',';
        } else {
          $stop_desc = substr($line,0,$comma);
          $line = substr($line,$comma+1);
        }
        push(@stop_descs,$stop_desc);

      } elsif ($col == $stoplat) {
        $stop_lat = substr($line,0,$comma);
        $line = substr($line,$comma+1);
        push(@stop_lats,$stop_lat);

      } elsif ($col == $stoplon) {
        $stop_lon = substr($line,0,$comma);
        $line = substr($line,$comma+1);
        push(@stop_lons,$stop_lon);
      }

    }

    warning("$stop_id has empty lon") if length($stop_lon) < 1;
    warning("$stop_id has empty lat") if length($stop_lat) < 1;
  }

  $stopcnt = scalar(@stop_ids);
  info("$stopcnt stops");

  return 1;
}

sub readroutes($)
{
  my ($dir) = @_;

  my ($routefile,$routefname);
  my ($col,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$name,$rtype);

  $routefname = $dir . '/' . 'routes.txt';

  info("reading $routefname");
  return info("dryrun") if $dryrun;

  open($routefile,'<',$routefname) or return error("cannot open routes.txt:$!");
  my $headline = readline($routefile);
  error_exit("routes.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    push(@cols,$routeid) if ($colname eq 'route_id');
    push(@cols,$routesname) if ($colname eq 'route_short_name');
    push(@cols,$routelname) if ($colname eq 'route_long_name');
    push(@cols,$routedesc) if ($colname eq 'route_desc');
    push(@cols,$routetype) if ($colname eq 'route_type');
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  error_exit("missing required route name") unless inarray('route_short_name',@colnames) or inarray('route_long_name',@colnames);

  foreach $req ('route_id','route_type') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($routefile);
  close($routefile);
  error_exit("stop_times.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';
    $name = '';

    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $routeid) {
        $route_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);

      } elsif ($col == $routesname) {
        $name .= substr($line,0,$comma) . ' ';
        $line = substr($line,$comma+1);

      } elsif ($col == $routelname) {
        $name .= substr($line,0,$comma) . ' ';
        $line = substr($line,$comma+1);

      } elsif ($col == $routetype) {
        $rtype = substr($line,0,$comma);
        $line = substr($line,$comma+1);
      }

    } # each col

    if (exists($routeids{$route_id})) {
      warning("$linno: route id $route_id already defined on line $routeids{$route_id}");
    } else {
      $routeids{$route_id} = $linno;
    }

    push(@routes,join("\t",$route_id,$name,$rtype));

  } # each line

  $routecnt = scalar(@routes);
  info("$routecnt routes");

  return 1;
}

sub readtrips($)
{
  my ($dir) = @_;

  my ($tripfile,$tripfname);
  my ($col,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$trip_id,$service_id);

  $tripfname = $dir . '/' . 'trips.txt';

  info("reading $tripfname");
  return info("dryrun") if $dryrun;

  open($tripfile,'<',$tripfname) or return error("cannot open trips.txt:$!");
  my $headline = readline($tripfile);
  error_exit("trips.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    push(@cols,$routeid) if ($colname eq 'route_id');
    push(@cols,$serviceid) if ($colname eq 'service_id');
    push(@cols,$tripid) if ($colname eq 'trip_id');
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  foreach $req ('route_id','service_id','trip_id') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($tripfile);
  close($tripfile);
  error_exit("trips.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';

    $trip_id = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $routeid) {
        $route_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);
      } elsif ($col == $serviceid) {
        $service_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);
      } elsif ($col == $tripid) {
        $trip_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);
      }

    } # each col

    if (length($trip_id) == 0) {
      warning("$linno: missing trip id for route  $route_id");
      next;
    }
    if (exists($tripids{$trip_id})) {
      warning("$linno: trip id $trip_id previously defined on line $tripids{$trip_id}");
      next;
    } else {
      $tripids{$trip_id} = $linno;
      $tripseq{$trip_id} = '';
      $triproutes{$trip_id} = $route_id;
    }

    if (exists($routeids{$route_id})) {
      push(@trips,join("\t",$route_id,$service_id,$trip_id));
    } else {
      warning("$linno: undefined route id $route_id");
    }

  } # each line

  $tripcnt = scalar(@trips);
  info("$tripcnt trips");

  return 1;
}

sub readstoptimes($)
{
  my ($dir) = @_;

  my ($stoptimes,$stoptimesname);
  my ($col,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$rid,$trip_id,$arr_time,$dep_time,$stop_id,$stop_seq,$dep);
  my ($route,$trip,$seq,$prvseq,$hop,$dep_id,$arr_id,$prvstop_id);

  return error("missing dir arg for import") unless defined $dir and length($dir);

  $stoptimesname = $dir . '/' . 'stop_times.txt';

  info("reading $stoptimesname");
  return info("dryrun") if $dryrun;

  open($stoptimes,'<',$stoptimesname) or return error("cannot open stop_times.txt:$!");
  my $headline = readline($stoptimes);
  error_exit("stoptimes.txt is empty") unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    push(@cols,$tripid) if ($colname eq 'trip_id');
    push(@cols,$arrtime) if ($colname eq 'arrival_time');
    push(@cols,$deptime) if ($colname eq 'departure_time');
    push(@cols,$stopid) if ($colname eq 'stop_id');
    push(@cols,$stopseq) if ($colname eq 'stop_sequence');
    push(@cols,$picktype) if ($colname eq 'pickup_type');
    push(@cols,$droptype) if ($colname eq 'drop_off_type');
  }
  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields") if (@cols < @colnames);

  foreach $req ('trip_id','arrival_time','departure_time','stop_id','stop_sequence') {
    error_exit("missing required $req") unless inarray($req,@colnames);
  }

  my @lines = readline($stoptimes);
  close($stoptimes);
  error_exit("stop_times.txt is empty") unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;
#    last if ($linno > 10000);

    $line .= ',';

    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field") if $comma < 0;

      if ($col == $tripid) {
        $trip_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);

      } elsif ($col == $stopid) {
        $stop_id = substr($line,0,$comma);
        $line = substr($line,$comma+1);
        warning("$linno: undefined stop id $stop_id") unless exists $stopids{$stop_id};

      } elsif ($col == $stopseq) {
        $stop_seq = substr($line,0,$comma);
        $line = substr($line,$comma+1);

      } elsif ($col == $deptime) {
        $dep_time = substr($line,0,$comma);
        $line = substr($line,$comma+1);

      } elsif ($col == $arrtime) {
        $arr_time = substr($line,0,$comma);
        $line = substr($line,$comma+1);
      }

    } # each col

    unless (exists($tripids{$trip_id})) {
      warning("$linno: undefined trip id $trip_id");
      next;
    }

    if (length($stop_seq) == 0) { warning("$linno: empy stop_seq for $stop_id"); $stop_id = 0; }
    elsif ($stop_seq =~ $nondigits) { warning("$linno: stop_seq '$stop_seq' not numerical for $stop_id"); $stop_id = 0; }
    else {
      unless (exists($triproutes{$trip_id})) {
        warning("$linno: undefined route for trip id $trip_id");
        next;
      }
      $route_id = $triproutes{$trip_id};

      $tripseq{$trip_id} .= join(' ',$stop_seq,$stop_id,'');
    }
    push(@stentries,join("\t",$route_id,$trip_id,$stop_id,$stop_seq,$dep_time,$arr_time));

    info("line $linno of $linecnt") if ($linno % 100000) == 0;

  } # each line

  $ttcnt = scalar(@stentries);
  info("$ttcnt time entries");

  my @das;
  my @seqs;
  my ($troute,$seqlen,$i,$seq2,$deparr,$arr);

  while (($route,$rid) = each %routeids) {
#    next if ($rid > 100);

    my %routeseqs;

    while (($trip,$troute) = each %triproutes) {
      next if $troute ne $route;
      @seqs = split(' ',$tripseq{$trip});
      $seqlen = scalar @seqs;
      for ($i = 2; $i < $seqlen; $i += 2) {
        $seq = $seqs[$i]; $dep = $seqs[$i+1];
        $seq2 = $seqs[$i-2] . ' ' . $seq;
        $routeseqs{$seq2} = $seqs[$i-1] . ' ' . $dep;
      }
    }

    while (($seq2,$deparr) = each %routeseqs) {
      @das = split(' ',$deparr);
      $dep = $das[0]; $arr = $das[1];
      push (@hops, join("\t",$dep,$arr,$route,$hopcnt));
      $stopdeps[$stopids{$dep}] = 1;
      $stopdeps[$stopids{$arr}] = 1;
      $hopcnt++;
    }

    info("$hopcnt hops") if ($hopcnt % 1000) == 0;
  }
  info("$hopcnt hops");

  return 1;
}

sub import($)
{
  my ($dir) = @_;

  my $x = getdate();
  info("$x");
  return 0;

  readstops($dir) or return 0;
  readroutes($dir) or return 0;
  readtrips($dir) or return 0;
  readstoptimes($dir) or return 0;
  return 1;
}

# todo autoscale on bbox and have tripover read bbox+scale
sub str2latlon()
{
  no integer;

  my ($inlat,$inlon,$lat,$lon);
  my $scale = 100000;

  foreach $inlat (@stop_lats) {
    $lat = ($inlat + 90.0) * $scale;
    push(@lats,int($lat));
  }
  foreach $inlon (@stop_lons) {
    $lon = ($inlon + 180.0) * $scale;
    push(@lons,int($lon));
  }
}

sub getdate()
{
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($^T);

  return sprintf("%u-%02u-%02u %u:%02u utc",$year+1900,$mon+1,$mday,$hour,$min);
}

sub writext($)
{
  my ($dir) = @_;

  my ($name,$portfile,$hopfile,$stop,$hop,@hopln,$route,$hopid);
  my ($dep_id,$arr_id,$dep,$arr,$fstopcnt);

  info("writing tripover external format");
  return info("dryrun") if $dryrun;

  $fstopcnt = 0;
  for ($stop = 0; $stop < $stopcnt; $stop++) {
    $dep = $stop_rids[$stop];
    $fstopcnt++ if ($stopdeps[$dep] > 0);
  }

  info("writing $fstopcnt ports");
  open($portfile,'>','ports.txt') or error_exit("cannot create ports.txt:$!");
  print($portfile "# ports.txt - tripover external port aka stops file\n\n");
  printf($portfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,gmtime($^T));
  printf($portfile "# %u ports from %s/stops.txt\n\n",$fstopcnt,$dir);

  str2latlon();
  for ($stop = 0; $stop < $stopcnt; $stop++) {
    $dep = $stop_rids[$stop];
    if ($stopdeps[$dep] > 0) {
      printf($portfile "%x\t%s\t%x\t%x # id %s code %s\n",$dep,$stop_names[$stop],$lats[$stop],$lons[$stop],$stop_ids[$stop],$stop_codes[$stop]);
    }
  }
  close($portfile);

  info("writing $hopcnt hops");

  open($hopfile,'>','hops.txt') or error_exit("cannot create ports.txt:$!");
  print($hopfile "# hops.txt - tripover external hops aka trips file\n\n");
  printf($hopfile "# %u hops from %s/stoptimes.txt\n\n",$hopcnt,$dir);

  foreach $hop (@hops) {
    @hopln = split("\t",$hop);
    $dep_id = $hopln[0];
    $arr_id = $hopln[1];
    $route = $hopln[2];
    $hopid = $hopln[3];

    $dep = $stopids{$dep_id};
    $arr = $stopids{$arr_id};

    printf($hopfile "%s\t%x\tD%u\tD%u # %u %u\n",$route,$hopid,$dep,$arr,$dep_id,$arr_id);
  }

}

my ($arg,$opt,$cmd);
my @args;

if (@ARGV == 0) { usage(); exit 1; }

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
    if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
  }
}

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
    elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
    elsif ($opt eq 'h' or $opt eq 'help') { usage(); exit 1; }
    elsif ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    else { info("ignring unknown option -$opt"); }
  } else {
    push(@args,$arg);
  }
}
if (@args > 0) {
  init();
  $cmd = $args[0];
  if ($cmd eq 'import') { import($args[1]); writext($args[1]); }
  else { info("unknown command"); }
}
