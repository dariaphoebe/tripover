#!/usr/bin/perl -W

# gtfstool - handle gtfs feeds

# This file is part of Tripover, a broad-search journey planner.

#  Copyright (C) 2014 Joris van der Geer.

#  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
#  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/

# primary use is to import gtfs feeds into tripover format.
# feeds can be merged, filtered, or verified
# optional export from tripover format to gtfs

use 5.008;
use strict;

# stop at compile-time warnings
my $ccmsg = '';
local $SIG{__WARN__} = sub { print "$ccmsg $_[0]"; exit 1;  };

my $version_maj = 0;
my $version_min = 16;
my $lastchanged = "15 dec 2014";

my $copyright = "Copyright (C) 2014, and Creative Commons CC-by-nc-nd'd by Joris van der Geer";

my $license = "This work is licensed under the Creative Commons\n" .
  "Attribution-NonCommercial-NoDerivatives 4.0 International License.\n" .
  "To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.\n";

my $verbose = 0;
my $dryrun = 0;

my $anaout = 0;
my $anadir = '.';

my $canonout = 0;
my $canondir = '.';

my $warningcnt = 0;
my $errorcnt = 0;

my $verbose_hops = 1;

my $merge_dup_parent = 0;  # merge if lat,lon,name identical: nl
my $infer_parent = 0;   # infer parent when seemingly missing : seq
my $infer_limit = 0.25;

my $watchfile = 'watches.cfg';
my $gtfscfgfile = 'gtfsfeed.cfg';

my %stops2watch = ('600484','glasshouse mtn','94414','innsbruck','stoparea:30398','innsbruck sta' );
my %rsids2watch;

my $logname = 'gtfstool.log';
my $logfd;

if (-t STDOUT) {
  rename($logname,$logname . '.0') if -f $logname;
  open($logfd,'>',$logname) or print("cannot create $logname:$!");
}

# unbuffered i/o
my $orgfh = select STDOUT; $| = 1; select STDERR; $| = 1; select $orgfh;

sub basemsg($) {
  my ($m) = @_;

  print("$m\n");
  print($logfd "$m\n") if defined $logfd;
  return 1;
}

sub msg($) {
  my ($m) = @_;

  my $t = time2yyyymmdd(time(),1,'sec');
  my $tt = substr($t,11);  # only from hh in yyyy-mm-dd hh:mm:ss

  my ($package,$filename,$line,$sub,$hasargs) = caller(1);
  my $fln = sprintf("%4u",$line);
  my $clron = sprintf('%c[0;32m',27);
  my $clrof = sprintf('%c[0m',27);
  print("$clron$tt $fln $clrof$m\n");
  print($logfd "$t $fln $m\n") if defined $logfd;
  return 1;
}

sub info($) { return msg($_[0]); }

sub progress($$$) {
  my ($fmt,$a,$b) = @_;

  my $perc = ($a * 100) / $b;
  printf($fmt . " %.0f %%\r",$a,$b,$perc);
}

sub dinfo($) {
  my ($package,$filename,$line,$sub,$hasargs) = caller(0);
  return msg($_[0] . " fn $sub ln $line");
}

sub warning($) {
  my ($package,$filename,$line,$sub,$hasargs) = caller(0);
  msg("warning: " . $_[0] . "  at fn $sub.$line");
  $warningcnt++;
  return 1;
}

sub error($$) {
  msg("error: " . $_[0] . " at " . $_[1]);
  $errorcnt++;
  return 0;
}

sub error_exit($$) { error($_[0],$_[1]); exit 1; }

sub vrb($) {
  $ccmsg = $_[0] . "\n";
  msg($_[0]) if $verbose;
  return 1;
}

sub max($$) {
  my ($a,$b) = @_;
  return ($a > $b ? $a : $b);
}
sub min($$) {
  my ($a,$b) = @_;
  return ($a < $b ? $a : $b);
}

sub trimws($) {
  my ($s) = @_;
  $s =~ s/[ \t\r\n]+/ /g;
  $s =~ s/^ //;
  $s =~ s/ $//;
  return $s;
}

sub time2yyyymmdd($$$) {
  my ($nixsec,$local,$res) = @_;

  my ($fmt,$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);

  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = ($local ? localtime($nixsec) : gmtime($nixsec));
  return sprintf('%04u-%02u-%02u %02u:%02u:%02u',($year + 1900,$mon + 1,$mday,$hour,$min,$sec)) if $res eq 'sec';
  return sprintf('%04u-%02u-%02u %02u:%02u',($year + 1900,$mon + 1,$mday,$hour,$min)) if $res eq 'min';
  return sprintf('%04u-%02u-%02u %02u:%02u',($year + 1900,$mon + 1,$mday));
}

sub usage()
{
  my $m = "usage: gtfstool [options] [cmd]\n\n";
  $m .= "options:\n";
  $m .= "-v -verbose        verbose mode\n";
  $m .= "-n -dryrun         dryrun mode\n";
  $m .= "-h -help           show help and quit\n";
  $m .= "-a -analysis       enable analysis output\n";
  $m .= "-c -canonical      enable canonical output\n";
  $m .= "-V -version        show version and quit\n";
  $m .= "-L -license        show license and quit\n\n";
  $m .= "commands:\n\n";

  $m .= "import <indir> [outdir] import gtfs into tripover";
  basemsg($m);
}

# these are written as options to ext output
my $rtype_walk = 1699;
my $maxvariant = 16;
my $hivariant = 0;

my $dowstart = 'monday';

my $fmt_prvsid = 1;
my $fmt_diftid = 2;
my $fmt_difdep = 4;
my $fmt_difarr = 8;

# use integer codes for fields
my $col_enum = 1;
my $col_stopid    = $col_enum++;
my $col_stopcode  = $col_enum++;
my $col_stopname  = $col_enum++;
my $col_stopdesc  = $col_enum++;
my $col_stoplat   = $col_enum++;
my $col_stoplon   = $col_enum++;
my $col_zoneid    = $col_enum++;
my $col_stopurl   = $col_enum++;
my $col_loctype   = $col_enum++;
my $col_parent    = $col_enum++;
my $col_platform  = $col_enum++;

my $col_monday    = $col_enum++;
my $col_tuesday   = $col_enum++;
my $col_wednesday = $col_enum++;
my $col_thursday  = $col_enum++;
my $col_friday    = $col_enum++;
my $col_saturday  = $col_enum++;
my $col_sunday    = $col_enum++;

my $col_startdate = $col_enum++;
my $col_enddate   = $col_enum++;

my $col_date      = $col_enum++;
my $col_extype    = $col_enum++;

my $col_tripid    = $col_enum++;
my $col_headsign  = $col_enum++;
my $col_direction = $col_enum++;
my $col_arrtime   = $col_enum++;
my $col_deptime   = $col_enum++;
my $col_stopseq   = $col_enum++;
my $col_picktype  = $col_enum++;
my $col_droptype  = $col_enum++;

my $col_routeid   = $col_enum++;
my $col_routesname = $col_enum++;
my $col_routelname = $col_enum++;
my $col_routedesc = $col_enum++;
my $col_routetype = $col_enum++;

my $col_serviceid = $col_enum++;

my $col_unknown = $col_enum++;

my $opt_childstop = 1;
my $opt_parentstop = 2;
my $opt_inferred = 4;

# store field results here
my $utcofs12 = 1000 + 1200;

my $agencyname;
my $feedpublisher = '';

my @agencies;

my %stopids;
my %stop_ids;

my %stops2ignore;

my %stopnames;

my %stops;

my @stopdeps;
my @stoparrs;

my %parents;
my %parentids;
my %parent_ids;
my %parentbyid;
my $parentcnt = 0;
my $parentdupcnt = 0;

my %uniparents;
my %parentdups;

my %serviceids;
my %noserviceids;
my %servicedow;
my %servicet0;
my %servicet1;
my %serviceadd;
my %servicesub;
my $sidcnt = 0;
my %sidrefs;
my %sids2ignore;

my %tripids;
my %tripseq;
my %tripseq1;
my %trippseq;
my %tripref;
my $hitripid;
my @uniqids;

my %triproutes;
my %tripsids;
my $walkroute;

my @trips;

my %tripservice;

my @hops;

my @routes;
my %routeids;
my %norouteids;
my %routebyids;
my %rtypes;

my %uniqhops;

my $sumtimes = 0;

my @trip_ids;
my @dep_times;
my @arr_times;

my $stopcnt = 0;
my $ttcnt = 0;
my $hopcnt = 0;
my $tripcnt = 0;
my $routecnt = 0;
my $noroutecnt = 0;

# overall date range : coded decimal localtime yyyymmdd 
my $mint0 = 20200101;
my $maxt1 = 0;

my $nondigits = qr'[^0-9]';

my $unquoter = qr'/""/"/g';

sub inarray($@) {
  my ($a,@arr) = @_;

  foreach my $b (@arr) { return 1 if $a eq $b; }
  return 0;
}

sub showvers($)
{
  my ($full) = @_;

  basemsg("Tripover gtfs tool version $version_maj.$version_min");
  basemsg("last changed $lastchanged") if $full; 
  basemsg("$copyright\n");
}

sub rdwatches()
{
  my ($fh,$line,$linno);
  my ($var,$val,$fmt);

  info("inspecting $watchfile");
  return unless -r $watchfile and -s $watchfile;

  open($fh,"<",$watchfile) or return warning("cannot open $watchfile: $!");

  my $varxval = qr?^([a-z_.]+)\s+([x,\*])([0-9a-f]*)?;

  $linno = 0;
  while($line = readline $fh) {
    $linno++;
    next if index($line,'#') == 0;
    next if length $line < 2;
    ($var,$fmt,$val) = ($line =~ $varxval);
    next unless defined $var and defined $fmt;

    info("$var $fmt $val");

    if ($fmt eq 'x' and defined $val) { $val = hex($val); }
    elsif ($fmt eq '*') { $val = '*'; }
    elsif ($fmt eq  ',') { }

    printf("%s %x.%u\n",$var,$val,$val) unless $fmt eq '*';
    $rsids2watch{$val} = 1 if $var eq 'rsid';
  }
}

# one file with a config section per agency.
# once agency is known, load and apply the relevant section
#
# ignore-stop
# ignore-service
# infer-parent
# merge-x
#
sub rdgtfscfg($$)
{
  my ($name1,$name2) = @_;

  my ($fh,$line,$linno);
  my ($var,$val,$varlen,$sec,$arg,$args,$rest);

  info("inspecting $gtfscfgfile for '$name1' or '$name2'");
  return unless -r $gtfscfgfile and -s $gtfscfgfile;

  open($fh,"<",$gtfscfgfile) or return warning("cannot open $gtfscfgfile: $!");

  my $secpat = qr?^=([-_.A-Za-z\s0-9]+)=?;
  my $varpat = qr?^([-a-z_.]+)?;
  my $arg1pat = qr?^\s+([-_./0-9a-zA-Z]+)(.*)?;

  my $state = 0;

  $linno = 0;
  while($line = readline $fh) {
    $linno++;
    $line = trimws($line);
    next if index($line,'#') == 0;
    next if length $line < 2;

    if ($state == 0) {
      ($sec) = ($line =~ $secpat);
      next unless defined $sec and ($sec eq $name1 or $sec eq $name2);
      info("config section for $sec starts at line $linno");
      $state = 1;
    } elsif ($state == 1) {
      last if (substr($line,0,1) eq '='); # next section

      ($var) = ($line =~ $varpat);
      next unless defined $var and length($var) > 0;
      $varlen = length($var);
      $args = substr($line,$varlen);
      $args = '' unless defined $args;
      if ($var eq 'description' and length $args) {
        info("$args");
      } elsif ($var eq 'ignore-stop') {
        ($arg,$rest) = ($args =~ $arg1pat);
        next unless defined $arg and length($arg) > 0;
        $rest = '(no description)' unless defined $rest;
        info("ignore stop $arg $rest");
        $stops2ignore{$arg} = "$gtfscfgfile:$linno $rest";
      } elsif ($var eq 'ignore-service') {
        ($arg,$rest) = ($args =~ $arg1pat);
        next unless defined $arg and length($arg) > 0;
        $rest = '(no description)' unless defined $rest;
        info("ignore service $arg $rest");
        $sids2ignore{$arg} = "$gtfscfgfile:$linno $rest";
      } elsif ($var eq 'merge-duplicate-stations') {
        $merge_dup_parent = 1;
        info("merging duplicate stations if name,lat,lon equal $args");
      } elsif ($var eq 'infer-common-station') {
        $infer_parent = 1;
        info("infer common parent station if name,lat,lon almost equal $args");
      } else { info("line $linno: skip unknown var '$var'"); }
    }
  }
  info("no section for '$name1' or '$name2' in $gtfscfgfile") if $state == 0;
  info('');
}

sub init()
{
  rdwatches() if $anaout;
}

sub readagency($)
{
  my ($dir) = @_;

  my ($agency,$agencyfname);
  my ($col,$colname,$line);
  my ($col_id,$col_name,$col_tz);

  return error("missing dir arg for import",__LINE__) unless defined $dir and length($dir);

  $agencyfname = $dir . '/' . 'agency.txt';

  return error("required $agencyfname not present",__LINE__) unless -f $agencyfname;
  return error("required $agencyfname is empty",__LINE__) unless -s $agencyfname;

  info("reading $agencyfname");
  return info("dryrun") if $dryrun;

  open($agency,'<:encoding(UTF-8)',$agencyfname) or return error("cannot open $agencyfname:$!",__LINE__);
  my $headline = readline($agency);
  return error("$agencyfname",__LINE__) unless defined $headline and length($headline);
  $headline = trimws($headline);

  my @colnames = split(',',$headline);
  my @cols;
  my $colid = 0;

  foreach $colname (@colnames) {
    $col_id = $colid++ if ($colname eq 'agency_id');
    $col_name = $colid++ if ($colname eq 'agency_name');
    $col_tz = $colid++ if ($colname eq 'agency_timezone');
  }

  my @lines = readline($agency);
  close($agency);
  error_exit("$agencyfname is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  my ($id,$name,$tzstr);

  info("$linecnt lines") if $linecnt > 1;

  $linno = 0;
  foreach $line (@lines) {

    $linno++;
    @cols = split ',',trimws($line);

    $id = $name = $tzstr = '';

    $id = $cols[$col_id] if defined $col_id;
    $name = $cols[$col_name] if defined $col_name;
    $tzstr = $cols[$col_tz] if defined $col_tz;

    $agencyname = $name unless defined $agencyname;  # todo: use first one as overall feed ID

    push @agencies,join("\t",$id,$name,$tzstr);
  }
  info("Agency: '$agencyname'") if $linecnt == 1;
  return 1;
}

sub readfeedinfo($)
{
  my ($dir) = @_;

  my ($file,$fname);
  my ($col,$colname,$line);
  my ($col_id,$col_name,$col_tz);

  return error("missing dir arg for import",__LINE__) unless defined $dir and length($dir);

  $fname = $dir . '/' . 'feed_info.txt';

  return info("optional $fname not present") unless -f $fname;
  return info("optional $fname is empty") unless -s $fname;

  info("reading $fname");
  return info("dryrun") if $dryrun;

  open($file,'<:encoding(UTF-8)',$fname) or return error("cannot open $fname:$!",__LINE__);
  my $headline = readline($file);
  unless (defined $headline and length($headline)) {
    close($file);
    return warning("$fname is empty");
  }
  $headline = trimws($headline);

  my @colnames = split(',',$headline);
  my @cols;
  my $colid = 0;

  foreach $colname (@colnames) {
    $col_name = $colid++ if ($colname eq 'feed_publisher_name');
    $col_id = $colid++ if ($colname eq 'feed_id');
  }

  my @lines = readline($file);
  close($file);
  return warning ("$fname is empty") unless (@lines > 0);

  my $linecnt = scalar(@lines);

  info("$fname has $linecnt entries, reading first entry only") if $linecnt > 1;

  my $id = '';
  my $name = '';

  $line = $lines[0];

  @cols = split ',',trimws($line);

  $id = $cols[$col_id] if defined $col_id;
  $name = $cols[$col_name] if defined $col_name;

  $feedpublisher = $name;

  return 1;
}

my $latscale = 1000000;
my $lonscale = 1000000;
my $pi = 3.141592655;

# todo autoscale on bbox and have tripover read bbox+scale
sub str2lat($$)
{
  my ($lat,$linno) = @_;

  my ($ilat);

  $ilat = ($lat + 90) * $latscale;
  return int($ilat);
}

sub str2lon($$)
{
  my ($lon,$linno) = @_;

  my ($ilon);

  $ilon = ($lon + 180) * $lonscale;
  return int($ilon);
}

my $geolow = $pi * 1.0e-4;
my $mean_earth_radius = 6371.0;

sub geodist($$$$)
{
  my ($slat,$slon,$lat,$lon) = @_;

  my $dist;
  my $srlat = ($slat * $pi) / 180;
  my $srlon = ($slon * $pi) / 180;
  my $rlat = ($lat * $pi) / 180;
  my $rlon = ($lon * $pi) / 180;

  my $dlon = $srlon - $rlon;
  my $dlat = $srlat - $rlat;

  if (abs($dlon) < $geolow and abs($dlat) < $geolow) { # trivial case: assume flat
    $dlat = ($dlat * $mean_earth_radius * 2) / $pi;
    $dlon = ($dlon * $mean_earth_radius * 2) / $pi;
    $dist = sqrt( ($dlat * $dlat) + ($dlon * $dlon));
#    info("geodist $dist");
    return $dist;
  }
# info("geodist $dlon $dlat");
  return 1000;
}

sub readstops($)
{
  my ($dir) = @_;

  my ($stopfile,$stopsname,$anafile,$canonfile);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req,$val);
  my ($id,$stopid,$code,$name,$desc,$lat,$lon,$zone_id,$url,$loctype,$parent,$platform,$opt);
  my ($uniparent,$parent1,$isparent,$hasparent,$newparent,$newparentid);
  my ($ilat,$ilon);
  my ($simlst,$simstr,$simstop,$stopstr);
  my ($slat,$slon,$dist,$nearby);
  my (%similar,%simlats,%simlons);
  my @sims;

  return error("missing dir arg for import",__LINE__) unless defined $dir and length($dir);

  $stopsname = $dir . '/' . 'stops.txt';

  info("reading $stopsname");
  return info("dryrun") if $dryrun;

  open($stopfile,'<:encoding(UTF-8)',$stopsname) or return error("cannot open stops.txt:$!",__LINE__);
  my $headline = readline($stopfile);
  error_exit("stops.txt is empty",__LINE__) unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

  vrb("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_stopid if ($colname eq 'stop_id');
    $colid = $col_stopcode if ($colname eq 'stop_code');
    $colid = $col_stopname if ($colname eq 'stop_name');
    $colid = $col_stopdesc if ($colname eq 'stop_desc');
    $colid = $col_stoplat if ($colname eq 'stop_lat');
    $colid = $col_stoplon if ($colname eq 'stop_lon');
    $colid = $col_zoneid if ($colname eq 'zone_id');
    $colid = $col_stopurl if ($colname eq 'stop_url');
    $colid = $col_loctype if ($colname eq 'location_type');
    $colid = $col_parent if ($colname eq 'parent_station');
    $colid = $col_platform if ($colname eq 'platform_code');
    push(@cols,$colid);
  }
#  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  error_exit("unknown fields",__LINE__) if (@cols < @colnames);

  foreach $req ('stop_id','stop_name','stop_lat','stop_lon') {
    error_exit("missing required $req",__LINE__) unless inarray($req,@colnames);
  }

  my @lines = readline($stopfile);
  close($stopfile);
  error_exit("stops.txt is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  my $filtercnt = 0;
  my $infercnt = 0;
  my $instopcnt = 0;
  my $childstopcnt = 0;

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $line .= ',';

    $linno++;

    $id = ''; $code = ''; $name = ''; $lat = ''; $lon = '';
    $loctype = ''; $parent = ''; $platform = ''; $desc = '';

    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;
      $val = trimws(substr($line,0,$comma));

      if ($col == $col_stopid) {
        $id = substr($line,0,$comma);

      } elsif ($col == $col_stopcode) {
        $code = $val;

      } elsif ($col == $col_stopname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote",__LINE__) if $endq < 0;
          $name = substr($line,0,$endq);
          $name =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,",__LINE__) if $comma < 0;

        } else { # unquoted
          $name = substr($line,0,$comma);
        }

      } elsif ($col == $col_stopdesc) {
        if (substr($line,0,1) eq '"') {
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote",__LINE__) if $endq < 0;
          $desc = substr($line,0,$endq);
          $desc =~ $unquoter;
          $line = substr($line,$endq+1);
          $comma = index($line,',');
          error_exit("line $linno: missing ,",__LINE__) if $comma < 0;

        } else {
          $desc = substr($line,0,$comma);
        }

      } elsif ($col == $col_stoplat) {
        $lat = $val;

      } elsif ($col == $col_stoplon) {
        $lon = $val;

      } elsif ($col == $col_parent) {
        $parent = $val;

      } elsif ($col == $col_platform) {
        $platform = $val;

      } elsif ($col == $col_loctype) {
        $loctype = $val;
      }

      $line = substr($line,$comma+1);

    } # each col

    $instopcnt++;

    # ID may be integer or string. must be unique in set
    # tripover needs an integer : use line number as derived id
    if (exists($stopids{$id})) {
      warning("$linno: stop id $id already defined on line $stopids{$id}");
      $filtercnt++;
      next;
    } elsif (defined $stops2ignore{$id}) {
      info("$linno: filter stop id $id : $stops2ignore{$id}");
      $filtercnt++;
      next;
    } else {
      $stopid = $linno;
      $stopids{$id} = $stopid;
      $stop_ids{$stopid} = $id;
      $stopdeps[$stopid] = 0;
      $stoparrs[$stopid] = 0;
    }

    warning("$id has empty lon") if length($lon) < 1;
    warning("$id has empty lat") if length($lat) < 1;
    $ilat = str2lat($lat,$linno);
    $ilon = str2lon($lon,$linno);

    warning("$id has empty lat") unless defined $ilat;

    $desc = ' ' unless length($desc);
    $code = ' ' unless length($code);

    $stopnames{$stopid} = $name;

    $isparent = 0;
    if (length($loctype) == 1) {
      if ($loctype eq '1') { $isparent = 1; }
      elsif ($loctype eq '0') { $isparent = 0; }
      else { warning("$linno: stop $name has unknown location type $loctype"); }
    }

    $hasparent = (length($parent) > 0);
    if ($hasparent and $isparent) {
      warning("$linno: parent stop $name has parent $parent");
      $hasparent = 0;
    }

    $simlats{$stopid} = $lat;
    $simlons{$stopid} = $lon;

    if ($infer_parent and not $isparent and not $hasparent and length($name) > 3) {
      $simstr = sprintf("%u_%u",$ilat / 5000,$ilon / 5000);
      if (exists($similar{$simstr})) {
        info("check $simstr for $id") if $name eq 'Gold Coast Airport';
        ($simstop) = split('_',$similar{$simstr});
        $slat = $simlats{$simstop};
        $slon = $simlons{$simstop};
        warning("nil lat for $simstop") unless defined $slat;
        warning("nil lat for $stopid") unless defined $lat;
        $dist = geodist($slat,$slon,$lat,$lon);
        info("$dist for $slat $slon $lat $lon") if $name eq 'Gold Coast Airport';
        if ($dist < $infer_limit) {
          $similar{$simstr} .= '_' . $stopid;
        } else {
          info("$name not nearby $similar{$simstr} $dist") if $name eq 'Gold Coast Airport';
        }
      } else {
        $similar{$simstr} = $stopid;
      }
    }

    # use external id, as parent ids can refer forward
    if ($merge_dup_parent) {
      if ($isparent) {
        error_exit("duplicate parent id $stopid, first defined at line $parentids{$id}",__LINE__) if exists $parentids{$id};
        $uniparent = $name . $lat . $lon;
        if (exists $uniparents{$uniparent}) {
          $parent = $uniparents{$uniparent};
          $parentdups{$id} = $parent;
          info("dup parent $parent for $id");
          $parentdupcnt++;
          next;
        } else { $uniparents{$uniparent} = $id; }
      } elsif ($hasparent) {
        if (exists $parentdups{$parent}) {
          $parent1 = $parentdups{$parent};
          info("dup parent $parent to $parent1 for stop $id");
          $parent = $parent1;
        }
      }
    }

    if ($isparent) {
      vrb("station $name as $id code $code");
      $parentids{$id} = $stopid;
      $parent_ids{$stopid} = $id;
      $parentcnt++;
      $opt = $opt_parentstop;
    } elsif ($hasparent) {  # refers to id above
      $opt = $opt_childstop;
      $parents{$parent} .= $stopid . ' ';
      $parentbyid{$stopid} = $parent;
    } else { $opt = 0; }

    error_exit("no stop code at line $linno",__LINE__) unless defined $code;

    error_exit("no id at line $linno",__LINE__) unless defined $id;
    error_exit("no parent at line $linno",__LINE__) unless defined $parent;

    $stops{$stopid} = join("\t",$name,$id,$parent,$ilat,$ilon,$code,$desc,$opt);
  }

  my ($simname,$simdiff);

  $stopcnt = scalar(keys %stops);
  $infercnt = 0;
  while ( ($simstr,$simlst) = each %similar) {
    @sims = split('_',$simlst);
    next unless @sims > 1;
    $infercnt++;
    $newparentid = $infercnt + $stopcnt;
    $newparent = join('_','inferred',$newparentid,$simstr);

    $parentids{$newparent} = $newparentid;
    $parent_ids{$newparentid} = $newparent;

    $stopnames{$newparentid} = $newparent;
    $stopids{$newparent} = $newparentid;
    $stop_ids{$newparentid} = $id;
    $stopdeps[$newparentid] = 0;
    $stoparrs[$newparentid] = 0;

    $simstop = $sims[0];
    $simname = $stopnames{$simstop};
    $slat = $simlats{$simstop};
    $slon = $simlons{$simstop};

    $simdiff = 0;
    foreach $stopid (@sims) {
      $name = $stopnames{$stopid};
      $simdiff++ if $name ne $simname;
    }
    info("infer common parent $infercnt $simname on $simstr") if $simdiff;

    foreach $stopid (@sims) {
      $name = $stopnames{$stopid};
      $lat = $simlats{$stopid};
      $lon = $simlons{$stopid};
      $dist = geodist($slat,$slon,$lat,$lon);
      if ($simdiff) {
        info("  $name dist $dist id $stopid"); $simdiff++;
      }
      $parents{$newparent} .= $stopid . ' ';
      $parentbyid{$stopid} = $newparent;
      $stopstr = $stops{$stopid};
      ($name,$id,$parent,$ilat,$ilon,$code,$desc,$opt) = split("\t",$stopstr);
      $stops{$stopid} = join("\t",$name,$id,$newparent,$ilat,$ilon,$code,$desc . ' infer',$opt_childstop);
    }
    $stops{$newparentid} = join("\t",$name . '-parentsta',$newparent,'',$ilat,$ilon,$code,$desc . ' infer',$opt_parentstop);
  }
  $parentcnt += $infercnt;
  $stopcnt += $infercnt;

  foreach $stopid (keys %stops) {
    $childstopcnt++ if exists $parentbyid{$stopid};
  }

  my $mline = "$stopcnt from $instopcnt stops";
  $mline .= " $parentcnt stations" if $parentcnt;
  $mline .= " $infercnt inferred" if $infercnt;
  $mline .= " $parentdupcnt merged" if $parentdupcnt;
  $mline .= " $filtercnt filtered" if $filtercnt;
  info($mline);
  my $outstopcnt = $stopcnt - $childstopcnt;
  info("$childstopcnt station members $outstopcnt total planning stops");

  return 1 unless $canonout;

  open($canonfile,'>',$canondir . '/stops.txt') or return 0;
  print($canonfile "stop_id,location_type,parent_station,stop_name,stop_lat,stop_lon,stop_desc\n");
  while (($stopid,$stopstr) = each %stops) {
    ($name,$id,$parent,$lat,$lon,$code,$desc,$opt) = split("\t",$stopstr);
    $loctype = ($opt == $opt_parentstop) ? 1 : 0;
    print($canonfile join(',',$id,$loctype,$parent,$name,$lat,$lon,'*desc*'));
    print($canonfile "\n");
  }
  close($canonfile);
  return 1;
}

my $include_tram = 1;
my $include_metro = 1;
my $include_rail = 1;
my $include_bus = 1;
my $include_ferry = 1;

sub filtermode($)
{
  my ($type) = @_;

  return 1 if ($type == 0 and $include_tram == 1);
  return 1 if ($type == 1 and $include_metro == 1);
  return 1 if ($type == 2 and $include_rail == 1);
  return 1 if ($type == 3 and $include_bus == 1);
  return 1 if ($type == 4 and $include_ferry == 1);
  return 0;
}

sub readroutes($)
{
  my ($dir) = @_;

  my ($routefile,$routefname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$routeid1,$name,$slname,$rtype);

  $routefname = $dir . '/' . 'routes.txt';

  info("reading $routefname");
  return info("dryrun") if $dryrun;

  open($routefile,'<',$routefname) or return error("cannot open routes.txt:$!",__LINE__);
  my $headline = readline($routefile);
  error_exit("routes.txt is empty",__LINE__) unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

#  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_routeid if ($colname eq 'route_id');
    $colid = $col_routesname if ($colname eq 'route_short_name');
    $colid = $col_routelname if ($colname eq 'route_long_name');
    $colid = $col_routedesc if ($colname eq 'route_desc');
    $colid = $col_routetype if ($colname eq 'route_type');
    push(@cols,$colid);
  }
#  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  error_exit("missing required route name",__LINE__) unless inarray('route_short_name',@colnames) or inarray('route_long_name',@colnames);

  foreach $req ('route_id','route_type') {
    error_exit("missing required $req",__LINE__) unless inarray($req,@colnames);
  }

  my @lines = readline($routefile);
  close($routefile);
  error_exit("routes.txt is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';
    $name = ''; $slname = ''; $route_id = ''; $rtype = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_routeid) {
        $route_id = substr($line,0,$comma);

      } elsif ($col == $col_routesname or $col == $col_routelname) {
        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote",__LINE__) if $endq < 0;
          $name = substr($line,0,$endq);
          $name =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,",__LINE__) if $comma < 0;

        } else { # unquoted
          $name = substr($line,0,$comma);
        }
        $slname = $name if length($name);

      } elsif ($col == $col_routetype) {
        $rtype = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    vrb("$linno $route_id '$slname' $rtype");
    $routeid = $linno * $maxvariant;    # possible alternatives
    $routeid = $routeid * 2;  # even ID for outbound, next odd ID for inbond
    $routeid1 = $routeid + 1;

    if (exists($routeids{$route_id})) {
      warning("$linno: route id $route_id already defined on line $routeids{$route_id}");
      next;
    }

    $routebyids{$routeid} = $route_id;
    $routebyids{$routeid1} = $route_id;
    $rtypes{$routeid} = $rtype;
    $rtypes{$routeid1} = $rtype;
    $routeids{$route_id} = $routeid;

    if (filtermode($rtype)) {
      push(@routes,join("\t",$route_id,$slname,$rtype));
    } else {
      $noroutecnt++;
      info("filter route $route_id mode $rtype at line $linno");
      $norouteids{$route_id} = $routeid;
    }

  } # each line

  $linno++;

  $route_id = 'walk';
  $walkroute = $linno * $maxvariant * 2;
  $rtype = $rtype_walk;
  $slname = 'walk inferred from parent station';
  $routeids{$route_id} = $walkroute;
  $routebyids{$walkroute} = $route_id;
  $rtypes{$walkroute} = $rtype;
  push(@routes,join("\t",$route_id,$slname,$rtype));

  info("add inferred walk route $walkroute as type $rtype");
  $routecnt = scalar(@routes);
  info("$routecnt routes, $noroutecnt filtered out");

  return 1;
}

sub readtrips($)
{
  my ($dir) = @_;

  my ($tripfile,$tripfname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($route_id,$routeid,$trip_id,$service_id,$headsign,$dirid);

  $tripfname = $dir . '/' . 'trips.txt';

  info("reading $tripfname");
  return info("dryrun") if $dryrun;

  open($tripfile,'<',$tripfname) or return error("cannot open trips.txt:$!",__LINE__);
  my $headline = readline($tripfile);
  error_exit("trips.txt is empty",__LINE__) unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

#  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_routeid if ($colname eq 'route_id');
    $colid = $col_serviceid if ($colname eq 'service_id');
    $colid = $col_tripid if ($colname eq 'trip_id');
    $colid = $col_headsign if ($colname eq 'trip_headsign');
    $colid = $col_direction if ($colname eq 'direction_id');
    push(@cols,$colid);
  }
#  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  foreach $req ('route_id','service_id','trip_id') {
    error_exit("missing required $req",__LINE__) unless inarray($req,@colnames);
  }

  my @lines = readline($tripfile);
  close($tripfile);
  error_exit("trips.txt is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';

    $trip_id = ''; $route_id = ''; $service_id = ''; $dirid = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_routeid) {
        $route_id = substr($line,0,$comma);
      } elsif ($col == $col_serviceid) {
        $service_id = substr($line,0,$comma);
      } elsif ($col == $col_tripid) {
        $trip_id = substr($line,0,$comma);
      } elsif ($col == $col_headsign) {

        if (substr($line,0,1) eq '"') { # quoted
          $line = substr($line,1);
          $endq = index($line,'"');
          error_exit("line $linno: missing endquote",__LINE__) if $endq < 0;
          $headsign = substr($line,0,$endq);
          $headsign =~ $unquoter;
          $line = substr($line,$endq+1);

          $comma = index($line,',');
          error_exit("line $linno: missing ,",__LINE__) if $comma < 0;

        } else { # unquoted
          $headsign = substr($line,0,$comma);
        }

      } elsif ($col == $col_direction) {
        $dirid = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    if (length($trip_id) == 0) {
      warning("$linno: missing trip id for route  $route_id");
      next;
    }
    if (exists($tripids{$trip_id})) {
      warning("$linno: trip id $trip_id previously defined on line $tripids{$trip_id}");
      next;
    }
    if ($dirid ne '0' and $dirid ne '1') {
      warning("$linno: trip id $trip_id head $headsign direction $dirid not 0 or 1");
      next;
    }

    $tripids{$trip_id} = $linno;
    $hitripid = $linno;

    $routeid = $routeids{$route_id} + $dirid;
#    info("route $route_id id $routeid");
    $triproutes{$trip_id} = $routeid;

    if (exists($norouteids{$route_id})) {  # filtered
    } elsif (exists($routeids{$route_id})) {
      push(@trips,join("\t",$routeid,$service_id,$trip_id,$dirid));
      $tripservice{$trip_id} = $service_id;
    } else {
      warning("$linno: undefined route id $route_id");
    }

  } # each line

  $tripcnt = scalar(@trips);

  info("$tripcnt trips highest Id $hitripid");

  return 1;
}

sub readcalendar($)
{
  my ($dir) = @_;

  my ($calfile,$calfname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($service_id,$sid,$t0,$t1,$day,$dayno,$dows,$dow);
  my $filtercnt = 0;
  my @dow;

  $calfname = $dir . '/' . 'calendar.txt';

  info("reading $calfname");
  return info("dryrun") if $dryrun;

  open($calfile,'<',$calfname) or return info("no $calfname");
  my $headline = readline($calfile);
  error_exit("$calfname is empty",__LINE__) unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

#  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_serviceid if ($colname eq 'service_id');
    $colid = $col_monday if ($colname eq 'monday');
    $colid = $col_tuesday if ($colname eq 'tuesday');
    $colid = $col_wednesday if ($colname eq 'wednesday');
    $colid = $col_thursday if ($colname eq 'thursday');
    $colid = $col_friday if ($colname eq 'friday');
    $colid = $col_saturday if ($colname eq 'saturday');
    $colid = $col_sunday if ($colname eq 'sunday');
    $colid = $col_startdate if ($colname eq 'start_date');
    $colid = $col_enddate if ($colname eq 'end_date');
    push(@cols,$colid);
  }
#  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  foreach $req ('service_id','monday','tuesday','wednesday','thursday','friday','saturday','sunday','start_date','end_date') {
    error_exit("missing required $req",__LINE__) unless inarray($req,@colnames);
  }

  my @lines = readline($calfile);
  close($calfile);
  error_exit("$calfname is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;
  my $analines = '';

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';

    $service_id = ''; $t0 = ''; $t1 = '';
    $dow[0] = $dow[1] = $dow[2] = $dow[3] = $dow[4] = $dow[5] = $dow[6] = 0;
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_serviceid) {
        $service_id = substr($line,0,$comma);
      } elsif ($col == $col_monday) {
        $dow[6] = substr($line,0,$comma);
      } elsif ($col == $col_tuesday) {
        $dow[5] = substr($line,0,$comma);
      } elsif ($col == $col_wednesday) {
        $dow[4] = substr($line,0,$comma);
      } elsif ($col == $col_thursday) {
        $dow[3] = substr($line,0,$comma);
      } elsif ($col == $col_friday) {
        $dow[2] = substr($line,0,$comma);
      } elsif ($col == $col_saturday) {
        $dow[1] = substr($line,0,$comma);
      } elsif ($col == $col_sunday) {
        $dow[0] = substr($line,0,$comma);

      } elsif ($col == $col_startdate) {
        $t0 = substr($line,0,$comma);
      } elsif ($col == $col_enddate) {
        $t1 = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    if (length($service_id) == 0) {
      warning("$linno: missing service id");
      next;
    } elsif (exists($serviceids{$service_id})) {
      warning("$linno: service id $service_id previously defined on line $serviceids{$service_id}");
      $filtercnt++;
      next;
    } elsif (exists($sids2ignore{$service_id})) {
      $noserviceids{$service_id} = $linno;
      info("$linno: filter service id $service_id : $sids2ignore{$service_id}");
      $filtercnt++;
      next;
    }
    $dows = '..............'; $dow = 0; $dayno = 0;
    for $dayno (0 .. 6) {
      $day = $dow[$dayno];
      return error("$linno: $day not 0 or 1",__LINE__) if $day ne '0' and $day ne '1';
      $dow <<= 1;
      if ($day) {
        $dow |= 1;
        substr($dows,(6 - $dayno) * 2,2,substr('SuSaFrThWeTuMo',$dayno * 2,2));
      }
    }

    warning("$linno: end time $t1 before start time $t0") if $t1 < $t0;

    $sid = $linno;
    $serviceids{$service_id} = $sid;
    $servicedow{$sid} = $dow;
    $servicet0{$sid} = $t0;
    $servicet1{$sid} = $t1;
    $serviceadd{$sid} = [()];
    $servicesub{$sid} = [()];
    $mint0 = min($t0,$mint0);
    $maxt1 = max($t1,$maxt1);

    if (defined $rsids2watch{$sid} or defined $rsids2watch{'*'}) {
      $analines .= sprintf("rsid %02x.%02u: $t0 .. $t1 at $dows %x '$service_id'\n",$sid,$sid,$dow);
    }
  } # each line

# dummy for unknown
  $servicedow{0} = 0x7f;
  $servicet0{0} = $mint0;
  $servicet1{0} = $maxt1;

  $sidcnt = scalar(keys %serviceids);
  info("$sidcnt services $filtercnt filtered, overall period $mint0 to $maxt1");

  return 1 unless length $analines;

  my $anafile;
  open($anafile,'>',$anadir . '/rsids.log') or return 1;
  print($anafile $analines);
  close($anafile);

  return 1;
}

sub readcaldates($)
{
  my ($dir) = @_;

  my ($calfile,$calfname);
  my ($col,$colid,$colname,$line,$comma,$endq,$c,$req);
  my ($service_id,$sid,$date,$extype,$t0,$t1);
  my $filtercnt = 0;

  $calfname = $dir . '/' . 'calendar_dates.txt';

  info("reading $calfname");
  return info("dryrun") if $dryrun;

  open($calfile,'<',$calfname) or return info("no $calfname");
  my $headline = readline($calfile);
  error_exit("$calfname is empty",__LINE__) unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

#  info("'$headline'");

  my @colnames = split(',',$headline);
  my @cols;

  foreach $colname (@colnames) {
    $colid = $col_unknown;
    $colid = $col_serviceid if ($colname eq 'service_id');
    $colid = $col_date if ($colname eq 'date');
    $colid = $col_extype if ($colname eq 'exception_type');
    push(@cols,$colid);
  }
#  printf("%u of %u recognised fields\n",scalar @cols,scalar @colnames);
  warning("unknown fields") if (@cols < @colnames);

  foreach $req ('service_id','date','exception_type') {
    error_exit("missing required $req",__LINE__) unless inarray($req,@colnames);
  }

  my @lines = readline($calfile);
  close($calfile);
  error_exit("$calfname is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {
    $c = chop $line;
    $line .= $c if $c ne "\n";
    $c = chop $line;
    $line .= $c if $c ne "\r"; 

    $linno++;

    $line .= ',';

    $service_id = ''; $date = ''; $extype = '';
    foreach $col (@cols) {
      $comma = index($line,',');
      return error("line $linno: missing field",__LINE__) if $comma < 0;

      if ($col == $col_serviceid) {
        $service_id = substr($line,0,$comma);
      } elsif ($col == $col_date) {
        $date = substr($line,0,$comma);

      } elsif ($col == $col_extype) {
        $extype = substr($line,0,$comma);
      }

      $line = substr($line,$comma+1);

    } # each col

    if (length($service_id) == 0) {
      warning("$linno: missing service id");
      $filtercnt++;
      next;
    } elsif ($extype ne '1' and $extype ne '2') {
      warning("$linno: exception_type $extype not 1 or 2");
      $filtercnt++;
      next;
    } elsif (exists($serviceids{$service_id})) {  # modify existing regular sid
      $sid = $serviceids{$service_id};

      $t0 = $servicet0{$sid};
      $t1 = $servicet1{$sid};
      if ($extype == 1) {
        if ($date < $t0) {
          $servicet0{$sid} = $date;
        } elsif ($date > $t1) {
          $servicet1{$sid} = $date;
        }
        push (@{ $serviceadd{$sid} },$date);
        $mint0 = min($date,$mint0);
        $maxt1 = max($date,$maxt1);
      } elsif ($extype == 2) {
        if ($date < $t0) {
          warning("$linno: excluding day $date below $service_id range $t0 .. $t1");
        } elsif ($date > $t1) {
          warning("$linno: excluding day $date above $service_id range $t0 .. $t1");
        } else {
          push (@{ $servicesub{$sid} },$date);
        }
      }
    } elsif (exists($noserviceids{$service_id})) {
      vrb("$linno: service id $service_id previously filtered at calendar : $noserviceids{$service_id}");
      next;
    } elsif (exists($sids2ignore{$service_id})) {
      info("$linno: filter service id $service_id : $sids2ignore{$service_id}");
      $filtercnt++;
      next;
    } else {            # not in calendar.txt
      $sid = $linno;
      $serviceids{$service_id} = $sid;
      $servicet0{$sid} = $date;
      $servicet1{$sid} = $date;
      $servicedow{$sid} = 0;
      $serviceadd{$sid} = [($date)] if $extype == 1;
      $servicesub{$sid} = [($date)] if $extype == 2;
      $mint0 = min($date,$mint0);
      $maxt1 = max($date,$maxt1);
    }
  } # each line

  $sidcnt = scalar(keys %serviceids);
  info("$sidcnt services $filtercnt filtered, overall period $mint0 to $maxt1");

  return 1;
}

sub readstoptimes($)
{
  my ($dir) = @_;

  my ($stoptimes,$stoptimesname);
  my ($col,$colname,$line,$fldend,$endq,$c,$req);
  my ($route_id,$routeid,$trip_id,$tripid,$arr_time,$dep_time,$stop_id,$stopid,$stop_seq,$dep);
  my ($route,$trip,$seq,$hop,$dep_id,$arr_id);
  my ($service_id,$sid,$t0,$t1,$day,$dows);
  my ($concnt,$depcnt,$arrcnt,$parent,$parentid);

  return error("missing dir arg for import",__LINE__) unless defined $dir and length($dir);

  $stoptimesname = $dir . '/' . 'stop_times.txt';

  info("reading $stoptimesname");
  return info("dryrun") if $dryrun;

  open($stoptimes,'<',$stoptimesname) or return error("cannot open stop_times.txt:$!",__LINE__);
  my $headline = readline($stoptimes);
  error_exit("stoptimes.txt is empty",__LINE__) unless defined $headline and length($headline);
  $c = chop $headline;
  $headline .= $c if $c ne "\n"; 
  $c = chop $headline;
  $headline .= $c if $c ne "\r"; 

#  info("'$headline'");

  my @colnames = split(',',$headline);
  my @knowncols;
  my @cols;
  my $colid = 0;

  foreach $colname (@colnames) {
    $col_tripid = $colid++ if ($colname eq 'trip_id');
    $col_arrtime = $colid++ if ($colname eq 'arrival_time');
    $col_deptime = $colid++ if ($colname eq 'departure_time');
    $col_stopid = $colid++ if ($colname eq 'stop_id');
    $col_stopseq = $colid++ if ($colname eq 'stop_sequence');
    $col_picktype = $colid++ if ($colname eq 'pickup_type');
    $col_droptype = $colid++ if ($colname eq 'drop_off_type');
  }
#  printf("%u of %u recognised fields\n",$colid,scalar @colnames);
#  error_exit("unknown fields",__LINE__) if ($colid < @colnames);

  my @lines = readline($stoptimes);
  close($stoptimes);
  error_exit("stop_times.txt is empty",__LINE__) unless (@lines > 0);
  my $linno = 0;

  my $linecnt = scalar(@lines);
  my $prvseq = 0;
  my $prvtrip = 0;
  my $prvid = 0;
  my $prvtdep = 0;
  my $prvtarr = 0;
  my $prvstop_id = '';
  my $prvstopid = 0;

  my ($id,$uniqid,$uniqid1,$hoptime,$rtype,$name);

  my $hhmmpat = qr'^([0-9]+):([0-9]+)';
  my ($thh,$tmm,$tahh,$tamm,$tdepmin,$tarrmin,$tdummy,$tsep,$tsep2);

  my ($hdid,$haid,$did,$aid,$htdep,$htarr,$htdeparr);

  my $nottcnt = 0;

  info("$linecnt lines");

  $linno = 0;
  foreach $line (@lines) {

    $linno++;
#    last if ($linno > 10000);
    $c = chop $line;
    $line .= $c if $c ne "\n";

    @cols = split ',',$line;

    $prvstop_id = $stop_id;

    $trip_id = $cols[$col_tripid];
    $stop_id = $cols[$col_stopid];
    $stop_seq = $cols[$col_stopseq];
    $dep_time = $cols[$col_deptime];
    $arr_time = $cols[$col_arrtime];

    if (exists $stops2watch{$stop_id}) {
      info("$stop_id $line");
    }

    unless (exists($tripids{$trip_id})) {
      warning("$linno: undefined trip id $trip_id");
      next;
    }
    $tripid = $tripids{$trip_id};

    $prvseq = $stop_seq;

    $routeid = $triproutes{$trip_id};
    $route_id = $routebyids{$routeid};
    if (exists $norouteids{$route_id}) { # filtered
      info("filter $stop_id on route $route_id");
      next;
    }

    $rtype = $rtypes{$routeid};

    $service_id = $tripservice{$trip_id};
    $sid = $serviceids{$service_id};
    $sidrefs{$sid} = 1;
    $tripsids{$tripid} = $sid;

    $prvstopid = $stopid;

    $stopid = $stopids{$stop_id};

    if (exists($parentbyid{$stopid})) {
      $parent = $parentbyid{$stopid};
      $parent = $parentdups{$parent} if exists $parentdups{$parent};
      $parentid = $parentids{$parent};
      $id = $parentid;
    } else { $id = $stopid; }

    ($thh,$tmm) = ($dep_time =~ $hhmmpat);
    ($tahh,$tamm) = ($arr_time =~ $hhmmpat);

    if (defined $thh and defined $tmm) {
      $tahh = $thh unless defined $tahh;
      $tamm = $tmm unless defined $tamm;
    } elsif (defined $tahh and defined $tamm) {
      $thh = $tahh unless defined $thh;
      $tmm = $tamm unless defined $tmm;
    } elsif ($prvtdep > 0 and $prvtarr > 0) {
      $thh = $prvtdep / 60; $tmm = $prvtdep % 60;
      $tahh = $prvtarr / 60; $tamm = $prvtarr % 60;
    } else {
      $prvid = $id;
      $prvtrip = $tripid;
      $nottcnt++;
      info("line $linno stop $stop_id $stopnames{$stopid} has no time  $line");
      next;
    }

    $tdepmin = $thh * 60 + $tmm;
    $tarrmin = $tahh * 60 + $tamm;

    # actual hop derived from key lateron
    # note that seq can run back in time
    if ($prvtrip == $tripid) {
      if ($prvtdep <= $tarrmin) {
        $hdid = $prvid;
        $haid = $id;
        $did = $prvstopid;
        $aid = $stopid;
        $htdeparr = ($prvtdep << 16) | $tarrmin;
      } else {
        $haid = $prvid;
        $hdid = $id;
        $aid = $prvstopid;
        $did = $stopid;
        $htdeparr = ($tdepmin << 16) | $prvtarr;
      }

      # mark connectivity for individual stops, forward to parent later
      $uniqid1 = join('_',$routeid,$did,$aid);
      unless (exists($tripseq1{$uniqid1})) {
        $stopdeps[$did]++;
        $stoparrs[$aid]++;
      }

      if ($hdid == $haid) {
      } else {
        $uniqid = join('_',$routeid,$hdid,$haid);

        $sumtimes++;
        if (exists($tripseq{$uniqid})) {
          if (exists $stops2watch{$stop_id}) {
            info(" watch n $stop_id dep $stopnames{$hdid} arr $stopnames{$haid}");
            info(" watch n $stop_id dep $stopnames{$did} arr $stopnames{$aid}");
          }
          push @{ $tripseq{$uniqid} },($sid,$tripid,$htdeparr);
        } else {
          if (exists $stops2watch{$stop_id}) {
            info(" watch 0 $stop_id dep $stopnames{$hdid} arr $stopnames{$haid}");
            info(" watch 0 $stop_id dep $stopnames{$did} arr $stopnames{$aid}");
          }
          $tripref{$uniqid} = $linno;
          $tripseq{$uniqid} = [ ($sid,$tripid,$htdeparr) ];
          push @uniqids,$uniqid;

          $hopcnt++;
        }
      }
    }
    $prvtdep = $tdepmin;
    $prvtarr = $tarrmin;
    $prvid = $id;
    $prvtrip = $tripid;

    $ttcnt++;

    progress("line %u of %u",$linno,$linecnt) if ($linno % 100000) == 0;

  } # each line

  info("\n$ttcnt time entries, $nottcnt skipped, $hopcnt hops");

  # merge connectivity to parents
  my ($pid,$stoplst,@sibstop,$ndep,$narr);

  foreach $parent (keys %parents) {
    $parent = $parentdups{$parent} if exists $parentdups{$parent};
    $pid = $parentids{$parent};
    $stoplst = $parents{$parent};
    @sibstop = split(' ',trimws($stoplst));
    for $dep (@sibstop) {

      $ndep = $stopdeps[$dep];
      $narr = $stoparrs[$dep];

      $stopdeps[$pid] += $ndep;
      $stoparrs[$pid] += $narr;
    }
  }

  # show some connectivity stats
  if ($noroutecnt == 0) {
    while (($id,$stopid) = each %stopids) {
      if (exists $stops2watch{$id}) {
        $name = $stopnames{$stopid};
        info("stop $id $name $stops2watch{$id} has $stopdeps[$stopid] deps and $stoparrs[$stopid] arrs");
      }

      $name = $stopnames{$stopid};
      if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0) {
        warning("stop $id $name is unconnected");
      } elsif ($stopdeps[$stopid] == 0) {
        vrb("stop $id $name has no departures");
      } elsif ($stoparrs[$stopid] == 0) {
        vrb("stop $id $name has no arrivals");
      }
    }
  }

  info("-- connection stats --");
  foreach $concnt (0 .. 6) {
    $depcnt = 0; $arrcnt = 0;
    for $stopid (values %stopids) {
      $depcnt++ if $stopdeps[$stopid] == $concnt;
      $arrcnt++ if $stoparrs[$stopid] == $concnt;
    }
    info("stops with $concnt departures : $depcnt");
    info("stops with $concnt arrivals   : $arrcnt");
  }

  while (($service_id,$sid) = each %serviceids) {
    warning("service id $service_id not referenced") unless exists $sidrefs{$sid};
  }

  return 1;
}

sub import($)
{
  my ($dir) = @_;

  info("excluding bus") unless $include_bus;
  info("excluding train") unless $include_rail;
  info("excluding metro") unless $include_metro;
  info("excluding ferry") unless $include_ferry;

  readfeedinfo($dir);
  readagency($dir) or return 0;
  $agencyname = '(none)' unless defined $agencyname;

  rdgtfscfg($agencyname,$feedpublisher);

  readstops($dir) or return 0;
  readcalendar($dir) or return 0;
  readcaldates($dir) or return 0;
  readroutes($dir) or return 0;
  readtrips($dir) or return 0;
  readstoptimes($dir) or return 0;
  return 1;
}

sub getdate()
{
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($^T);

  return sprintf("%u-%02u-%02u %u:%02u utc",$year+1900,$mon+1,$mday,$hour,$min);
}

sub iniext($$)
{
  my ($name,$cnt) = @_;

  my $bckname = $name . '.bak';

  info("writing $cnt items to $name");

  unlink($bckname) if -f $bckname;
  rename($name,$bckname) if -f $name;
}

sub writext($$)
{
  my ($indir,$outdir) = @_;

  my ($name,$portfile,$hopfile,$stop,@stopln,$stopid,$hop,$route,$hopid);
  my ($dep_id,$arr_id,$dep,$arr,$fstopcnt,$depname,$arrname);
  my ($routeid,$rid,$rtype);
  my ($cnt);

  info("writing tripover external format");
  return info("dryrun") if $dryrun;

  $fstopcnt = $cnt = 0;
  for $stopid (values %stopids) {
    $fstopcnt++ if ($stopdeps[$stopid] > 0 or $stoparrs[$stopid] > 0);
  }
  $cnt = $stopcnt - $fstopcnt;
  warning("omitting $cnt unconnected ports") if $fstopcnt < $stopcnt;

  my $portname = $outdir . '/ports.txt';
  iniext($portname,$fstopcnt);

  open($portfile,'>:encoding(UTF-8)',$portname) or error_exit("cannot create $portname:$!",__LINE__);

  print($portfile "# ports.txt - tripover external port aka stops file\n\n");
  printf($portfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($portfile "# %u ports from %s/stops.txt\n\n",$fstopcnt,$indir);

  printf($portfile ".latscale\tD%u\n",$latscale);
  printf($portfile ".lonscale\tD%u\n\n",$lonscale);

  printf($portfile "# name\tid\tsubid\tlat\tlon\topts\n\n");

  my ($stop_id,$stopid_to,$stop_name,$stop_code,$stop_lat,$stop_lon,$lat,$lon,$desc,$opts);
  my ($parent,$parentid,$stopstr);
  my $portcnt = $parentcnt;

  while (($stopid,$stopstr) = each %stops) {
    @stopln = split("\t",$stopstr);  #  $name,$id,$parent,$lat,$lon,$code,$desc,$opts

    $stop_name = $stopln[0];

    $stop_id = $stopln[1];  # gtfs-view : stop_id.parent = stopid@tripover
    $stopid = $stopids{$stop_id};

    unless (defined $stopid) { warning("no id for stop $stop_id"); }
    next if ($stopdeps[$stopid] == 0 and $stoparrs[$stopid] == 0);

    $parent = $stopln[2];
    $lat = $stopln[3];
    $lon = $stopln[4];
    $stop_code = $stopln[5];
    $desc = $stopln[6];
    $opts = $stopln[7];
    $stop_code = '' unless defined $stop_code;
    $opts = 0 unless defined $opts;

#    info("port '$stop_name' code '$stop_code' desc '$desc' opt '$opts'");

    if (length($parent) > 0 and exists $parentids{$parent}) {
      warning("$parent equal to $stop_id") if $parent eq $stop_id;
      $parentid = $parentids{$parent};
      $stopid_to = $parentid;   # tripover-view  parent@gtfs = stopid_to
    } else {
      $stopid_to = $stopid;
      $portcnt++;
    }

    printf($portfile "%s\t%x\t%x\t%x\t%x\t%x\t# id %s code %s %s\n",$stop_name,$stopid_to,$stopid,$lat,$lon,$opts,$stop_id,$stop_code,$parent);
  }
  close($portfile);
  info("wrote $fstopcnt stops to $portcnt ports");

  my $timefile;
  my $timename = $outdir . '/times.txt';
  my ($service_id,$sid,$t0,$t1,$day,$dow,$addcnt,$subcnt,$addtimes,$subtimes);
  my @sidsubs;
  my @sidadds;

  iniext($timename,$sidcnt);

  open($timefile,'>',$timename) or error_exit("cannot create $timename:$!",__LINE__);
  print($timefile "# times.txt - tripover external timetable aka calendar file\n\n");
  printf($timefile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($timefile "# %u entries from %s\n\n",$sidcnt,$indir);

  printf($timefile ".dowstart\t'%s\t# day a week starts at : lsb in mask\n",$dowstart);
  printf($timefile ".timebox\t.%u\t.%u\t# time span in days\n",$mint0,$maxt1);
  printf($timefile ".utcofs\t.%u\t# minutes east of UTC +12h\n\n",$utcofs12);

  print($timefile "# service_id\tsid\tdow\tstart\tend\t# \n\n");

  while (($service_id,$sid) = each %serviceids) {
    next unless exists $sidrefs{$sid};
    $dow = $servicedow{$sid};
    $t0 = $servicet0{$sid};
    $t1 = $servicet1{$sid};
    if (defined $serviceadd{$sid}) {
      @sidadds = @{ $serviceadd{$sid} };
      $addcnt = @sidadds;
    } else { $subcnt = 0; }
    if (defined $servicesub{$sid}) {
      @sidsubs = @{ $servicesub{$sid} };
      $subcnt = @sidsubs;
    } else { $subcnt = 0; }
    $addtimes = $addcnt ? join("\t",@sidadds) : '';
    $subtimes = $subcnt ? join("\t",@sidsubs) : '';
    printf($timefile "%s\t%x\t%x\t..%u\t%u\t%u\t%u\t%s\t%s\n",$service_id,$sid,$dow,$t0,$t1,$addcnt,$subcnt,$addtimes,$subtimes);
  }
  close($timefile);

  my $hopname = $outdir . '/hops.txt';
  iniext($hopname,$hopcnt);

  open($hopfile,'>:encoding(UTF-8)',$hopname) or error_exit("cannot create $hopname:$!",__LINE__);
  print($hopfile "# hops.txt - tripover external hops aka trips file\n\n");
  printf($hopfile "# written by gtfstool %u.%u at %s\n",$version_maj,$version_min,getdate());
  printf($hopfile "# %u hops from %s/stoptimes.txt\n\n",$hopcnt,$indir);

  printf($hopfile ".variants\t%x\t%x\t# possible route variants\n",$maxvariant,$hivariant);
  printf($hopfile ".walk_id\t%x\t# route ID for inferred walk\n",$rtype_walk);
  printf($hopfile ".sumtimes\t.%u\t# total number of time entries\n",$sumtimes);
  printf($hopfile ".trips\t.%u\t# total number of trips\n",$tripcnt);
  printf($hopfile ".hitrip\t.%u\t# highest trip ID\n\n",$hitripid);

  print($hopfile "# route\tID\tfrom\tto\ttype\ttid\trid\t# from-name to-name\n\n");

  my ($uniqid,$hoptime,$mark,$ref,$fmt,$timestr);
  my $xinfo = '';
  my $hopno = 0;
  my @hopln;
  my @times;
  my @hoptimes;
  my ($tid,$tdep,$tarr,$tdeparr,$ztid,$ztdep,$ztarr,$prvsid,$prvtid,$prvtdep,$prvtarr);
  my ($timendx,$timecnt);

  foreach $uniqid (@uniqids) {

    @times = @{ $tripseq{$uniqid} };

    error_exit("invalid hop id $hopno",__LINE__) if ($hopno >= $hopcnt);

    @hopln = split('_',$uniqid);
    error_exit("missing hop arguments",__LINE__) if (@hopln < 3);

    $rid = $hopln[0];
    $dep = $hopln[1];
    $arr = $hopln[2];

    $hopid = $hopno;

    $timecnt = scalar @times;
    return error("$timecnt not a multiple of 3",__LINE__) if $timecnt % 3;
    $timecnt /= 3;

    $ref = $tripref{$uniqid};

    $depname = $stopnames{$dep};
    $arrname = $stopnames{$arr};

    if ($dep == $arr) {
      warning("hop $hopid dep $dep equals arr $depname");
      next;
    }
    warning("route ID $rid not found") unless exists $routebyids{$rid};
    $route = $routebyids{$rid};
    warning("route $route not found") unless exists $routeids{$route};

    warning("$route type not found") unless exists $rtypes{$rid};
    $rtype = $rtypes{$rid};
    $mark = ($rid eq $walkroute) ? 'walk ' : '';
    $route = '.' . $route if (substr($route,0,1) eq '.');
    $xinfo = "\t# $mark $ref $depname,$arrname" if ($verbose_hops > 0);

    ($sid,$tid,$tdeparr) = @times[0 .. 2];
    $tdep = $tdeparr >> 16;
    $tarr = $tdeparr & 0xffff;
    $timestr = sprintf("0\t%x\t%x\t%x\t%x",$sid,$tid,$tdep,$tarr);

    for ($timendx = 3; $timendx < $timecnt * 3; $timendx += 3) {
      $prvsid = $sid; $prvtid = $tid; $prvtdep = $tdep; $prvtarr = $tarr;
      ($sid,$tid,$tdeparr) = @times[$timendx .. $timendx + 2];
      $tdep = $tdeparr >> 16;
      $tarr = $tdeparr & 0xffff;
      $fmt = 0;
      if ($tid >= $prvtid) {
        $fmt |= $fmt_diftid;
        $ztid = $tid - $prvtid;
      } else { $ztid = $tid; }
      if ($tdep >= $prvtdep) {
        $fmt |= $fmt_difdep;
        $ztdep = $tdep - $prvtdep;
      } else { $ztdep = $tdep; }
      if ($tarr >= $prvtarr) {
        $fmt |= $fmt_difarr;
        $ztarr = $tarr - $prvtarr;
      } else { $ztarr = $tarr; }
      if ($sid == $prvsid) {
        $fmt |= $fmt_prvsid;
        $timestr .= sprintf("\t%x\t%x\t%x\t%x",$fmt,$ztid,$ztdep,$ztarr);
      } else {
        $timestr .= sprintf("\t%x\t%x\t%x\t%x\t%x",$fmt,$sid,$ztid,$ztdep,$ztarr);
      }

    }
    printf($hopfile "%s\t%x\t%x\t%x\t%x\t%x\tD%u\t%s%s\n",$route,$hopid,$dep,$arr,$rtype,$rid,$timecnt,$timestr,$xinfo);
    $hopno++;
  }
  return error("wrote 0 hops",__LINE__) if $hopno == 0;
  info("wrote $hopno hops");
  return 1;
}

my ($arg,$opt,$cmd,$indir,$outdir);
my @args;

if (@ARGV == 0) { usage(); exit 1; }

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'h' or $opt eq '?' or $opt eq 'help') { showvers(0); usage(); exit 1; }
    if ($opt eq 'V' or $opt eq 'version') { showvers(1); exit 1; }
    if ($opt eq 'L' or $opt eq 'license') { showvers(0); info("$license"); exit 1; }
  }
}

showvers(0);

foreach $arg (@ARGV) {
  if (substr($arg,0,1) eq '-') {
    $opt = $arg;
    $opt =~ s/^-+//;
    if ($opt eq 'v' or $opt eq 'verbose') { info('verbose mode'); $verbose = 1; }
    elsif ($opt eq 'n' or $opt eq 'dryrun') { info('dryrun mode'); $dryrun = 1; }
    elsif ($opt eq 'a' or $opt eq 'analysis') { info('analysis output enabled'); $anaout = 1; }
    elsif ($opt eq 'c' or $opt eq 'canonical') { info('canonical output enabled'); $canonout = 1; }
    elsif ($opt eq 'nobus') { $include_bus = 0; }
    elsif ($opt eq 'nometro') { $include_metro = 0; }
    elsif ($opt eq 'noferry') { $include_ferry = 0; }
    elsif ($opt eq 'notrain' or $opt eq 'norail') { $include_rail = 0; }
    else { info("ignoring unknown option -$opt"); }
  } else {
    push(@args,$arg);
  }
}
if (@args > 0) {
  init();
  $cmd = $args[0];
  if ($cmd eq 'import') {
    error_exit("missing arg 'dir' for import",__LINE__) unless (@args > 1);
    $indir = $args[1];
    $outdir = (@args > 2) ? $args[2] : '.';
    $anadir = $outdir;
    info("import from $indir to $outdir");
    import($indir) and writext($indir,$outdir);
  }
  else { info("unknown command"); }
}

my $usertime = times();
if ($usertime > 60) { info("elapsed time " . int($usertime / 60) . " min " . $usertime % 60 . " sec"); }
else { info("elapsed time $usertime seconds"); }

info("1 warning") if $warningcnt == 1;
info("$warningcnt warnings") if $warningcnt > 1;
info("1 error") if $errorcnt == 1;
info("$errorcnt errors") if $errorcnt > 1;

# POSIX::_exit($errorcnt > 0);
